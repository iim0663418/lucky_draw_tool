const PAGE_SIZE = 5;
let historyList = [];
let currentPage = 1;

// 3D Â†¥ÊôØÁõ∏ÈóúËÆäÊï∏
let scene, camera, renderer;
let cssScene, cssRenderer;
let cards = [];
let cssCards = [];
let animationId;

// ÂàùÂßãÂåñ 3D Â†¥ÊôØ
function initThreeScene() {
  const canvas = document.getElementById('three-canvas');
  
  // ÂâµÂª∫Â†¥ÊôØ
  scene = new THREE.Scene();
  
  // ÂâµÂª∫ÊîùÂΩ±Ê©ü
  camera = new THREE.PerspectiveCamera(
    45, // Á∏ÆÂ∞èË¶ñËßí (FOV)ÔºåÈ°û‰ººÈï∑ÁÑ¶Èè°È†≠ÔºåÊîæÂ§ß‰∏ªÈ´î
    window.innerWidth / window.innerHeight, // Èï∑ÂØ¨ÊØî
    0.1, // ËøëË£ÅÂâ™Èù¢
    1000 // ÈÅ†Ë£ÅÂâ™Èù¢
  );
  camera.position.z = 3.5; // ÊîùÂΩ±Ê©üÁ®çÂæÆÈù†Ëøë
  
  // ÂâµÂª∫Ê∏≤ÊüìÂô® - ÈáùÂ∞çË∂ÖÈ´òÂìÅË≥™ÊñáÂ≠óÂÑ™Âåñ
  renderer = new THREE.WebGLRenderer({ 
    canvas: canvas,
    alpha: true, // ÈÄèÊòéËÉåÊôØ
    antialias: true, // ÊäóÈã∏ÈΩí
    powerPreference: "high-performance", // È´òÊïàËÉΩ
    precision: "highp", // È´òÁ≤æÂ∫¶
    stencil: false,
    depth: true,
    logarithmicDepthBuffer: false
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  // Â∞çÊñºË∂ÖÈ´òÂìÅË≥™ÊñáÂ≠óÔºå‰ΩøÁî®ÂÆåÊï¥ÁöÑË®≠ÂÇôÂÉèÁ¥†ÊØî
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 3)); 
  renderer.outputEncoding = THREE.sRGBEncoding;
  
  // ÂïüÁî®Êõ¥Â•ΩÁöÑÊùêË≥™ÈÅéÊøæ
  renderer.capabilities.getMaxAnisotropy && 
  renderer.capabilities.getMaxAnisotropy() > 1 && 
  (renderer.anisotropySupport = renderer.capabilities.getMaxAnisotropy());
  
  // Ë®≠ÁΩÆ canvas Ê®£Âºè
  canvas.style.position = 'absolute';
  canvas.style.top = '0';
  canvas.style.left = '0';
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.pointerEvents = 'none';
  canvas.style.zIndex = '1';
  
  // ÂâµÂª∫ CSS3D Â†¥ÊôØÂíåÊ∏≤ÊüìÂô®ÔºàÁî®ÊñºÊ∏ÖÊô∞ÊñáÂ≠óÔºâ
  if (typeof THREE.CSS3DRenderer !== 'undefined') {
    cssScene = new THREE.Scene();
    cssRenderer = new THREE.CSS3DRenderer();
    cssRenderer.setSize(window.innerWidth, window.innerHeight);
    cssRenderer.domElement.style.position = 'absolute';
    cssRenderer.domElement.style.top = '0';
    cssRenderer.domElement.style.left = '0';
    cssRenderer.domElement.style.pointerEvents = 'none';
    cssRenderer.domElement.style.zIndex = '2'; // Âú® WebGL ‰πã‰∏ä
    
    // Â∞á CSS3D Ê∏≤ÊüìÂô®Ê∑ªÂä†Âà∞ overlay
    const overlay = document.getElementById('overlay');
    overlay.appendChild(cssRenderer.domElement);
  } else {
    console.warn('CSS3DRenderer not available, falling back to WebGL only');
    cssScene = null;
    cssRenderer = null;
  }
  
  // Âä†ÂÖ•Âü∫Êú¨ÂÖâÁÖß
  const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // Áí∞Â¢ÉÂÖâ
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Âπ≥Ë°åÂÖâ
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);
}

// ÂâµÂª∫Ë∂ÖÈ´òÂìÅË≥™ÊñáÂ≠óÊùêË≥™ÁöÑÂáΩÊï∏ (SDF-like approach)
function createUltraTextTexture(text, fontSize = 48, textColor = '#ffffff', bgColor = '#2ECC71') {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  
  // Ê•µÈ´òËß£ÊûêÂ∫¶Ôºö4K ÊùêË≥™Áî®ÊñºÊúÄÈ´òÂìÅË≥™
  const superRes = 4; // Ë∂ÖÊé°Ê®£ÂÄçÊï∏
  const baseWidth = 2048;
  const baseHeight = 1024;
  canvas.width = baseWidth * superRes;
  canvas.height = baseHeight * superRes;
  
  // Ë®≠ÁΩÆËÉåÊôØ
  context.fillStyle = bgColor;
  context.fillRect(0, 0, canvas.width, canvas.height);
  
  // ÂïüÁî®ÊâÄÊúâÂèØÁî®ÁöÑÊ∏≤ÊüìÂÑ™Âåñ
  context.textRenderingOptimization = 'optimizeQuality';
  context.imageSmoothingEnabled = true;
  context.imageSmoothingQuality = 'high';
  context.mozImageSmoothingEnabled = true;
  context.webkitImageSmoothingEnabled = true;
  context.msImageSmoothingEnabled = true;
  
  // Ë®≠ÁΩÆÊ•µÈ´òÂìÅË≥™ÁöÑÊñáÂ≠óÊ®£Âºè
  const scaledFontSize = fontSize * 4 * superRes;
  context.fillStyle = textColor;
  context.font = `bold ${scaledFontSize}px 'SF Pro Display', 'PingFang TC', 'Noto Sans TC', 'Microsoft JhengHei', 'Helvetica Neue', Arial, sans-serif`;
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  
  // Ê∑ªÂä†ÊñáÂ≠óÊèèÈÇä‰ª•Â¢ûÂº∑Ê∏ÖÊô∞Â∫¶
  context.strokeStyle = 'rgba(0, 0, 0, 0.1)';
  context.lineWidth = 2 * superRes;
  context.strokeText(text, canvas.width / 2, canvas.height / 2);
  
  // Áπ™Ë£Ω‰∏ªÊñáÂ≠ó
  context.fillText(text, canvas.width / 2, canvas.height / 2);
  
  // ÂâµÂª∫ÊùêË≥™
  const texture = new THREE.CanvasTexture(canvas);
  
  // ÂÑ™ÂåñÊùêË≥™Ë®≠ÂÆö
  texture.generateMipmaps = true;
  texture.minFilter = THREE.LinearMipmapLinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.format = THREE.RGBAFormat;
  texture.flipY = false; // ÈÅøÂÖç‰∏ä‰∏ãÁøªËΩâ
  
  // Â¶ÇÊûúÊîØÊåÅÂêÑÂêëÁï∞ÊÄßÈÅéÊøæÔºåÂïüÁî®ÊúÄÈ´òÁ¥öÂà•
  if (renderer && renderer.capabilities) {
    const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
    if (maxAnisotropy > 1) {
      texture.anisotropy = maxAnisotropy;
    }
  }
  
  return new THREE.MeshBasicMaterial({ 
    map: texture,
    transparent: true,
    alphaTest: 0.1,
    side: THREE.FrontSide
  });
}

// ÂâµÂª∫ÂÆåÁæéÊ∏ÖÊô∞ÁöÑ CSS3D ÊñáÂ≠óÂç°Áâá
function createCSSCard(winnerName) {
  // Ê™¢Ê∏¨ÊöóËâ≤‰∏ªÈ°å
  const isDarkMode = document.body.classList.contains('dark');
  
  // ÂâµÂª∫ HTML ÂÖÉÁ¥†
  const cardElement = document.createElement('div');
  cardElement.className = 'css-card';
  cardElement.innerHTML = `
    <div class="card-front">
      <div class="card-content">
        <div class="card-text">${winnerName}</div>
        <div class="card-decoration">üèÜ</div>
      </div>
    </div>
    <div class="card-back">
      <div class="logo-container">
        <div class="logo-circle">
          <div class="logo-text">moda</div>
          <div class="logo-subtitle">LUCKY DRAW</div>
        </div>
        <div class="decoration-dots"></div>
      </div>
    </div>
  `;
  
  // Âç°Áâá‰∏ªÂÆπÂô®Ê®£Âºè
  cardElement.style.width = '400px';
  cardElement.style.height = '240px';
  cardElement.style.position = 'relative';
  cardElement.style.transformStyle = 'preserve-3d';
  cardElement.style.borderRadius = '16px';
  cardElement.style.overflow = 'hidden';
  
  // Ê≠£Èù¢Ê®£Âºè
  const cardFront = cardElement.querySelector('.card-front');
  cardFront.style.position = 'absolute';
  cardFront.style.width = '100%';
  cardFront.style.height = '100%';
  cardFront.style.background = isDarkMode ? 
    'linear-gradient(135deg, #00d260, #00b851)' : 
    'linear-gradient(135deg, #2ECC71, #27AE60)';
  cardFront.style.borderRadius = '16px';
  cardFront.style.boxShadow = '0 15px 35px rgba(0,0,0,0.3)';
  cardFront.style.display = 'flex';
  cardFront.style.alignItems = 'center';
  cardFront.style.justifyContent = 'center';
  cardFront.style.backfaceVisibility = 'hidden';
  cardFront.style.border = '3px solid rgba(255,255,255,0.3)';
  
  // ËÉåÈù¢Ê®£Âºè
  const cardBack = cardElement.querySelector('.card-back');
  cardBack.style.position = 'absolute';
  cardBack.style.width = '100%';
  cardBack.style.height = '100%';
  cardBack.style.background = isDarkMode ?
    'radial-gradient(circle at center, #161b22 0%, #0d1117 70%, #010409 100%)' :
    'radial-gradient(circle at center, #ffffff 0%, #f8f9fa 70%, #e9ecef 100%)';
  cardBack.style.borderRadius = '16px';
  cardBack.style.boxShadow = '0 15px 35px rgba(0,0,0,0.3)';
  cardBack.style.display = 'flex';
  cardBack.style.alignItems = 'center';
  cardBack.style.justifyContent = 'center';
  cardBack.style.backfaceVisibility = 'hidden';
  cardBack.style.transform = 'rotateY(180deg)';
  cardBack.style.border = isDarkMode ?
    '3px solid rgba(0,210,96,0.4)' :
    '3px solid rgba(46,204,113,0.3)';
  
  // Logo ÂÆπÂô®
  const logoContainer = cardElement.querySelector('.logo-container');
  logoContainer.style.position = 'relative';
  logoContainer.style.width = '100%';
  logoContainer.style.height = '100%';
  logoContainer.style.display = 'flex';
  logoContainer.style.alignItems = 'center';
  logoContainer.style.justifyContent = 'center';
  
  // Logo ÂúìÂΩ¢ËÉåÊôØ
  const logoCircle = cardElement.querySelector('.logo-circle');
  logoCircle.style.position = 'relative';
  logoCircle.style.width = '160px';
  logoCircle.style.height = '160px';
  logoCircle.style.background = isDarkMode ?
    'radial-gradient(circle, #00d260 0%, #00b851 100%)' :
    'radial-gradient(circle, #2ECC71 0%, #27AE60 100%)';
  logoCircle.style.borderRadius = '50%';
  logoCircle.style.display = 'flex';
  logoCircle.style.flexDirection = 'column';
  logoCircle.style.alignItems = 'center';
  logoCircle.style.justifyContent = 'center';
  logoCircle.style.boxShadow = isDarkMode ?
    '0 8px 25px rgba(0,210,96,0.5), inset 0 2px 10px rgba(255,255,255,0.2)' :
    '0 8px 25px rgba(46,204,113,0.4), inset 0 2px 10px rgba(255,255,255,0.3)';
  logoCircle.style.border = '2px solid rgba(255,255,255,0.4)';
  
  // Logo ÊñáÂ≠ó
  const logoText = cardElement.querySelector('.logo-text');
  logoText.style.color = '#ffffff';
  logoText.style.fontSize = '28px';
  logoText.style.fontWeight = 'bold';
  logoText.style.fontFamily = "'SF Pro Display', 'PingFang TC', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif";
  logoText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
  logoText.style.letterSpacing = '1px';
  
  // Logo ÂâØÊ®ôÈ°å
  const logoSubtitle = cardElement.querySelector('.logo-subtitle');
  logoSubtitle.style.color = 'rgba(255,255,255,0.9)';
  logoSubtitle.style.fontSize = '10px';
  logoSubtitle.style.fontWeight = 'bold';
  logoSubtitle.style.fontFamily = "'SF Pro Display', 'PingFang TC', 'Noto Sans TC', sans-serif";
  logoSubtitle.style.marginTop = '2px';
  logoSubtitle.style.letterSpacing = '2px';
  
  // Ê≠£Èù¢ÂÖßÂÆπÊ®£Âºè
  const cardContent = cardElement.querySelector('.card-content');
  cardContent.style.display = 'flex';
  cardContent.style.flexDirection = 'column';
  cardContent.style.alignItems = 'center';
  cardContent.style.gap = '10px';
  
  const cardText = cardElement.querySelector('.card-text');
  cardText.style.color = 'white';
  cardText.style.fontSize = '32px';
  cardText.style.fontWeight = 'bold';
  cardText.style.fontFamily = "'PingFang TC', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif";
  cardText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
  cardText.style.letterSpacing = '1px';
  
  const cardDecoration = cardElement.querySelector('.card-decoration');
  cardDecoration.style.fontSize = '24px';
  cardDecoration.style.opacity = '0.8';
  
  // ÂâµÂª∫ CSS3D Áâ©‰ª∂
  const cssObject = new THREE.CSS3DObject(cardElement);
  
  // Ë®≠ÁΩÆÂàùÂßãËÆäÊèõ
  cssObject.scale.set(0.006, 0.006, 0.006); // Ë™øÊï¥Âà∞ÂêàÈÅ©ÁöÑ 3D Á©∫ÈñìÂ§ßÂ∞è
  
  return cssObject;
}

// Áπ™Ë£ΩÁ≤æÁæéÁöÑÂæåÂÇô Logo
function drawFallbackLogo(context) {
  const centerX = 512;
  const centerY = 256;
  
  // Ê™¢Ê∏¨ÊöóËâ≤‰∏ªÈ°å
  const isDarkMode = document.body.classList.contains('dark');
  
  // Ë®≠ÁΩÆÈ´òÂìÅË≥™ÁöÑËÉåÊôØÊº∏Â±§
  const bgGradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, 400);
  if (isDarkMode) {
    bgGradient.addColorStop(0, '#161b22');
    bgGradient.addColorStop(0.7, '#0d1117');
    bgGradient.addColorStop(1, '#010409');
  } else {
    bgGradient.addColorStop(0, '#ffffff');
    bgGradient.addColorStop(0.7, '#f8f9fa');
    bgGradient.addColorStop(1, '#e9ecef');
  }
  context.fillStyle = bgGradient;
  context.fillRect(0, 0, 1024, 512);
  
  // ‰∏ªË¶ÅÂúìÂΩ¢ËÉåÊôØ - Êõ¥Â§ßÊõ¥Áèæ‰ª£
  context.beginPath();
  context.arc(centerX, centerY, 140, 0, Math.PI * 2);
  const mainGradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, 140);
  if (isDarkMode) {
    mainGradient.addColorStop(0, '#00d260');
    mainGradient.addColorStop(1, '#00b851');
  } else {
    mainGradient.addColorStop(0, '#2ECC71');
    mainGradient.addColorStop(1, '#27AE60');
  }
  context.fillStyle = mainGradient;
  context.fill();
  
  // ÂÖßÂúàË£ùÈ£æÂúì
  context.beginPath();
  context.arc(centerX, centerY, 100, 0, Math.PI * 2);
  context.strokeStyle = 'rgba(255, 255, 255, 0.3)';
  context.lineWidth = 2;
  context.stroke();
  
  // È´òÂÖâÊïàÊûú
  context.beginPath();
  context.arc(centerX - 40, centerY - 40, 80, 0, Math.PI * 2);
  const glossGradient = context.createRadialGradient(centerX - 40, centerY - 40, 0, centerX - 40, centerY - 40, 80);
  glossGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
  glossGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.1)');
  glossGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  context.fillStyle = glossGradient;
  context.fill();
  
  // ÂìÅÁâåÂêçÁ®± "moda" - Êõ¥Áèæ‰ª£ÁöÑÂ≠óÈ´î
  context.fillStyle = '#ffffff';
  context.font = 'bold 68px "SF Pro Display", "PingFang TC", "Noto Sans TC", "Microsoft JhengHei", sans-serif';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  
  // Âº∑ÂåñÊñáÂ≠óÈô∞ÂΩ±
  context.shadowColor = 'rgba(0, 0, 0, 0.6)';
  context.shadowOffsetX = 3;
  context.shadowOffsetY = 3;
  context.shadowBlur = 6;
  
  context.fillText('moda', centerX, centerY - 10);
  
  // Ê∏ÖÈô§Èô∞ÂΩ±Ë®≠ÂÆö
  context.shadowColor = 'transparent';
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 0;
  
  // ÂâØÊ®ôÈ°å
  context.fillStyle = 'rgba(255, 255, 255, 0.9)';
  context.font = 'bold 24px "SF Pro Display", "PingFang TC", "Noto Sans TC", sans-serif';
  context.fillText('LUCKY DRAW', centerX, centerY + 40);
  
  // Ë£ùÈ£æÊÄßÂ∞èÂúìÈªû - Êõ¥Á≤æÁ∑ªÁöÑÊéíÂàó
  const decorationPoints = [
    { x: centerX - 80, y: centerY - 80, size: 6 },
    { x: centerX + 80, y: centerY - 80, size: 6 },
    { x: centerX - 80, y: centerY + 80, size: 6 },
    { x: centerX + 80, y: centerY + 80, size: 6 },
    { x: centerX, y: centerY - 110, size: 4 },
    { x: centerX, y: centerY + 110, size: 4 },
    { x: centerX - 110, y: centerY, size: 4 },
    { x: centerX + 110, y: centerY, size: 4 }
  ];
  
  decorationPoints.forEach(point => {
    context.beginPath();
    context.arc(point.x, point.y, point.size, 0, Math.PI * 2);
    context.fillStyle = 'rgba(255, 255, 255, 0.8)';
    context.fill();
    
    // Â∞èÂÖâÊöàÊïàÊûú
    context.beginPath();
    context.arc(point.x, point.y, point.size * 1.5, 0, Math.PI * 2);
    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
    context.fill();
  });
  
  // Â§ñÂúàË£ùÈ£æÁí∞
  context.beginPath();
  context.arc(centerX, centerY, 160, 0, Math.PI * 2);
  context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
  context.lineWidth = 3;
  context.stroke();
}

// ÂâµÂª∫ Logo ÊùêË≥™ÁöÑÂáΩÊï∏
function createLogoTexture() {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  
  // ÊèêÈ´òËß£ÊûêÂ∫¶
  const pixelRatio = window.devicePixelRatio || 1;
  canvas.width = 1024 * pixelRatio;
  canvas.height = 512 * pixelRatio;
  canvas.style.width = '1024px';
  canvas.style.height = '512px';
  
  // Á∏ÆÊîæ context
  context.scale(pixelRatio, pixelRatio);
  
  // Ë®≠ÁΩÆËÉåÊôØÈ°èËâ≤
  context.fillStyle = '#f8f9fa';
  context.fillRect(0, 0, 1024, 512);
  
  // ÂïüÁî®ÂúñÁâáÂèçÈã∏ÈΩí
  context.imageSmoothingEnabled = true;
  context.imageSmoothingQuality = 'high';
  
  // ÂòóË©¶ËºâÂÖ•ÂØ¶Èöõ Logo ÂúñÁâá
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = function() {
    // ÂúñÁâáËºâÂÖ•ÊàêÂäüÔºåÁπ™Ë£ΩÂà∞ canvas ‰∏ä
    const scale = Math.min(1024 / img.width, 512 / img.height) * 0.8;
    const width = img.width * scale;
    const height = img.height * scale;
    const x = (1024 - width) / 2;
    const y = (512 - height) / 2;
    
    context.drawImage(img, x, y, width, height);
  };
  img.onerror = function() {
    // ÂúñÁâáËºâÂÖ•Â§±ÊïóÔºå‰ΩøÁî®Á≤æÁæéÁöÑÂæåÂÇôË®≠Ë®à
    drawFallbackLogo(context);
  };
  
  // ËºâÂÖ•ÂØ¶Èöõ Logo
  img.src = 'https://yt3.googleusercontent.com/D9Q7NjE7vztVgb0c2-OwofJtZOdFjghZWLw0Yj17dW9X9oMrve4Xt-16vN4tOvAvxcRu43TR=s900-c-k-c0x00ffffff-no-rj';
  
  // ÂÖàË®≠ÁΩÆÈ†êË®≠ÂÖßÂÆπ
  drawFallbackLogo(context);
  
  const texture = new THREE.CanvasTexture(canvas);
  
  // ÂïüÁî® Mipmap ÁîüÊàê‰ª•Áç≤ÂæóÊõ¥Â•ΩÁöÑÊ∏≤ÊüìÂìÅË≥™
  texture.generateMipmaps = true;
  
  // ‰ΩøÁî®ÊúÄÈ´òÂìÅË≥™ÁöÑ Mipmap ÁØ©ÈÅ∏Âô®
  texture.minFilter = THREE.LinearMipmapLinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.format = THREE.RGBAFormat;
  return new THREE.MeshBasicMaterial({ map: texture });
}

// ÂâµÂª∫ 3D Âç°ÁâåÁöÑÂ∑•Âª†ÂáΩÂºè
function createWinnerCard(winnerName) {
  // ÈÄ≤‰∏ÄÊ≠•ÊîæÂ§ßÂ∞∫ÂØ∏‰ª•Áç≤ÂæóÊúÄÂ§ßÊ∏ÖÊô∞Â∫¶
  const cardWidth = 2.5;
  const cardHeight = 1.5; // ÊåâÊØî‰æãÊîæÂ§ß
  const cardDepth = 0.05;
  const geometry = new THREE.BoxGeometry(cardWidth, cardHeight, cardDepth);
  
  // ÂâµÂª∫ 6 Èù¢ÊùêË≥™Èô£Âàó
  const materials = [
    // Âè≥ÂÅ¥Èù¢ (Á¥¢Âºï 0)
    new THREE.MeshBasicMaterial({ color: 0x333333 }),
    // Â∑¶ÂÅ¥Èù¢ (Á¥¢Âºï 1)  
    new THREE.MeshBasicMaterial({ color: 0x333333 }),
    // ‰∏äÂÅ¥Èù¢ (Á¥¢Âºï 2)
    new THREE.MeshBasicMaterial({ color: 0x333333 }),
    // ‰∏ãÂÅ¥Èù¢ (Á¥¢Âºï 3)
    new THREE.MeshBasicMaterial({ color: 0x333333 }),
    // Ê≠£Èù¢ - ÂæóÁçéËÄÖÂßìÂêç (Á¥¢Âºï 4) - ‰ΩøÁî®Ë∂ÖÈ´òÂìÅË≥™ÊñáÂ≠óÊ∏≤Êüì
    createUltraTextTexture(winnerName, 72, '#ffffff', '#2ECC71'),
    // ËÉåÈù¢ - Logo (Á¥¢Âºï 5)
    createLogoTexture()
  ];
  
  // ÂâµÂª∫Á∂≤Ê†º
  const card = new THREE.Mesh(geometry, materials);
  
  return card;
}

// ÂãïÁï´Âæ™Áí∞
function animate() {
  animationId = requestAnimationFrame(animate);
  
  // Â¶ÇÊûúÊúâÂãïÁï´Â∫´ÔºàTWEEN.jsÔºâÔºåÊõ¥Êñ∞Ë£úÈñìÂãïÁï´
  if (typeof TWEEN !== 'undefined') {
    TWEEN.update();
  }
  
  // Ê∏≤Êüì WebGL Â†¥ÊôØÔºàËÉåÊôØÂíåÊïàÊûúÔºâ
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
  
  // Ê∏≤Êüì CSS3D Â†¥ÊôØÔºàÊ∏ÖÊô∞ÊñáÂ≠óÔºâ
  if (cssRenderer && cssScene && camera) {
    cssRenderer.render(cssScene, camera);
  }
}

// ÂÅúÊ≠¢ÂãïÁï´Âæ™Áí∞
function stopAnimation() {
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
}

// Ê∏ÖÁêÜ 3D Â†¥ÊôØ
function cleanupThreeScene() {
  // ÂÅúÊ≠¢ÂãïÁï´
  stopAnimation();
  
  // Ê∏ÖÁêÜÂç°Áâå
  cards.forEach(card => {
    if (card.geometry) card.geometry.dispose();
    if (card.material) {
      if (Array.isArray(card.material)) {
        card.material.forEach(mat => {
          if (mat.map) mat.map.dispose();
          mat.dispose();
        });
      } else {
        if (card.material.map) card.material.map.dispose();
        card.material.dispose();
      }
    }
    if (scene) scene.remove(card);
  });
  cards = [];
  
  // Ê∏ÖÁêÜ CSS3D Âç°Áâå
  cssCards.forEach(cssCard => {
    if (cssScene) cssScene.remove(cssCard);
    if (cssCard.element && cssCard.element.parentNode) {
      cssCard.element.parentNode.removeChild(cssCard.element);
    }
  });
  cssCards = [];
  
  // Ê∏ÖÁêÜÊ∏≤ÊüìÂô®
  if (renderer) {
    renderer.dispose();
    renderer = null;
  }
  
  if (cssRenderer && cssRenderer.domElement) {
    const overlay = document.getElementById('overlay');
    if (overlay && cssRenderer.domElement.parentNode === overlay) {
      overlay.removeChild(cssRenderer.domElement);
    }
    cssRenderer = null;
  }
  
  // Ê∏ÖÁêÜÂ†¥ÊôØÂíåÊîùÂΩ±Ê©ü
  scene = null;
  cssScene = null;
  camera = null;
}

// Ë®àÁÆóÊúÄÁµÇÁ∂≤Ê†º‰ΩàÂ±Ä‰ΩçÁΩÆ (V3 - Á≤æÊ∫ñË®àÁÆóÈÇäÁïå)
function calculateGridLayout(cardCount) {
  // --- 1. Ë®àÁÆóÊîùÂΩ±Ê©üÂú® Z=0 Âπ≥Èù¢‰∏äÁöÑÂèØË¶ñÁØÑÂúç ---
  const fovInRadians = (camera.fov * Math.PI) / 180;
  const visibleHeight = 2 * Math.tan(fovInRadians / 2) * camera.position.z;
  const visibleWidth = visibleHeight * camera.aspect;

  // --- 2. ÂàùÂßã‰ΩàÂ±ÄË®àÁÆó ---
  const positions = [];
  const cardBaseWidth = 2.5;
  const cardBaseHeight = 1.5;
  const padding = 0.5;
  const cardWidthWithPadding = cardBaseWidth + padding;
  const cardHeightWithPadding = cardBaseHeight + padding;

  const maxCols = Math.floor(visibleWidth / cardWidthWithPadding);
  const cols = Math.min(cardCount, maxCols > 0 ? maxCols : 1);
  const rows = Math.ceil(cardCount / cols);

  // --- 3. [ÊúÄÁµÇ‰øÆÊ≠£] Á≤æÊ∫ñË®àÁÆóÁ∂≤Ê†º‰ΩîÁî®ÁöÑÂØ¶ÈöõÁ©∫Èñì ---
  // ‰ΩîÁî®ÂØ¨Â∫¶ = (Ê¨ÑÊï∏-1)*ÈñìË∑ù + Âç°ÁâåËá™Ë∫´ÂØ¨Â∫¶
  // ‰ΩîÁî®È´òÂ∫¶ = (ÂàóÊï∏-1)*ÈñìË∑ù + Âç°ÁâåËá™Ë∫´È´òÂ∫¶
  const occupiedWidth = (cols - 1) * cardWidthWithPadding + cardBaseWidth;
  const occupiedHeight = (rows - 1) * cardHeightWithPadding + cardBaseHeight;

  // --- 4. Ê™¢Ê∏¨ÊòØÂê¶Ë∂ÖÂá∫ÂèØË¶ñÁØÑÂúç‰∏¶Ë®àÁÆóÁ∏ÆÊîæÊØî‰æã ---
  let scale = 1.0;
  // ÁÇ∫‰∫ÜÁïôÂá∫ÈÇäÁïåÔºåÊàëÂÄëÁî® 90% ÁöÑÂèØË¶ñÁØÑÂúç‰æÜÊØîËºÉ
  const safeVisibleWidth = visibleWidth * 0.9;
  const safeVisibleHeight = visibleHeight * 0.9;
  
  // ‰ΩøÁî®‰øÆÊ≠£ÂæåÁöÑ‰ΩîÁî®ÂØ¨È´òÈÄ≤Ë°åÂà§Êñ∑
  if (occupiedWidth > safeVisibleWidth) {
    scale = Math.min(scale, safeVisibleWidth / occupiedWidth);
  }
  if (occupiedHeight > safeVisibleHeight) {
    scale = Math.min(scale, safeVisibleHeight / occupiedHeight);
  }

  // --- 5. ÁîüÊàêÊúÄÁµÇ‰ΩçÁΩÆ (ÊáâÁî®Á∏ÆÊîæ) ---
  const finalGridWidth = (cols - 1) * cardWidthWithPadding;
  const finalGridHeight = (rows - 1) * cardHeightWithPadding;
  const startX = -finalGridWidth / 2;
  const startY = finalGridHeight / 2;

  for (let i = 0; i < cardCount; i++) {
    const row = Math.floor(i / cols);
    const col = i % cols;
    
    positions.push({
      x: (startX + col * cardWidthWithPadding) * scale,
      y: (startY - row * cardHeightWithPadding) * scale,
      z: 0
    });
  }

  // ËøîÂõû‰ΩçÁΩÆÂíåÁ∏ÆÊîæÊØî‰æã
  return { positions, scale };
}

// ÂêåÊ≠• WebGL Âíå CSS3D Âç°ÁâåÂãïÁï´ (V2 - Âä†ÂÖ• gridScale)
function animateCardPair(webglCard, cssCard, finalPosition, gridScale, delay = 0) {
  return new Promise((resolve) => {
    // ÈöéÊÆµ1ÔºöËµ∑ÂßãÁãÄÊÖã (ÈÉΩÂú®‰∏≠ÂøÉÂæåÊñπ)
    webglCard.position.set(0, 0, -2);
    webglCard.rotation.set(0, Math.PI, 0); // ËÉåÈù¢ÊúùÂâç
    webglCard.scale.set(0.1, 0.1, 0.1); // ÂæàÂ∞è
    
    // CSS3D Âç°ÁâáÂêåÊ≠•ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
    if (cssCard) {
      cssCard.position.copy(webglCard.position);
      cssCard.rotation.copy(webglCard.rotation);
      cssCard.scale.set(0.0006, 0.0006, 0.0006); // CSS3D ÈúÄË¶ÅÊõ¥Â∞èÁöÑÁ∏ÆÊîæ
    }
    
    // ÈöéÊÆµ2ÔºöÈ£õËàûÁãÄÊÖã (Èö®Ê©üÊï£Èñã)
    const randomX = (Math.random() - 0.5) * 8;
    const randomY = (Math.random() - 0.5) * 6;
    const randomZ = Math.random() * 3 + 1;
    
    setTimeout(() => {
      // WebGL Âç°ÁâáÂãïÁï´
      new TWEEN.Tween(webglCard.position)
        .to({ x: randomX, y: randomY, z: randomZ }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .onUpdate(() => {
          if (cssCard) cssCard.position.copy(webglCard.position);
        })
        .start();
        
      new TWEEN.Tween(webglCard.scale)
        .to({ x: 1, y: 1, z: 1 }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .onUpdate(() => {
          if (cssCard) {
            cssCard.scale.set(
              webglCard.scale.x * 0.006, 
              webglCard.scale.y * 0.006, 
              webglCard.scale.z * 0.006
            );
          }
        })
        .start();
        
      new TWEEN.Tween(webglCard.rotation)
        .to({ x: Math.random() * Math.PI, y: Math.random() * Math.PI, z: Math.random() * Math.PI }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .onUpdate(() => {
          if (cssCard) cssCard.rotation.copy(webglCard.rotation);
        })
        .onComplete(() => {
          // ÈöéÊÆµ3ÔºöÈ£õÂà∞ÊúÄÁµÇ‰ΩçÁΩÆ‰∏¶ÁøªËΩâÂà∞Ê≠£Èù¢
          setTimeout(() => {
            new TWEEN.Tween(webglCard.position)
              .to(finalPosition, 1500)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => {
                if (cssCard) cssCard.position.copy(webglCard.position);
              })
              .start();
              
            new TWEEN.Tween(webglCard.rotation)
              .to({ x: 0, y: 0, z: 0 }, 1500) // Ê≠£Èù¢ÊúùÂâç
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => {
                if (cssCard) cssCard.rotation.copy(webglCard.rotation);
              })
              .start(); // Â∞á onComplete ÁßªÂà∞‰∏ãÈù¢ÁöÑ scale ÂãïÁï´‰∏≠
              
            // [‰øÆÊîπ] ËÆìÂç°ÁâåÁ∏ÆÊîæÂà∞ÊúÄÁµÇË®àÁÆóÂá∫ÁöÑ gridScale
            new TWEEN.Tween(webglCard.scale)
              .to({ x: gridScale, y: gridScale, z: gridScale }, 1500)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onUpdate(() => {
                if (cssCard) {
                  const s = webglCard.scale.x * 0.006;
                  cssCard.scale.set(s, s, s);
                }
              })
              .onComplete(() => resolve()) // Âú®ÊúÄÂæå‰∏ÄÂÄãÂãïÁï´ÂÆåÊàêÊôÇ resolve
              .start();
          }, 500);
        })
        .start();
    }, delay);
  });
}

// ÂéüÁâàÂãïÁï´ÂáΩÊï∏ (V2 - Âä†ÂÖ• gridScale)
function animateCard(card, finalPosition, gridScale, delay = 0) {
  return new Promise((resolve) => {
    // ÈöéÊÆµ1ÔºöËµ∑ÂßãÁãÄÊÖã (ÈÉΩÂú®‰∏≠ÂøÉÂæåÊñπ)
    card.position.set(0, 0, -2);
    card.rotation.set(0, Math.PI, 0); // ËÉåÈù¢ÊúùÂâç
    card.scale.set(0.1, 0.1, 0.1); // ÂæàÂ∞è
    
    // ÈöéÊÆµ2ÔºöÈ£õËàûÁãÄÊÖã (Èö®Ê©üÊï£Èñã)
    const randomX = (Math.random() - 0.5) * 8;
    const randomY = (Math.random() - 0.5) * 6;
    const randomZ = Math.random() * 3 + 1;
    
    setTimeout(() => {
      // ÊîæÂ§ß‰∏¶È£õÂà∞Èö®Ê©ü‰ΩçÁΩÆ
      new TWEEN.Tween(card.position)
        .to({ x: randomX, y: randomY, z: randomZ }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();
        
      new TWEEN.Tween(card.scale)
        .to({ x: 1, y: 1, z: 1 }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();
        
      new TWEEN.Tween(card.rotation)
        .to({ x: Math.random() * Math.PI, y: Math.random() * Math.PI, z: Math.random() * Math.PI }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .onComplete(() => {
          // ÈöéÊÆµ3ÔºöÈ£õÂà∞ÊúÄÁµÇ‰ΩçÁΩÆ‰∏¶ÁøªËΩâÂà∞Ê≠£Èù¢
          setTimeout(() => {
            new TWEEN.Tween(card.position)
              .to(finalPosition, 1500)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
              
            new TWEEN.Tween(card.rotation)
              .to({ x: 0, y: 0, z: 0 }, 1500) // Ê≠£Èù¢ÊúùÂâç
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
              
            // [‰øÆÊîπ] ËÆìÂç°ÁâåÁ∏ÆÊîæÂà∞ÊúÄÁµÇË®àÁÆóÂá∫ÁöÑ gridScale
            new TWEEN.Tween(card.scale)
              .to({ x: gridScale, y: gridScale, z: gridScale }, 1500)
              .easing(TWEEN.Easing.Cubic.InOut)
              .onComplete(() => resolve()) // Âú®ÊúÄÂæå‰∏ÄÂÄãÂãïÁï´ÂÆåÊàêÊôÇ resolve
              .start();
          }, 500);
        })
        .start();
    }, delay);
  });
}

// 3D Âç°ÁâåÈõ®ÂãïÁï´‰∏ªÂáΩÂºè
async function showCardShowerAnimation(winners) {
  return new Promise(async (resolve) => {
    const overlay = document.getElementById('overlay');
    
    // È°ØÁ§∫ overlay
    overlay.classList.add('show');
    
    // ÂàùÂßãÂåñ 3D Â†¥ÊôØ
    initThreeScene();
    
    // ÈñãÂßãÂãïÁï´Âæ™Áí∞
    animate();
    
    // ÂâµÂª∫ WebGL Âç°ÁâåÔºàËÉåÊôØÂíåÊïàÊûúÔºâ
    cards = [];
    cssCards = [];
    
    winners.forEach(winnerName => {
      // WebGL Âç°ÁâåÔºàÁî®ÊñºËÉåÊôØÊïàÊûúÔºâ
      const webglCard = createWinnerCard(winnerName);
      cards.push(webglCard);
      scene.add(webglCard);
      
      // CSS3D Âç°ÁâåÔºàÁî®ÊñºÊ∏ÖÊô∞ÊñáÂ≠óÔºâ- ÂÉÖÂú® CSS3DRenderer ÂèØÁî®ÊôÇ
      if (cssScene && cssRenderer) {
        const cssCard = createCSSCard(winnerName);
        cssCards.push(cssCard);
        cssScene.add(cssCard);
        
        // ÂêåÊ≠•ÂàùÂßã‰ΩçÁΩÆ
        cssCard.position.copy(webglCard.position);
        cssCard.rotation.copy(webglCard.rotation);
        cssCard.scale.copy(webglCard.scale);
      }
    });
    
    // [‰øÆÊîπ] Ë®àÁÆóÊúÄÁµÇ‰ΩçÁΩÆÔºåÊé•Êî∂ÂõûÂÇ≥ÁöÑÁâ©‰ª∂
    const layout = calculateGridLayout(winners.length);
    const finalPositions = layout.positions;
    const gridScale = layout.scale; // Áç≤ÂèñÁ∂≤Ê†ºÁ∏ÆÊîæÊØî‰æã
    
    // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊôÇÈñìËÆìÂ†¥ÊôØÊ∫ñÂÇôÂÆåÊàê
    await new Promise(r => setTimeout(r, 500));
    
    // [‰øÆÊîπ] ‰æùÂ∫èÂïüÂãïÊØèÂºµÂç°ÁâåÁöÑÂãïÁï´ÔºåÂÇ≥ÂÖ• gridScale
    const animationPromises = cards.map((card, index) => {
      if (cssCards.length > 0) {
        // ‰ΩøÁî® CSS3D + WebGL Ê∑∑ÂêàÊ®°Âºè
        const cssCard = cssCards[index];
        return animateCardPair(card, cssCard, finalPositions[index], gridScale, index * 200);
      } else {
        // ÂÉÖ‰ΩøÁî® WebGL Ê®°Âºè
        return animateCard(card, finalPositions[index], gridScale, index * 200);
      }
    });
    
    // Á≠âÂæÖÊâÄÊúâÂãïÁï´ÂÆåÊàê
    await Promise.all(animationPromises);
    
    // ÂÜçÁ≠âÂæÖ 2 ÁßíËÆì‰ΩøÁî®ËÄÖÊ¨£Ë≥ûÊúÄÁµÇÁµêÊûú
    await new Promise(r => setTimeout(r, 2000));
    
    // Ê∑°Âá∫ overlay
    overlay.classList.add('fade-out');
    setTimeout(() => {
      overlay.classList.remove('show', 'fade-out');
      // Ê∏ÖÁêÜ 3D Â†¥ÊôØ
      cleanupThreeScene();
      resolve();
    }, 1000);
  });
}

// Ë¶ñÁ™óÂ§ßÂ∞èË™øÊï¥ËôïÁêÜ
function handleWindowResize() {
  if (camera && renderer) {
    // Êõ¥Êñ∞ÊîùÂΩ±Ê©üÈï∑ÂØ¨ÊØî
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    
    // Êõ¥Êñ∞ WebGL Ê∏≤ÊüìÂô®Â§ßÂ∞è
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Êõ¥Êñ∞ CSS3D Ê∏≤ÊüìÂô®Â§ßÂ∞è
    if (cssRenderer) {
      cssRenderer.setSize(window.innerWidth, window.innerHeight);
    }
  }
}

function loadHistory() {
  const stored = localStorage.getItem('drawHistory');
  if (stored) {
    try {
      historyList = JSON.parse(stored);
    } catch {
      historyList = [];
    }
  }
}

function saveHistory() {
  localStorage.setItem('drawHistory', JSON.stringify(historyList));
}

function populatePrizeOptions() {
  const select = document.getElementById('prizeFilter');
  const current = select.value;
  const prizes = Array.from(new Set(historyList.map(item => item.prize)));
  select.innerHTML = '<option value=\"ÂÖ®ÈÉ®\">ÂÖ®ÈÉ®</option>';
  prizes.forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    select.appendChild(opt);
  });
  if (prizes.includes(current) || current === 'ÂÖ®ÈÉ®') {
    select.value = current;
  }
}

function getFilteredList(prizeName) {
  if (prizeName === 'ÂÖ®ÈÉ®') return historyList;
  return historyList.filter(item => item.prize === prizeName);
}

function renderHistoryPage(list, page) {
  const container = document.getElementById('historyContainer');
  container.innerHTML = '';
  const start = (page - 1) * PAGE_SIZE;
  const pageItems = list.slice(start, start + PAGE_SIZE);

  if (pageItems.length === 0) {
    container.innerHTML = '<div class="alert alert-info">Â∞öÁÑ°Ê≠§ÂìÅÈ†ÖÊäΩÁçéÁ¥ÄÈåÑ„ÄÇ</div>';
  } else {
    pageItems.forEach(record => {
      const card = document.createElement('div');
      card.className = 'card history-card';
      card.innerHTML = `
        <div class="card-body">
          <h5 class="card-title">ÂìÅÈ†ÖÔºö${record.prize}</h5>
          <h6 class="card-subtitle mb-2 text-muted">ÊôÇÈñìÔºö${record.date}</h6>
          <p class="card-text">‰∏≠ÁçéËÄÖÔºö${record.winners.join('„ÄÅ')}</p>
          <p class="card-text"><small class="text-secondary">‰∫ÇÊï∏Á®ÆÂ≠êÔºö${record.seed}</small></p>
          <p class="card-text"><small class="text-secondary">ÂÖÅË®±ÈáçË§áÔºö${record.allowRepeat ? 'ÊòØ' : 'Âê¶'}</small></p>
        </div>
      `;
      container.appendChild(card);
    });
  }
  renderPagination(list.length);
}

function renderPagination(totalItems) {
  const totalPages = Math.ceil(totalItems / PAGE_SIZE);
  const pagContainer = document.getElementById('paginationContainer');
  pagContainer.innerHTML = '';
  if (totalPages <= 1) return;

  const prevLi = document.createElement('li');
  prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
  prevLi.innerHTML = `<button class="page-link">‰∏ä‰∏ÄÈ†Å</button>`;
  prevLi.onclick = () => {
    if (currentPage > 1) {
      currentPage--;
      updateHistoryDisplay();
    }
  };
  pagContainer.appendChild(prevLi);

  for (let i = 1; i <= totalPages; i++) {
    const li = document.createElement('li');
    li.className = `page-item ${currentPage === i ? 'active' : ''}`;
    li.innerHTML = `<button class="page-link">${i}</button>`;
    li.onclick = () => {
      currentPage = i;
      updateHistoryDisplay();
    };
    pagContainer.appendChild(li);
  }

  const nextLi = document.createElement('li');
  nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
  nextLi.innerHTML = `<button class="page-link">‰∏ã‰∏ÄÈ†Å</button>`;
  nextLi.onclick = () => {
    if (currentPage < totalPages) {
      currentPage++;
      updateHistoryDisplay();
    }
  };
  pagContainer.appendChild(nextLi);
}

function updateHistoryDisplay() {
  const selectedPrize = document.getElementById('prizeFilter').value;
  const filtered = getFilteredList(selectedPrize);
  renderHistoryPage(filtered, currentPage);
}

function updateParticipantCount(count) {
  document.getElementById('participantCount').textContent = 'ÁõÆÂâçÂèÉËàáËÄÖ ' + count + ' ‰∫∫';
}

function renderRemainingList(participants) {
  const remainingWrapper = document.getElementById('remainingWrapper');
  const remainingContainer = document.getElementById('remainingContainer');
  remainingContainer.innerHTML = '';
  if (participants.length === 0) {
    remainingContainer.innerHTML = '<div class="alert alert-info">ÁÑ°Ââ©È§òÂèÉËàáËÄÖ„ÄÇ</div>';
  } else {
    const ul = document.createElement('ul');
    participants.forEach((p, idx) => {
      const li = document.createElement('li');
      li.textContent = p;
      li.style.animationDelay = `${idx * 0.1}s`;
      ul.appendChild(li);
    });
    remainingContainer.appendChild(ul);
  }
}

function handleAllowRepeatToggle() {
  const allowRepeat = document.getElementById('allowRepeatCheckbox').checked;
  const remainingWrapper = document.getElementById('remainingWrapper');
  if (allowRepeat) {
    remainingWrapper.style.display = 'none';
    document.getElementById('remainingContainer').innerHTML = '';
  } else {
    remainingWrapper.style.display = 'block';
    const participants = document.getElementById('nameList').value
      .split('\n').map(n => n.trim()).filter(n => n !== '');
    updateParticipantCount(participants.length);
    renderRemainingList(participants);
  }
  document.getElementById('repeatHelp').textContent = allowRepeat
    ? 'ÂÖÅË®±Âêå‰∏ÄÂèÉËàáËÄÖÈáçË§á‰∏≠ÁçéÔºå‰∏çÊúÉÁßªÈô§ÂêçÂñÆ„ÄÇ'
    : '‰∏çÂÖÅË®±Âêå‰∏ÄÂèÉËàáËÄÖÈáçË§á‰∏≠ÁçéÔºå‰∏≠ÁçéËÄÖÂ∞áÂæûÂêçÂñÆÁßªÈô§„ÄÇ';
}

// Show countdown overlay function
async function showCountdownOverlay() {
  const overlay = document.getElementById('overlay');
  const container = document.getElementById('countdownContainer');
  container.innerHTML = '';
  overlay.classList.add('show');

  for (let c = 3; c > 0; c--) {
    const div = document.createElement('div');
    div.className = 'countdown-number';
    div.textContent = c;
    container.appendChild(div);
    void div.offsetWidth;
    await new Promise(r => setTimeout(r, 1000));
    container.removeChild(div);
  }
  overlay.classList.add('fade-out');
  setTimeout(() => {
    overlay.classList.remove('show', 'fade-out');
  }, 1000);
}

function scrollToWinners() {
  const container = document.getElementById('winnersContainer');
  if (container) {
    setTimeout(() => {
      container.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 100);
  }
}

async function shuffleWithSHA256(array, seed) {
  const encoder = new TextEncoder();
  const data = encoder.encode(seed);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = hashArray[i % hashArray.length] % (i + 1);
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

// Theme toggle functionality
function initializeTheme() {
  const themeToggle = document.getElementById('themeToggle');
  const body = document.body;
  const lightIcon = document.querySelector('.theme-icon-light');
  const darkIcon = document.querySelector('.theme-icon-dark');

  function applyTheme(theme) {
    if (theme === 'dark') {
      body.classList.add('dark');
      if (lightIcon) lightIcon.style.display = 'none';
      if (darkIcon) darkIcon.style.display = 'inline';
    } else {
      body.classList.remove('dark');
      if (lightIcon) lightIcon.style.display = 'inline';
      if (darkIcon) darkIcon.style.display = 'none';
    }
  }

  function toggleTheme() {
    const currentTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    localStorage.setItem('theme', newTheme);
    applyTheme(newTheme);
  }

  // Initialize theme based on localStorage or system preference
  const savedTheme = localStorage.getItem('theme');
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

  if (savedTheme) {
    applyTheme(savedTheme);
  } else if (prefersDark) {
    applyTheme('dark');
  } else {
    applyTheme('light'); // Default to light theme
  }

  if (themeToggle) {
    themeToggle.addEventListener('click', toggleTheme);
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  loadHistory();
  populatePrizeOptions();
  updateHistoryDisplay();
  initializeTheme(); // Call theme initialization
  
  // Âä†ÂÖ•Ë¶ñÁ™óÂ§ßÂ∞èË™øÊï¥Áõ£ËÅΩÂô®
  window.addEventListener('resize', handleWindowResize);

  // Set current year in footer
  const currentYearSpan = document.getElementById('currentYear');
  if (currentYearSpan) {
    currentYearSpan.textContent = new Date().getFullYear();
  }

  document.getElementById('prizeFilter').addEventListener('change', () => {
    currentPage = 1;
    updateHistoryDisplay();
  });

  document.getElementById('clearHistory').addEventListener('click', () => {
    if (confirm('Á¢∫ÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÊ≠∑Âè≤Á¥ÄÈåÑÂóéÔºü')) {
      historyList = [];
      saveHistory();
      populatePrizeOptions();
      currentPage = 1;
      updateHistoryDisplay();
    }
  });

  document.getElementById('allowRepeatCheckbox').addEventListener('change', handleAllowRepeatToggle);

  document.getElementById('nameList').addEventListener('input', () => {
    const participants = document.getElementById('nameList').value
      .split('\n').map(n => n.trim()).filter(n => n !== '');
    updateParticipantCount(participants.length);
    if (!document.getElementById('allowRepeatCheckbox').checked) {
      renderRemainingList(participants);
    }
  });

  const initialParticipants = document.getElementById('nameList').value
    .split('\n').map(n => n.trim()).filter(n => n !== '');
  updateParticipantCount(initialParticipants.length);
  // Initial call to render remaining list if checkbox is unchecked
  if (!document.getElementById('allowRepeatCheckbox').checked) {
    renderRemainingList(initialParticipants);
  }


  document.getElementById('drawButton').addEventListener('click', async function () {
    const textarea = document.getElementById('nameList');
    const seedInput = document.getElementById('seedInput').value.trim();
    const prizeInput = document.getElementById('prizeInput').value.trim() || 'Êú™ÂëΩÂêçÂìÅÈ†Ö';
    const countInput = document.getElementById('winnerCount').value.trim();
    const allowRepeat = document.getElementById('allowRepeatCheckbox').checked;
    const seedDisplayBlock = document.getElementById('seedDisplayBlock');
    const seedDisplay = document.getElementById('seedDisplay');

    const seed = seedInput || Date.now().toString();
    if (!seedInput) {
      seedDisplayBlock.style.display = 'block';
      seedDisplay.textContent = seed;
    } else {
      seedDisplayBlock.style.display = 'none';
      seedDisplay.textContent = '';
    }

    let participants = textarea.value
      .split('\n')
      .map(name => name.trim())
      .filter(name => name !== '');

    let winnerCount = parseInt(countInput, 10);
    if (isNaN(winnerCount) || winnerCount < 1) {
      alert('Ë´ãËº∏ÂÖ•Ê≠£Á¢∫ÁöÑÂæóÁçé‰∫∫Êï∏');
      return;
    }
    if (!allowRepeat && winnerCount > participants.length) {
      alert('ÂæóÁçé‰∫∫Êï∏‰∏çÂæóË∂ÖÈÅéÂèÉËàáËÄÖÁ∏ΩÊï∏ÔºåÊàñË´ãÂãæÈÅ∏ÂÖÅË®±ÈáçË§á‰∏≠Áçé');
      return;
    }
    if (participants.length < 1) {
      alert('Ë´ãËá≥Â∞ëËº∏ÂÖ• 1 ‰ΩçÂèÉËàáËÄÖ');
      return;
    }

    // Áç≤Âèñ‰∏≠ÁçéËÄÖ
    const shuffled = await shuffleWithSHA256(participants, seed);
    const winners = shuffled.slice(0, winnerCount);

    // È°ØÁ§∫ 3D Âç°ÁâåÈõ®ÂãïÁï´
    await showCardShowerAnimation(winners);

    const winnersContainer = document.getElementById('winnersContainer');
    winnersContainer.innerHTML = '';

    // Display winners
    winners.forEach((name, index) => {
      const col = document.createElement('div');
      col.className = 'col-12 col-sm-6 col-md-4';
      const card = document.createElement('div');
      card.className = 'card winner-card highlight-winner'; // Added highlight-winner class
      card.style.animationDelay = `${index * 0.2}s`;
      const cardBody = document.createElement('div');
      cardBody.className = 'card-body text-center';
      const title = document.createElement('h5');
      title.className = 'card-title';
      title.textContent = `üèÜ ${name} üèÜ`; // Added trophy emojis
      const subtitle = document.createElement('p');
      subtitle.className = 'card-text text-muted';
      subtitle.textContent = 'ÊÅ≠Âñú‰∏≠ÁçéÔºÅ';
      cardBody.appendChild(title);
      cardBody.appendChild(subtitle);
      card.appendChild(cardBody);
      col.appendChild(card);
      winnersContainer.appendChild(col);
    });

    // Auto-scroll to winners
    scrollToWinners();

    // Trigger confetti
    // Ensure body is accessible here or re-fetch it.
    const currentBody = document.body; // Re-fetch body element to ensure it's available
    const isDarkMode = currentBody.classList.contains('dark');
    let confettiColors = isDarkMode ? ['#FFFFFF', '#e9ecef', '#adb5bd', '#38d980'] : ['#1a1a1a', '#3e4346', '#565e62', '#2ECC71'];
    // Add gold/silver for surprise effect
    confettiColors = [...confettiColors, '#FFD700', '#C0C0C0'];

    // Basic test call for confetti
    if (typeof confetti === 'function') {
      console.log('Confetti function is available. Attempting basic call.');
      try {
        confetti(); // Simplest possible call
      } catch (e) {
        console.error('Error during basic confetti call:', e);
      }
    } else {
      console.error('Confetti function is NOT available.');
    }

    // First burst - wider and more particles
    if (typeof confetti === 'function') {
      confetti({
        particleCount: 400, // Significantly increased particle count
        spread: 300,        // Wider spread
        origin: { y: 0.5 }, // Slightly higher origin
        colors: confettiColors,
        shapes: ['circle', 'square', 'star'],
        startVelocity: 30, // Make them shoot up a bit more
        drift: 0, // Less sideways drift for the initial burst
        gravity: 0.8 // Slightly stronger gravity
      });

      // Second burst - more focused and with different shapes/colors if desired
      setTimeout(() => {
        confetti({
          particleCount: 200,
          spread: 120,
          origin: { y: 0.6 },
          colors: ['#FFD700', '#C0C0C0', isDarkMode ? '#38d980' : '#2ECC71'], // Emphasize gold, silver and accent
          shapes: ['star'], // Focus on stars for the second burst
          scalar: 1.2 // Slightly larger particles
        });
      }, 150); // Slight delay for the second burst
    } // Closing the if (typeof confetti === 'function') block

    // Brief background flash
    currentBody.classList.add('flash-background');
    setTimeout(() => {
      currentBody.classList.remove('flash-background');
    }, 300);


    if (!allowRepeat) {
      winners.forEach(w => {
        let idx;
        while ((idx = participants.indexOf(w)) !== -1) {
          participants.splice(idx, 1);
        }
      });
      textarea.value = participants.join('\n');
      updateParticipantCount(participants.length);
      renderRemainingList(participants);
    }

    const now = new Date();
    const nowStr = now.getFullYear() + '-' +
                   String(now.getMonth()+1).padStart(2,'0') + '-' +
                   String(now.getDate()).padStart(2,'0') + ' ' +
                   String(now.getHours()).padStart(2,'0') + ':' +
                   String(now.getMinutes()).padStart(2,'0') + ':' +
                   String(now.getSeconds()).padStart(2,'0');
    const newRecord = {
      prize: prizeInput,
      seed: seed,
      date: nowStr,
      winners: winners,
      allowRepeat: allowRepeat
    };
    historyList.unshift(newRecord);
    if (historyList.length > 10) { // Keep only last 10 records for simplicity, adjust as needed
      historyList.splice(10);
    }
    saveHistory();
    populatePrizeOptions();
    updateHistoryDisplay();
  });
});
