<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>moda_draw_tool</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Roboto:wght@400;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet" />
</head>
<body>
  <header class="app-header text-center py-4">
    <h1>moda å¹¸é‹æŠ½çå°å·¥å…·</h1>
  </header>
  <main class="container py-4">
    <section class="setup-section card shadow-sm mb-4">
      <div class="card-body">
        <h2 class="section-title mb-3">æŠ½çè¨­å®š</h2>
        <div class="row">
          <div class="col-lg-4 mb-3">
            <label for="nameList" class="form-label">åƒèˆ‡è€…æ¸…å–®ï¼ˆæ¯è¡Œä¸€ä½ï¼‰ï¼š</label>
            <textarea class="form-control" id="nameList" rows="8" placeholder="è¼¸å…¥åƒèˆ‡è€…åå–®..."></textarea>
            <p id="participantCount" class="mt-2 text-muted small">ç›®å‰åƒèˆ‡è€… 0 äºº</p>
          </div>
          <div class="col-lg-8">
            <div class="row">
              <div class="col-md-6 mb-3">
                <label for="prizeInput" class="form-label">æŠ½çå“é …ï¼š</label>
                <input type="text" class="form-control" id="prizeInput" placeholder="ä¾‹å¦‚ï¼šé ­ç - Switch" />
              </div>
              <div class="col-md-6 mb-3">
                <label for="seedInput" class="form-label">å¹¸é‹ç¨®å­ï¼ˆå¯ç•™ç©ºï¼‰ï¼š</label>
                <input type="text" class="form-control" id="seedInput" placeholder="ä¾‹å¦‚ï¼šluckyday2025" />
              </div>
              <div class="col-md-6 mb-3">
                <label for="winnerCount" class="form-label">å¾—çäººæ•¸ï¼š</label>
                <input type="number" class="form-control" id="winnerCount" value="1" min="1" placeholder="è¼¸å…¥æ•¸å­—" />
              </div>
              <div class="col-md-6 mb-3 align-self-center">
                <div class="form-check mt-3">
                  <input class="form-check-input" type="checkbox" id="allowRepeatCheckbox">
                  <label class="form-check-label" for="allowRepeatCheckbox">å…è¨±é‡è¤‡ä¸­ç</label>
                </div>
                <small id="repeatHelp" class="form-text text-muted">ä¸å‹¾é¸æ™‚ï¼Œä¸­çè€…å°‡å¾åå–®ç§»é™¤ã€‚</small>
              </div>
            </div>
          </div>
        </div>
        <div class="text-center mt-3">
          <button id="drawButton" class="btn btn-draw btn-lg px-5">é–‹å§‹æŠ½ç</button>
        </div>
      </div>
    </section>

    <div class="mt-4 text-center" id="seedDisplayBlock" style="display:none;">
      <h5 class="text-muted small">æœ¬æ¬¡å¹¸é‹ç¨®å­ï¼š<span id="seedDisplay" class="fw-bold"></span></h5>
    </div>

    <section class="results-section mt-4 mb-4">
      <h2 class="section-title text-center mb-3">ä¸­çåå–®æ­æ›‰</h2>
      <div id="winnersContainer" class="row gy-4"></div>
    </section>

    <section id="remainingWrapper" class="remaining-section card shadow-sm mb-4" style="display:none;">
      <div class="card-body">
        <h3 class="section-title-sm mb-2">å‰©é¤˜åƒèˆ‡è€…</h3>
        <div id="remainingContainer" class="fadeInList"></div>
      </div>
    </section>

    <section class="history-section card shadow-sm">
      <div class="card-body">
        <h2 class="section-title mb-3">æŠ½çæ­·å²ç´€éŒ„</h2>
        <div class="row mb-3 align-items-end">
          <div class="col-md-5 mb-2 mb-md-0">
            <label for="prizeFilter" class="form-label">ä¾å“é …ç¯©é¸ï¼š</label>
            <select id="prizeFilter" class="form-select">
              <option value="å…¨éƒ¨">é¡¯ç¤ºå…¨éƒ¨å“é …</option>
            </select>
          </div>
          <div class="col-md-7 text-md-end">
            <button id="clearHistory" class="btn btn-clear-history">ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨ç´€éŒ„</button>
          </div>
        </div>
        <div id="historyContainer"></div>
        <nav class="pagination-container mt-3">
          <ul id="paginationContainer" class="pagination justify-content-center"></ul>
        </nav>
      </div>
    </section>
  </main>
  <footer class="app-footer text-center py-3 mt-4">
    <p class="mb-0 small">&copy; <span id="currentYear"></span> moda å¹¸é‹æŠ½ç. All rights reserved.</p>
  </footer>

  <!-- Overlay for countdown -->
  <div id="overlay" class="overlay">
    <div class="blur-bg"></div>
    <div id="countdownContainer"></div>
  </div>

  <!-- Three.js container for ACT animation -->
  <div id="threeContainer" style="
    position: fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%);
    width: 1200px; 
    height: 700px;
    max-width: 95vw;
    max-height: 95vh;
    z-index: 9999; 
    display: none; 
    background: linear-gradient(135deg, rgba(47,27,20,0.95) 0%, rgba(139,69,19,0.9) 50%, rgba(160,82,45,0.85) 100%);
    border-radius: 15px;
    box-shadow: 0 20px 60px rgba(139,69,19,0.6), inset 0 0 30px rgba(255,215,0,0.1);
    border: 2px solid rgba(255,215,0,0.3);
    overflow: hidden;
  "></div>

  <!-- å¼•å…¥ confetti å‡½å¼åº« -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>
  <!-- Three.js å‹•ç•«ç³»çµ±ä½¿ç”¨ ES Modules -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    
    console.log('Three.js ES module loaded:', THREE);
    
    // Make THREE available globally
    window.THREE = THREE;
    
    // Import and create animation class
    try {
      // Simple Three.js animation class
      class ThreeJSAnimation {
        constructor() {
          console.log('ES Module ThreeJSAnimation constructor called');
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.cards = [];
          this.container = null;
          this.isAnimating = false;
          this.animationCallback = null;
          this.clickHandlerAdded = false;
        }

        init() {
          this.container = document.getElementById('threeContainer');
          
          if (!this.container) {
            console.error('Three.js container not found');
            return false;
          }

          console.log('Container found:', this.container);
          
          // Force container to be visible and get computed style
          this.container.style.display = 'block';
          
          // Wait a moment for CSS to apply, then get dimensions
          setTimeout(() => {
            const rect = this.container.getBoundingClientRect();
            console.log('Container getBoundingClientRect:', rect);
          }, 10);
          
          // Use fallback dimensions if container reports 0 size
          let width = this.container.clientWidth || 1200;
          let height = this.container.clientHeight || 700;
          
          // If still 0, use window dimensions as fallback
          if (width === 0 || height === 0) {
            width = Math.min(window.innerWidth * 0.9, 1200);
            height = Math.min(window.innerHeight * 0.9, 700);
            console.log('Using fallback dimensions:', width, 'x', height);
          }
          
          console.log('Final container dimensions:', width, 'x', height);

          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
          this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          
          this.renderer.setSize(width, height);
          // ä½¿ç”¨æ·±è—è‰²èƒŒæ™¯ï¼Œå®Œå…¨ä¸é€æ˜ï¼Œé¿å…è©­ç•°çš„è¦–è¦ºæ•ˆæœ
          this.renderer.setClearColor(0x1a1a2e, 1.0);
          
          // Style the canvas to ensure it's visible
          this.renderer.domElement.style.position = 'absolute';
          this.renderer.domElement.style.top = '0';
          this.renderer.domElement.style.left = '0';
          this.renderer.domElement.style.width = '100%';
          this.renderer.domElement.style.height = '100%';
          this.renderer.domElement.style.zIndex = '1';
          
          this.container.appendChild(this.renderer.domElement);
          
          // è¨­ç½®é©ç•¶çš„å…‰ç…§ç³»çµ±
          // ç’°å¢ƒå…‰ï¼šæä¾›åŸºç¤ç…§æ˜
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
          this.scene.add(ambientLight);
          
          // ä¸»æ–¹å‘å…‰ï¼šæ¨¡æ“¬å¤ªé™½å…‰
          const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
          mainLight.position.set(5, 10, 5);
          mainLight.castShadow = false; // é—œé–‰é™°å½±ä»¥æé«˜æ€§èƒ½
          this.scene.add(mainLight);
          
          // è£œå…‰ï¼šå¾å¦ä¸€å€‹è§’åº¦æä¾›æŸ”å’Œç…§æ˜
          const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
          fillLight.position.set(-5, 0, 3);
          this.scene.add(fillLight);
          
          console.log('å…‰ç…§ç³»çµ±è¨­ç½®å®Œæˆ');
          
          // è¨­ç½®ç›¸æ©Ÿä½ç½®ï¼Œæä¾›æœ€ä½³è¦–è§’
          this.camera.position.set(0, 2, 12); // ç¨å¾®æé«˜ä¸¦é é›¢ï¼Œç²å¾—æ›´å¥½çš„è¦–è§’
          this.camera.lookAt(0, 0, 0);
          
          // è¨­ç½®ç›¸æ©Ÿåƒæ•¸
          this.camera.near = 0.1;
          this.camera.far = 100;
          this.camera.updateProjectionMatrix();
          
          console.log('ç›¸æ©Ÿè¨­ç½®å®Œæˆï¼Œä½ç½®:', this.camera.position);
          
          console.log('Three.js initialized successfully');
          console.log('Scene objects count:', this.scene.children.length);
          console.log('Camera position:', this.camera.position);
          console.log('Renderer size:', this.renderer.getSize(new THREE.Vector2()));

          window.addEventListener('resize', () => this.onWindowResize(), false);
          return true;
        }

        onWindowResize() {
          if (!this.camera || !this.renderer || !this.container) return;
          
          this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        }

        createCard(name) {
          console.log('Creating card for:', name);
          
          // å‰µå»ºåˆç†å°ºå¯¸çš„å¡ç‰‡
          const geometry = new THREE.PlaneGeometry(2, 3);
          
          // å¡ç‰‡æ­£é¢ï¼šä½¿ç”¨å„ªé›…çš„é‡‘è‰²
          const frontMaterial = new THREE.MeshLambertMaterial({ 
            color: 0xffd700, // é‡‘è‰²
            side: THREE.DoubleSide
          });
          
          // å¡ç‰‡èƒŒé¢ï¼šè¼‰å…¥æ–‡å­—è²¼åœ–ä¸¦æª¢æŸ¥
          let backTexture = null;
          let backMaterial = null;
          
          try {
            backTexture = this.createTextTexture(name);
            
            // æª¢æŸ¥è²¼åœ–æ˜¯å¦æˆåŠŸå‰µå»º
            if (backTexture && backTexture.image) {
              backMaterial = new THREE.MeshLambertMaterial({ 
                map: backTexture,
                side: THREE.DoubleSide,
                color: 0xffffff,
                transparent: false
              });
              console.log('è²¼åœ–è¼‰å…¥æˆåŠŸ:', name);
            } else {
              throw new Error('è²¼åœ–å‰µå»ºå¤±æ•—');
            }
          } catch (error) {
            console.warn('è²¼åœ–è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨å¾Œå‚™æè³ª:', error);
            // å¾Œå‚™æè³ªï¼šç´”è‰²èƒŒæ™¯ + æ–‡å­—
            backMaterial = new THREE.MeshLambertMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide
            });
          }
          
          const card = new THREE.Mesh(geometry, frontMaterial);
          
          card.userData = {
            frontMaterial: frontMaterial,
            backMaterial: backMaterial,
            isFlipped: false,
            name: name,
            settled: false,
            clickable: false
          };
          
          console.log('Card created for:', name);
          console.log('Front material color:', frontMaterial.color.getHexString());
          console.log('Back texture size:', backTexture.image.width, 'x', backTexture.image.height);
          
          return card;
        }

        createTextTexture(text) {
          try {
            console.log('å‰µå»ºæ–‡å­—è²¼åœ–:', text);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // é«˜è§£æåº¦ç•«å¸ƒ
            canvas.width = 512;
            canvas.height = 768;
            
            // ç™½è‰²èƒŒæ™¯
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½é‚Šæ¡†
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 4;
            ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);
            
            // æ–‡å­—æ¨£å¼
            ctx.fillStyle = '#1a1a1a';
            ctx.font = 'bold 72px "Noto Sans TC", "Microsoft JhengHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ–‡å­—é™°å½±
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // ç¹ªè£½æ–‡å­—
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // å‰µå»ºè²¼åœ–ä¸¦è¨­å®šæ­£ç¢ºçš„æ–¹å‘
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.flipY = false;
            
            // ä¿®æ­£è²¼åœ–æ–¹å‘ - è¨­å®šæ—‹è½‰ä¸­å¿ƒé»å’Œè§’åº¦
            texture.center = new THREE.Vector2(0.5, 0.5);
            texture.rotation = Math.PI; // 180åº¦æ—‹è½‰ä¿®æ­£æ–¹å‘
            
            texture.needsUpdate = true;
            
            console.log('æ–‡å­—è²¼åœ–å‰µå»ºæˆåŠŸ:', {
              text: text,
              size: `${canvas.width}x${canvas.height}`,
              font: ctx.font
            });
            
            return texture;
            
          } catch (error) {
            console.error('æ–‡å­—è²¼åœ–å‰µå»ºå¤±æ•—:', error);
            
            // å‰µå»ºç°¡å–®çš„å¾Œå‚™è²¼åœ–
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ERROR', canvas.width / 2, canvas.height / 2);
            
            return new THREE.CanvasTexture(canvas);
          }
        }

        async startAnimation(winners, callback) {
          console.log('startAnimation called with winners:', winners);
          if (this.isAnimating) return;
          
          this.isAnimating = true;
          this.animationCallback = callback;
          this.cards = [];
          
          console.log('Initializing Three.js...');
          if (!this.init()) {
            console.error('Three.js initialization failed');
            this.isAnimating = false;
            if (callback) callback();
            return;
          }

          console.log('Setting container display to block');
          this.container.style.display = 'block';
          
          const positions = this.generatePositions(winners.length);
          
          winners.forEach((winner, index) => {
            const card = this.createCard(winner);
            
            const startPos = {
              x: (Math.random() - 0.5) * 6,  // Smaller random spread
              y: 10 + Math.random() * 2,     // Higher starting position
              z: 0
            };
            
            card.position.set(startPos.x, startPos.y, startPos.z);
            
            card.userData.targetPosition = positions[index].clone();
            card.userData.velocity = {
              x: (Math.random() - 0.5) * 0.02, // æ¸›æ…¢æ°´å¹³é‹å‹•
              y: -0.02 - Math.random() * 0.01, // å¤§å¹…æ¸›æ…¢å‚ç›´é€Ÿåº¦
              z: 0
            };
            card.userData.rotationVelocity = {
              x: (Math.random() - 0.5) * 0.05,
              y: (Math.random() - 0.5) * 0.05,
              z: (Math.random() - 0.5) * 0.05
            };
            
            console.log(`Card ${index} (${winner}):`);
            console.log('  Start position:', startPos);
            console.log('  Target position:', positions[index]);
            console.log('  Target Y after adjustment:', card.userData.targetPosition.y);
            console.log('  Velocity:', card.userData.velocity);
            console.log('  Distance to fall:', startPos.y - card.userData.targetPosition.y);
            
            this.scene.add(card);
            this.cards.push(card);
          });

          console.log('All cards added to scene. Total cards:', this.cards.length);
          console.log('Scene children count:', this.scene.children.length);

          this.animate();
        }

        generatePositions(count) {
          const positions = [];
          const cols = Math.ceil(Math.sqrt(count));
          const rows = Math.ceil(count / cols);
          const spacingX = 2; // Smaller spacing
          const spacingY = 1.5; // Smaller spacing
          
          for (let i = 0; i < count; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const x = (col - (cols - 1) / 2) * spacingX;
            const y = ((rows - 1) / 2 - row) * spacingY;
            
            // Force target Y to be at screen center for better visibility
            const finalY = 0; // Center of screen
            positions.push(new THREE.Vector3(x, finalY, 0));
          }
          
          console.log('Generated positions for', count, 'cards:', positions);
          return positions;
        }

        animate() {
          if (!this.isAnimating) return;
          
          requestAnimationFrame(() => this.animate());
          
          let allSettled = true;
          
          // Add frame counter for debugging (but don't spam console)
          if (!this.frameCount) this.frameCount = 0;
          this.frameCount++;
          
          // è¶…æ™‚å¼·åˆ¶è½åœ°æ©Ÿåˆ¶ - é¿å…å¡ç‰‡é•·æ™‚é–“é£„æµ®
          const maxFrames = 1200; // 20ç§’è¶…æ™‚ (60fps * 20)
          if (this.frameCount > maxFrames) {
            console.log('å‹•ç•«è¶…æ™‚ï¼Œå¼·åˆ¶æ‰€æœ‰å¡ç‰‡è½åœ°');
            this.cards.forEach((card, index) => {
              if (!card.userData.settled) {
                card.position.copy(card.userData.targetPosition);
                card.rotation.set(0, 0, 0);
                card.userData.settled = true;
                card.userData.clickable = true;
                card.renderOrder = 10;
                console.log(`å¼·åˆ¶è½åœ°ï¼šå¡ç‰‡ ${index}`);
              }
            });
          }
          
          // æ¸›å°‘è¼¸å‡ºé »ç‡
          if (this.frameCount % 120 === 0) { // æ¯2ç§’è¼¸å‡ºä¸€æ¬¡
            console.log(`å‹•ç•«é€²è¡Œä¸­ï¼Œç¬¬${this.frameCount}å¹€ï¼Œç§»å‹•ä¸­çš„å¡ç‰‡: ${this.cards.filter(c => !c.userData.settled).length}å¼µ`);
          }
          
          this.cards.forEach((card, index) => {
            if (!card.userData.settled) {
              const oldPos = card.position.y;
              card.position.add(card.userData.velocity);
              card.rotation.x += card.userData.rotationVelocity.x;
              card.rotation.y += card.userData.rotationVelocity.y;
              card.rotation.z += card.userData.rotationVelocity.z;
              
              card.userData.velocity.y += -0.002; // æ¸›æ…¢é‡åŠ›åŠ é€Ÿåº¦
              
              // åªåœ¨é—œéµæ™‚åˆ»è¼¸å‡ºé™¤éŒ¯è³‡è¨Š
              if (this.frameCount === 1 || this.frameCount === 30 || this.frameCount % 60 === 0) {
                console.log(`å‹•ç•«ç¬¬${this.frameCount}å¹€ - å¡ç‰‡${index}: Y=${card.position.y.toFixed(1)}, ç›®æ¨™=${card.userData.targetPosition.y.toFixed(1)}, é€Ÿåº¦=${card.userData.velocity.y.toFixed(3)}`);
              }
              
              // æ”¹å–„è½åœ°åˆ¤æ–· - å¢åŠ ç·©è¡å€åŸŸé¿å…ç©¿é€
              const distanceToTarget = card.position.y - card.userData.targetPosition.y;
              const tolerance = 0.1; // ç·©è¡å€åŸŸ
              
              if (distanceToTarget <= tolerance) {
                // ä½ç½®æ ¡æ­£ï¼šç¢ºä¿å¡ç‰‡ç²¾ç¢ºè½åœ¨ç›®æ¨™ä½ç½®
                card.position.copy(card.userData.targetPosition);
                card.rotation.set(0, 0, 0);
                card.userData.settled = true;
                card.userData.clickable = true;
                
                // è¨­å®šæ¸²æŸ“é †åºï¼Œç¢ºä¿å¡ç‰‡åœ¨æ­£ç¢ºå±¤ç´š
                card.renderOrder = 10;
                
                console.log(`å¡ç‰‡ ${index} (${card.userData.name}) å·²ç©©å®šè½åœ°`);
              } else {
                allSettled = false;
                
                // é™¤éŒ¯è¼¸å‡º
                if (this.frameCount % 120 === 0) {
                  console.log(`å¡ç‰‡ ${index} ä¸‹è½ä¸­: Y=${card.position.y.toFixed(2)}, ç›®æ¨™=${card.userData.targetPosition.y.toFixed(2)}, è·é›¢=${distanceToTarget.toFixed(2)}`);
                }
              }
            }
          });
          
          if (allSettled && !this.allCardsFlipped()) {
            console.log('All cards settled, enabling click handling');
            this.enableClickHandling();
          }
          
          this.renderer.render(this.scene, this.camera);
          
          if (allSettled && this.allCardsFlipped()) {
            console.log('All cards flipped, ending animation in 2 seconds');
            setTimeout(() => {
              this.endAnimation();
            }, 2000);
          }
        }

        enableClickHandling() {
          if (this.clickHandlerAdded) return;
          
          this.clickHandlerAdded = true;
          this.renderer.domElement.addEventListener('click', (event) => this.onCanvasClick(event), false);
        }

        onCanvasClick(event) {
          const rect = this.renderer.domElement.getBoundingClientRect();
          const mouse = new THREE.Vector2();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, this.camera);
          
          // åªæª¢æ¸¬å·²ç©©å®šä¸”å¯é»æ“Šçš„å¡ç‰‡
          const clickableCards = this.cards.filter(card => 
            card.userData.settled && 
            card.userData.clickable && 
            !card.userData.isFlipped
          );
          
          const intersects = raycaster.intersectObjects(clickableCards);
          
          if (intersects.length > 0) {
            const card = intersects[0].object;
            console.log('é»æ“Šå¡ç‰‡:', card.userData.name);
            this.flipCard(card);
          } else {
            console.log('é»æ“Šä½ç½®ç„¡æœ‰æ•ˆå¡ç‰‡', {
              mousePos: mouse,
              clickableCards: clickableCards.length,
              settledCards: this.cards.filter(c => c.userData.settled).length
            });
          }
        }

        flipCard(card) {
          card.userData.isFlipped = true;
          card.userData.clickable = false;
          
          const duration = 500;
          const startTime = Date.now();
          
          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            card.rotation.y = progress * Math.PI;
            
            if (progress >= 0.5 && card.material === card.userData.frontMaterial) {
              card.material = card.userData.backMaterial;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          };
          
          animate();
        }

        allCardsFlipped() {
          return this.cards.every(card => card.userData.isFlipped);
        }

        endAnimation() {
          this.isAnimating = false;
          this.container.style.display = 'none';
          
          this.cards.forEach(card => {
            this.scene.remove(card);
          });
          this.cards = [];
          
          if (this.clickHandlerAdded && this.renderer && this.renderer.domElement) {
            this.renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
            this.clickHandlerAdded = false;
          }
          
          if (this.renderer && this.container) {
            this.container.removeChild(this.renderer.domElement);
            this.renderer.dispose();
            this.renderer = null;
          }
          
          if (this.animationCallback) {
            this.animationCallback();
          }
        }

        // === é€²éš3DåŠŸèƒ½å¯¦ç¾ ===
        
        /**
         * å‰µå»ºMODAä¼æ¥­èƒŒæ™¯SVGç´‹ç†
         */
        createModaSvgTexture() {
          console.log('å‰µå»ºMODA SVGèƒŒæ™¯ç´‹ç†...');
          
          try {
            // å‰µå»ºSVGç•«å¸ƒ
            const svgData = `
              <svg width="1024" height="1024" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <linearGradient id="modaGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#2c1810;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#8b4513;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#a0522d;stop-opacity:0.8" />
                  </linearGradient>
                  <pattern id="modaPattern" x="0" y="0" width="200" height="200" patternUnits="userSpaceOnUse">
                    <rect width="200" height="200" fill="url(#modaGradient)" opacity="0.3"/>
                    <text x="100" y="100" font-family="serif" font-size="24" fill="#ffd700" opacity="0.6" text-anchor="middle" dominant-baseline="middle">MODA</text>
                  </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#modaGradient)"/>
                <rect width="100%" height="100%" fill="url(#modaPattern)"/>
                <circle cx="512" cy="512" r="300" fill="none" stroke="#ffd700" stroke-width="2" opacity="0.4"/>
              </svg>
            `;
            
            // è½‰æ›ç‚ºè²¼åœ–
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const loader = new THREE.TextureLoader();
            this.modaTexture = loader.load(url, 
              (texture) => {
                console.log('MODAèƒŒæ™¯ç´‹ç†è¼‰å…¥æˆåŠŸ');
                URL.revokeObjectURL(url);
              },
              undefined,
              (error) => {
                console.error('MODAèƒŒæ™¯ç´‹ç†è¼‰å…¥å¤±æ•—:', error);
                URL.revokeObjectURL(url);
              }
            );
            
            return this.modaTexture;
            
          } catch (error) {
            console.error('å‰µå»ºMODAç´‹ç†å¤±æ•—:', error);
            return null;
          }
        }

        /**
         * é åˆå§‹åŒ–3Då ´æ™¯å’Œè³‡æº
         */
        preInitializeScene(container) {
          console.log('é åˆå§‹åŒ–3Då ´æ™¯...');
          
          if (this.scene) {
            console.log('å ´æ™¯å·²å­˜åœ¨ï¼Œè·³éé åˆå§‹åŒ–');
            return true;
          }
          
          try {
            // é å‰µå»ºå ´æ™¯çµ„ä»¶
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, 1200/700, 0.1, 1000);
            
            // é è¼‰å…¥MODAèƒŒæ™¯
            this.createModaSvgTexture();
            
            // å‰µå»ºèƒŒæ™¯å¹³é¢
            this.createBackgroundPlane();
            
            // é ç½®ç²’å­ç³»çµ±
            this.initParticleSystem();
            
            console.log('å ´æ™¯é åˆå§‹åŒ–å®Œæˆ');
            return true;
            
          } catch (error) {
            console.error('å ´æ™¯é åˆå§‹åŒ–å¤±æ•—:', error);
            return false;
          }
        }

        /**
         * åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
         */
        initAudioSystem() {
          console.log('åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±...');
          
          try {
            // é è¼‰å…¥éŸ³æ•ˆæ–‡ä»¶
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // å¡ç‰‡ç¿»è½‰éŸ³æ•ˆ
            this.loadSound('cardFlip', 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGAZCECa0y6r');
            
            // æˆåŠŸéŸ³æ•ˆ
            this.loadSound('success', 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGAZCECa0');
            
            console.log('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–å®Œæˆ');
            return true;
            
          } catch (error) {
            console.warn('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
            return false;
          }
        }

        /**
         * è¼‰å…¥éŸ³æ•ˆæ–‡ä»¶
         */
        loadSound(name, dataUrl) {
          // æ¨¡æ“¬éŸ³æ•ˆè¼‰å…¥ - å¯¦éš›å°ˆæ¡ˆä¸­æœƒè¼‰å…¥çœŸå¯¦éŸ³æ•ˆæ–‡ä»¶
          this.sounds = this.sounds || {};
          this.sounds[name] = { loaded: true, url: dataUrl };
        }

        /**
         * æ’­æ”¾éŸ³æ•ˆ
         */
        playSound(name) {
          if (this.sounds && this.sounds[name] && this.sounds[name].loaded) {
            console.log('æ’­æ”¾éŸ³æ•ˆ:', name);
            // å¯¦éš›æ’­æ”¾é‚è¼¯
          }
        }

        /**
         * å‰µå»ºMODAèƒŒæ™¯å¹³é¢
         */
        createBackgroundPlane() {
          console.log('å‰µå»ºèƒŒæ™¯å¹³é¢...');
          
          try {
            const geometry = new THREE.PlaneGeometry(50, 30);
            
            // ä½¿ç”¨ç°¡å–®ä½†ç¾è§€çš„æ¼¸è®Šæè³ªï¼ˆä¸ä¾è³´SVGç´‹ç†ï¼‰
            const material = new THREE.MeshLambertMaterial({
              color: 0x8b4513, // æ£•è‰²
              transparent: true,
              opacity: 0.3
            });
            
            this.backgroundPlane = new THREE.Mesh(geometry, material);
            this.backgroundPlane.position.set(0, 0, -15); // æ”¾åœ¨æœ€å¾Œé¢
            this.backgroundPlane.renderOrder = -1;
            
            if (this.scene) {
              this.scene.add(this.backgroundPlane);
              console.log('èƒŒæ™¯å¹³é¢å·²æ·»åŠ åˆ°å ´æ™¯ï¼Œä½ç½®:', this.backgroundPlane.position);
              console.log('å ´æ™¯ä¸­ç‰©ä»¶æ•¸é‡:', this.scene.children.length);
            } else {
              console.warn('å ´æ™¯ä¸å­˜åœ¨ï¼Œç„¡æ³•æ·»åŠ èƒŒæ™¯å¹³é¢');
            }
            
          } catch (error) {
            console.error('å‰µå»ºèƒŒæ™¯å¹³é¢å¤±æ•—:', error);
          }
        }

        /**
         * åˆå§‹åŒ–ç²’å­ç³»çµ±
         */
        initParticleSystem() {
          console.log('åˆå§‹åŒ–ç²’å­ç³»çµ±...');
          
          try {
            const particleCount = 50; // æ¸›å°‘æ•¸é‡æ–¹ä¾¿è§€å¯Ÿ
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // å‰µå»ºéš¨æ©Ÿç²’å­ä½ç½®å’Œé¡è‰²
            for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;
              
              // ä½ç½® - åœ¨ç›¸æ©Ÿè¦–é‡å…§
              positions[i3] = (Math.random() - 0.5) * 20;     // x: -10 åˆ° 10
              positions[i3 + 1] = (Math.random() - 0.5) * 20; // y: -10 åˆ° 10  
              positions[i3 + 2] = (Math.random() - 0.5) * 10; // z: -5 åˆ° 5
              
              // é¡è‰² - é‡‘è‰²èª¿
              colors[i3] = 1.0;     // r
              colors[i3 + 1] = 0.8; // g
              colors[i3 + 2] = 0.0; // b
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
              size: 5, // å¢å¤§å°ºå¯¸æ–¹ä¾¿çœ‹è¦‹
              vertexColors: true,
              transparent: true,
              opacity: 0.8
            });
            
            this.particles = new THREE.Points(geometry, material);
            this.particles.renderOrder = 5; // åœ¨èƒŒæ™¯ä¹‹ä¸Šï¼Œå¡ç‰‡ä¹‹ä¸‹
            
            if (this.scene) {
              this.scene.add(this.particles);
              console.log('ç²’å­ç³»çµ±å·²æ·»åŠ åˆ°å ´æ™¯ï¼Œç²’å­æ•¸é‡:', particleCount);
              console.log('ç²’å­ä½ç½®ç¯„åœ: XÂ±10, YÂ±10, ZÂ±5');
              console.log('å ´æ™¯ä¸­ç‰©ä»¶æ•¸é‡:', this.scene.children.length);
            } else {
              console.warn('å ´æ™¯ä¸å­˜åœ¨ï¼Œç„¡æ³•æ·»åŠ ç²’å­ç³»çµ±');
            }
            
          } catch (error) {
            console.error('ç²’å­ç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
          }
        }

        /**
         * æ›´æ–°ç²’å­å‹•ç•«
         */
        updateParticles() {
          if (!this.particles) return;
          
          const positions = this.particles.geometry.attributes.position.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            // ç·©æ…¢æ—‹è½‰ç²’å­
            positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
            positions[i + 1] += Math.cos(Date.now() * 0.001 + i) * 0.01;
          }
          
          this.particles.geometry.attributes.position.needsUpdate = true;
          this.particles.rotation.y += 0.001;
        }

        /**
         * æ¸¬è©¦æ¸²æŸ“å‡½æ•¸ - ç«‹å³æ¸²æŸ“ä¸€å¹€æª¢æŸ¥å ´æ™¯
         */
        testRender() {
          if (!this.renderer || !this.scene || !this.camera) {
            console.warn('ç„¡æ³•æ¸¬è©¦æ¸²æŸ“ - ç¼ºå°‘å¿…è¦çµ„ä»¶');
            return;
          }
          
          console.log('åŸ·è¡Œæ¸¬è©¦æ¸²æŸ“...');
          console.log('å ´æ™¯ç‰©ä»¶:', this.scene.children.map(child => child.type));
          
          // æ›´æ–°ç²’å­ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          this.updateParticles();
          
          // æ¸²æŸ“ä¸€å¹€
          this.renderer.render(this.scene, this.camera);
          
          console.log('æ¸¬è©¦æ¸²æŸ“å®Œæˆ');
        }
      }
      
      // Create and expose ThreeJSAnimation instance
      window.threeJSAnimation = new ThreeJSAnimation();
      console.log('Three.js animation instance created and attached to window');
      window.threeJSLoadedSuccessfully = true;
      
    } catch (error) {
      console.error('Failed to create Three.js animation instance:', error);
      window.threeJSLoadedSuccessfully = false;
    }
  </script>
  <script src="js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Theme toggle button -->
  <button id="themeToggle" class="theme-toggle-button" aria-label="åˆ‡æ›è‰²å½©æ¨¡å¼">
    <span class="theme-icon-light">â˜€ï¸</span>
    <span class="theme-icon-dark" style="display:none;">ğŸŒ™</span>
  </button>
</body>
</html>
