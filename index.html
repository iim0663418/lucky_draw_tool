<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>moda_draw_tool</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Roboto:wght@400;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet" />
</head>
<body>
  <header class="app-header text-center py-4">
    <h1>moda å¹¸é‹æŠ½çå°å·¥å…·</h1>
  </header>
  <main class="container py-4">
    <section class="setup-section card shadow-sm mb-4">
      <div class="card-body">
        <h2 class="section-title mb-3">æŠ½çè¨­å®š</h2>
        <div class="row">
          <div class="col-lg-4 mb-3">
            <label for="nameList" class="form-label">åƒèˆ‡è€…æ¸…å–®ï¼ˆæ¯è¡Œä¸€ä½ï¼‰ï¼š</label>
            <textarea class="form-control" id="nameList" rows="8" placeholder="è¼¸å…¥åƒèˆ‡è€…åå–®..."></textarea>
            <p id="participantCount" class="mt-2 text-muted small">ç›®å‰åƒèˆ‡è€… 0 äºº</p>
          </div>
          <div class="col-lg-8">
            <div class="row">
              <div class="col-md-6 mb-3">
                <label for="prizeInput" class="form-label">æŠ½çå“é …ï¼š</label>
                <input type="text" class="form-control" id="prizeInput" placeholder="ä¾‹å¦‚ï¼šé ­ç - Switch" />
              </div>
              <div class="col-md-6 mb-3">
                <label for="seedInput" class="form-label">å¹¸é‹ç¨®å­ï¼ˆå¯ç•™ç©ºï¼‰ï¼š</label>
                <input type="text" class="form-control" id="seedInput" placeholder="ä¾‹å¦‚ï¼šluckyday2025" />
              </div>
              <div class="col-md-6 mb-3">
                <label for="winnerCount" class="form-label">å¾—çäººæ•¸ï¼š</label>
                <input type="number" class="form-control" id="winnerCount" value="1" min="1" placeholder="è¼¸å…¥æ•¸å­—" />
              </div>
              <div class="col-md-6 mb-3 align-self-center">
                <div class="form-check mt-3">
                  <input class="form-check-input" type="checkbox" id="allowRepeatCheckbox">
                  <label class="form-check-label" for="allowRepeatCheckbox">å…è¨±é‡è¤‡ä¸­ç</label>
                </div>
                <small id="repeatHelp" class="form-text text-muted">ä¸å‹¾é¸æ™‚ï¼Œä¸­çè€…å°‡å¾åå–®ç§»é™¤ã€‚</small>
              </div>
            </div>
          </div>
        </div>
        <div class="text-center mt-3">
          <button id="drawButton" class="btn btn-draw btn-lg px-5">é–‹å§‹æŠ½ç</button>
        </div>
      </div>
    </section>

    <div class="mt-4 text-center" id="seedDisplayBlock" style="display:none;">
      <h5 class="text-muted small">æœ¬æ¬¡å¹¸é‹ç¨®å­ï¼š<span id="seedDisplay" class="fw-bold"></span></h5>
    </div>

    <section class="results-section mt-4 mb-4">
      <h2 class="section-title text-center mb-3">ä¸­çåå–®æ­æ›‰</h2>
      <div id="winnersContainer" class="row gy-4"></div>
    </section>

    <section id="remainingWrapper" class="remaining-section card shadow-sm mb-4" style="display:none;">
      <div class="card-body">
        <h3 class="section-title-sm mb-2">å‰©é¤˜åƒèˆ‡è€…</h3>
        <div id="remainingContainer" class="fadeInList"></div>
      </div>
    </section>

    <section class="history-section card shadow-sm">
      <div class="card-body">
        <h2 class="section-title mb-3">æŠ½çæ­·å²ç´€éŒ„</h2>
        <div class="row mb-3 align-items-end">
          <div class="col-md-5 mb-2 mb-md-0">
            <label for="prizeFilter" class="form-label">ä¾å“é …ç¯©é¸ï¼š</label>
            <select id="prizeFilter" class="form-select">
              <option value="å…¨éƒ¨">é¡¯ç¤ºå…¨éƒ¨å“é …</option>
            </select>
          </div>
          <div class="col-md-7 text-md-end">
            <button id="clearHistory" class="btn btn-clear-history">ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨ç´€éŒ„</button>
          </div>
        </div>
        <div id="historyContainer"></div>
        <nav class="pagination-container mt-3">
          <ul id="paginationContainer" class="pagination justify-content-center"></ul>
        </nav>
      </div>
    </section>
  </main>
  <footer class="app-footer text-center py-3 mt-4">
    <p class="mb-0 small">&copy; <span id="currentYear"></span> moda å¹¸é‹æŠ½ç. All rights reserved.</p>
  </footer>

  <!-- Overlay for countdown -->
  <div id="overlay" class="overlay">
    <div class="blur-bg"></div>
    <div id="countdownContainer"></div>
  </div>

  <!-- Three.js container for cyberpunk animation -->
  <div id="threeContainer" style="
    position: fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%);
    width: 1200px; 
    height: 700px;
    max-width: 95vw;
    max-height: 95vh;
    z-index: 9999; 
    display: none; 
    background: linear-gradient(135deg, rgba(10,10,10,0.95) 0%, rgba(26,0,51,0.9) 25%, rgba(0,0,102,0.85) 50%, rgba(51,0,102,0.9) 75%, rgba(102,0,153,0.95) 100%);
    border-radius: 15px;
    box-shadow: 0 20px 60px rgba(0,255,255,0.3), 0 0 40px rgba(255,0,255,0.2), inset 0 0 30px rgba(0,255,255,0.1);
    border: 2px solid rgba(0,255,255,0.5);
    overflow: hidden;
    backdrop-filter: blur(5px);
  "></div>

  <!-- å¼•å…¥ confetti å‡½å¼åº« -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>
  <!-- Three.js å‹•ç•«ç³»çµ±ä½¿ç”¨ ES Modules -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    
    console.log('Three.js ES module loaded:', THREE);
    
    // Make THREE available globally
    window.THREE = THREE;
    
    // Import and create animation class
    try {
      // Simple Three.js animation class
      class ThreeJSAnimation {
        constructor() {
          console.log('ES Module ThreeJSAnimation constructor called');
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.cards = [];
          this.container = null;
          this.isAnimating = false;
          this.animationCallback = null;
          this.clickHandlerAdded = false;
          
          // åˆå§‹åŒ–æ€§èƒ½é…ç½®èˆ‡åƒæ•¸ç®¡ç†
          this.initPerformanceConfig();
          
          // åˆå§‹åŒ–çµ±ä¸€ä¸»é¡Œè‰²å½©ç®¡ç†ç³»çµ±
          this.initThemeColorManager();
          
          // åˆå§‹åŒ–é¼ æ¨™äº’å‹•ç³»çµ±
          this.initMouseInteraction();
        }

        /**
         * åˆå§‹åŒ–é¼ æ¨™äº’å‹•ç³»çµ±
         */
        initMouseInteraction() {
          console.log('åˆå§‹åŒ–é¼ æ¨™äº’å‹•ç³»çµ±...');
          
          // é¼ æ¨™ç‹€æ…‹è·Ÿè¹¤
          this.mouseState = {
            position: new THREE.Vector2(),
            normalizedPosition: new THREE.Vector2(),
            isMoving: false,
            lastMoveTime: 0,
            velocity: new THREE.Vector2(),
            lastPosition: new THREE.Vector2()
          };
          
          // Raycaster ç”¨æ–¼æª¢æ¸¬äº’å‹•
          this.raycaster = new THREE.Raycaster();
          this.hoveredObjects = [];
          
          // äº’å‹•ç‰¹æ•ˆ
          this.mouseEffects = {
            ripples: [], // æ³¢ç´‹æ•ˆæœé™£åˆ—
            gravitationalField: null, // å¼•åŠ›å ´
            cursor: null // è‡ªè¨‚æ¸¸æ¨™æ•ˆæœ
          };
          
          console.log('é¼ æ¨™äº’å‹•ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
        }

        /**
         * è¨­å®šé¼ æ¨™äº‹ä»¶ç›£è½å™¨
         */
        setupMouseEventListeners() {
          if (!this.container) return;
          
          console.log('è¨­å®šé¼ æ¨™äº‹ä»¶ç›£è½å™¨...');
          
          // é¼ æ¨™ç§»å‹•äº‹ä»¶
          this.container.addEventListener('mousemove', (event) => {
            this.handleMouseMove(event);
          });
          
          // é¼ æ¨™é»æ“Šäº‹ä»¶
          this.container.addEventListener('click', (event) => {
            this.handleMouseClick(event);
          });
          
          // é¼ æ¨™é€²å…¥å’Œé›¢é–‹äº‹ä»¶
          this.container.addEventListener('mouseenter', () => {
            this.mouseState.isMoving = true;
          });
          
          this.container.addEventListener('mouseleave', () => {
            this.mouseState.isMoving = false;
            this.clearHoverEffects();
          });
          
          console.log('é¼ æ¨™äº‹ä»¶ç›£è½å™¨è¨­å®šå®Œæˆ');
        }

        /**
         * è™•ç†é¼ æ¨™ç§»å‹•äº‹ä»¶
         */
        handleMouseMove(event) {
          if (!this.container || !this.camera) return;
          
          const rect = this.container.getBoundingClientRect();
          
          // æ›´æ–°é¼ æ¨™ä½ç½®
          this.mouseState.lastPosition.copy(this.mouseState.position);
          this.mouseState.position.x = event.clientX - rect.left;
          this.mouseState.position.y = event.clientY - rect.top;
          
          // æ¨™æº–åŒ–åº§æ¨™ (-1 åˆ° 1)
          this.mouseState.normalizedPosition.x = (this.mouseState.position.x / rect.width) * 2 - 1;
          this.mouseState.normalizedPosition.y = -(this.mouseState.position.y / rect.height) * 2 + 1;
          
          // è¨ˆç®—é¼ æ¨™é€Ÿåº¦
          this.mouseState.velocity.subVectors(this.mouseState.position, this.mouseState.lastPosition);
          
          this.mouseState.isMoving = true;
          this.mouseState.lastMoveTime = Date.now();
          
          // é€²è¡Œ Raycasting æª¢æ¸¬
          this.performRaycasting();
          
          // æ›´æ–°å¼•åŠ›å ´æ•ˆæœ
          this.updateGravitationalField();
        }

        /**
         * è™•ç†é¼ æ¨™é»æ“Šäº‹ä»¶
         */
        handleMouseClick(event) {
          console.log('é¼ æ¨™é»æ“Šäº‹ä»¶:', event);
          
          // å‰µå»ºæ³¢ç´‹æ•ˆæœ
          this.createRippleEffect(this.mouseState.normalizedPosition.clone());
          
          // æª¢æ¸¬é»æ“Šçš„ç‰©ä»¶
          this.performRaycasting();
          
          // å¦‚æœé»æ“Šåˆ°å¡ç‰‡ï¼Œè§¸ç™¼ç‰¹æ®Šæ•ˆæœ
          if (this.hoveredObjects.length > 0) {
            this.hoveredObjects.forEach(intersection => {
              if (intersection.object.userData && intersection.object.userData.name) {
                this.triggerCardClickEffect(intersection.object);
              }
            });
          }
        }

        /**
         * åŸ·è¡Œ Raycasting æª¢æ¸¬
         */
        performRaycasting() {
          if (!this.raycaster || !this.camera || !this.scene) return;
          
          // è¨­å®š raycaster
          this.raycaster.setFromCamera(this.mouseState.normalizedPosition, this.camera);
          
          // æª¢æ¸¬æ‰€æœ‰å¯äº’å‹•ç‰©ä»¶
          const intersectableObjects = [];
          
          // æ·»åŠ å¡ç‰‡åˆ°æª¢æ¸¬æ¸…å–®
          if (this.cards) {
            intersectableObjects.push(...this.cards);
          }
          
          // æ·»åŠ ç²’å­åˆ°æª¢æ¸¬æ¸…å–®ï¼ˆé¸æ“‡æ€§ï¼‰
          if (this.spriteParticleGroups) {
            this.spriteParticleGroups.forEach(group => {
              // åªæª¢æ¸¬å¤§å°ºå¯¸ç²’å­
              const largeParticles = group.sprites.filter(sprite => sprite.scale.x > 1.0);
              intersectableObjects.push(...largeParticles);
            });
          }
          
          // åŸ·è¡Œç¢°æ’æª¢æ¸¬
          const intersections = this.raycaster.intersectObjects(intersectableObjects);
          
          // æ¸…é™¤ä¹‹å‰çš„hoveræ•ˆæœ
          this.clearHoverEffects();
          
          // æ‡‰ç”¨æ–°çš„hoveræ•ˆæœ
          this.hoveredObjects = intersections.slice(0, 3); // é™åˆ¶æœ€å¤š3å€‹ç‰©ä»¶
          this.applyHoverEffects();
        }

        /**
         * æ‡‰ç”¨hoveræ•ˆæœ
         */
        applyHoverEffects() {
          this.hoveredObjects.forEach(intersection => {
            const object = intersection.object;
            
            if (object.userData && object.userData.effects) {
              // å¡ç‰‡hoveræ•ˆæœ
              this.applyCardHoverEffect(object);
            } else if (object.material && object.material.opacity !== undefined) {
              // ç²’å­hoveræ•ˆæœ
              this.applyParticleHoverEffect(object);
            }
          });
        }

        /**
         * æ‡‰ç”¨å¡ç‰‡hoveræ•ˆæœ
         */
        applyCardHoverEffect(card) {
          if (!card.userData.animationState) return;
          
          card.userData.animationState.isHovered = true;
          
          // å¢å¼·å…‰æšˆ
          if (card.userData.effects.edgeGlowLayers) {
            card.userData.effects.edgeGlowLayers.forEach(layer => {
              if (layer.material) {
                layer.material.opacity *= 1.5;
              }
            });
          }
          
          // è¼•å¾®æ”¾å¤§
          const hoverScale = 1.05;
          card.scale.multiplyScalar(hoverScale);
        }

        /**
         * æ‡‰ç”¨ç²’å­hoveræ•ˆæœ
         */
        applyParticleHoverEffect(particle) {
          // å¢å¼·ç²’å­äº®åº¦å’Œå°ºå¯¸
          if (particle.material) {
            particle.material.opacity = Math.min(1.0, particle.material.opacity * 1.3);
          }
          particle.scale.multiplyScalar(1.2);
        }

        /**
         * æ¸…é™¤hoveræ•ˆæœ
         */
        clearHoverEffects() {
          this.hoveredObjects.forEach(intersection => {
            const object = intersection.object;
            
            if (object.userData && object.userData.animationState) {
              object.userData.animationState.isHovered = false;
            }
          });
          
          this.hoveredObjects = [];
        }

        /**
         * å‰µå»ºæ³¢ç´‹æ•ˆæœ
         */
        createRippleEffect(position) {
          const rippleGeometry = new THREE.RingGeometry(0.1, 0.1, 16);
          const rippleMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
          });
          
          const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
          
          // å°‡è¢å¹•åº§æ¨™è½‰æ›ç‚ºä¸–ç•Œåº§æ¨™
          const worldPosition = new THREE.Vector3(position.x, position.y, 0);
          worldPosition.unproject(this.camera);
          
          ripple.position.copy(worldPosition);
          ripple.position.z = 0; // ç¢ºä¿åœ¨åˆé©çš„æ·±åº¦
          ripple.renderOrder = 999;
          
          const rippleData = {
            mesh: ripple,
            startTime: Date.now(),
            duration: 1000, // 1ç§’
            maxRadius: 5
          };
          
          this.mouseEffects.ripples.push(rippleData);
          
          if (this.scene) {
            this.scene.add(ripple);
          }
        }

        /**
         * æ›´æ–°å¼•åŠ›å ´æ•ˆæœ
         */
        updateGravitationalField() {
          if (!this.spriteParticleGroups || !this.mouseState.isMoving) return;
          
          const mouseWorldPos = new THREE.Vector3(
            this.mouseState.normalizedPosition.x,
            this.mouseState.normalizedPosition.y,
            0
          );
          mouseWorldPos.unproject(this.camera);
          
          // å½±éŸ¿é™„è¿‘çš„ç²’å­
          this.spriteParticleGroups.forEach(group => {
            group.sprites.forEach(sprite => {
              const distance = sprite.position.distanceTo(mouseWorldPos);
              
              if (distance < 10) { // å½±éŸ¿ç¯„åœ
                const force = (10 - distance) / 10; // åŠ›çš„å¼·åº¦
                const direction = new THREE.Vector3()
                  .subVectors(mouseWorldPos, sprite.position)
                  .normalize()
                  .multiplyScalar(force * 0.02);
                
                // æ‡‰ç”¨å¼•åŠ›æˆ–æ–¥åŠ›
                if (this.mouseState.velocity.length() > 5) {
                  // å¿«é€Ÿç§»å‹•æ™‚ç”¢ç”Ÿæ–¥åŠ›
                  sprite.position.sub(direction);
                } else {
                  // æ…¢é€Ÿç§»å‹•æ™‚ç”¢ç”Ÿå¼•åŠ›
                  sprite.position.add(direction);
                }
              }
            });
          });
        }

        /**
         * è§¸ç™¼å¡ç‰‡é»æ“Šæ•ˆæœ
         */
        triggerCardClickEffect(card) {
          console.log('è§¸ç™¼å¡ç‰‡é»æ“Šæ•ˆæœ:', card.userData.name);
          
          // å‰µå»ºçˆ†ç‚¸å¼å…‰æšˆ
          if (card.userData.effects.aura) {
            const aura = card.userData.effects.aura;
            
            // å‹•ç•«åƒæ•¸
            const startTime = Date.now();
            const duration = 800;
            
            const animateExplosion = () => {
              const elapsed = Date.now() - startTime;
              const progress = elapsed / duration;
              
              if (progress < 1) {
                // çˆ†ç‚¸å¼æ”¾å¤§
                const scale = 1 + progress * 4;
                aura.scale.setScalar(scale);
                
                // é€æ˜åº¦è®ŠåŒ–
                aura.material.uniforms.intensity.value = (1 - progress) * 2;
                
                requestAnimationFrame(animateExplosion);
              } else {
                // é‡ç½®
                aura.scale.setScalar(1);
                aura.material.uniforms.intensity.value = 0;
              }
            };
            
            animateExplosion();
          }
        }

        /**
         * æ›´æ–°é¼ æ¨™äº’å‹•æ•ˆæœ
         */
        updateMouseEffects(time) {
          // æ›´æ–°æ³¢ç´‹æ•ˆæœ
          this.mouseEffects.ripples = this.mouseEffects.ripples.filter(rippleData => {
            const elapsed = Date.now() - rippleData.startTime;
            const progress = elapsed / rippleData.duration;
            
            if (progress < 1) {
              // æ›´æ–°æ³¢ç´‹
              const currentRadius = rippleData.maxRadius * progress;
              rippleData.mesh.geometry.dispose();
              rippleData.mesh.geometry = new THREE.RingGeometry(
                currentRadius * 0.8, 
                currentRadius, 
                16
              );
              
              rippleData.mesh.material.opacity = (1 - progress) * 0.8;
              
              return true;
            } else {
              // ç§»é™¤å®Œæˆçš„æ³¢ç´‹
              if (this.scene) {
                this.scene.remove(rippleData.mesh);
              }
              rippleData.mesh.geometry.dispose();
              rippleData.mesh.material.dispose();
              return false;
            }
          });
          
          // æª¢æŸ¥é¼ æ¨™éœæ­¢ç‹€æ…‹
          if (Date.now() - this.mouseState.lastMoveTime > 100) {
            this.mouseState.isMoving = false;
          }
        }

        /**
         * åˆå§‹åŒ–æ€§èƒ½é…ç½®èˆ‡åƒæ•¸ç®¡ç†
         */
        initPerformanceConfig() {
          console.log('åˆå§‹åŒ–æ€§èƒ½é…ç½®ç³»çµ±...');
          
          // å‹•æ…‹èª¿æ•´é…ç½®
          this.dynamicLayoutConfig = {
            // å¡ç‰‡å°ºå¯¸é…ç½®ï¼ˆå¯èª¿ç¯€ï¼‰
            sizeFactors: {
              single: 2.0,      // å–®å¼µå¡ç‰‡æ”¾å¤§ä¿‚æ•¸
              dual: 1.8,        // å…©å¼µå¡ç‰‡æ”¾å¤§ä¿‚æ•¸
              triple: 1.5,      // ä¸‰å¼µå¡ç‰‡æ”¾å¤§ä¿‚æ•¸
              medium: 1.3,      // ä¸­ç­‰æ•¸é‡åŸºæº–ä¿‚æ•¸
              standard: 1.0     // æ¨™æº–å°ºå¯¸ä¿‚æ•¸
            },
            
            // å…‰æšˆå¼·åº¦é…ç½®
            glowFactors: {
              maxIntensity: 2.1,  // æœ€å¤§å…‰æšˆå¼·åº¦ï¼ˆ1å¼µå¡ç‰‡ï¼‰
              minIntensity: 0.8,  // æœ€å°å…‰æšˆå¼·åº¦ï¼ˆè¶…å¤šå¡ç‰‡ï¼‰
              boostThreshold: 3   // å°‘é‡å¡ç‰‡å¼·åŒ–é–¾å€¼
            },
            
            // é–“è·é…ç½®
            spacingFactors: {
              singleCard: { x: 0, y: 0 },
              dualCard: { x: 5.0, y: 0 },
              tripleCard: { x: 4.5, y: 0 },
              gridBase: { x: 4.0, y: 3.0 },
              gridDecrement: { x: 0.2, y: 0.1 }
            },
            
            // æ€§èƒ½å„ªåŒ–é…ç½®
            performance: {
              maxCardCount: 50,        // æœ€å¤§æ”¯æ´å¡ç‰‡æ•¸é‡
              floatAnimationThreshold: 3, // å•Ÿç”¨æµ®å‹•å‹•ç•«çš„å¡ç‰‡æ•¸é‡é–¾å€¼
              updateFrequency: 0.033,  // æ›´æ–°é »ç‡ (30fps)
              enableHoverEffect: true,  // æ˜¯å¦å•Ÿç”¨hoveræ•ˆæœ
              enableFloatAnimation: true // æ˜¯å¦å•Ÿç”¨æµ®å‹•å‹•ç•«
            }
          };
          
          // æ€§èƒ½ç›£æ§
          this.performanceStats = {
            frameCount: 0,
            lastFpsCheck: 0,
            averageFps: 60,
            droppedFrames: 0,
            isLowPerformance: false
          };
          
          console.log('æ€§èƒ½é…ç½®ç³»çµ±åˆå§‹åŒ–å®Œæˆ', this.dynamicLayoutConfig);
        }

        /**
         * å‹•æ…‹æ€§èƒ½èª¿æ•´
         */
        adjustPerformanceSettings(cardCount) {
          const config = this.dynamicLayoutConfig.performance;
          
          // æ ¹æ“šå¡ç‰‡æ•¸é‡è‡ªå‹•èª¿æ•´æ€§èƒ½è¨­å®š
          if (cardCount > 20) {
            // å¤§é‡å¡ç‰‡æ™‚é™ä½æ•ˆæœå¼·åº¦
            config.enableFloatAnimation = false;
            config.enableHoverEffect = false;
            config.updateFrequency = 0.05; // 20fps
          } else if (cardCount > 10) {
            // ä¸­ç­‰æ•¸é‡æ™‚é©åº¦èª¿æ•´
            config.enableFloatAnimation = false;
            config.enableHoverEffect = true;
            config.updateFrequency = 0.04; // 25fps
          } else {
            // å°‘é‡å¡ç‰‡æ™‚å•Ÿç”¨å…¨éƒ¨æ•ˆæœ
            config.enableFloatAnimation = true;
            config.enableHoverEffect = true;
            config.updateFrequency = 0.033; // 30fps
          }
          
          console.log(`ç‚º ${cardCount} å¼µå¡ç‰‡èª¿æ•´æ€§èƒ½è¨­å®š:`, config);
        }

        /**
         * çµ±ä¸€ä¸»é¡Œè‰²å½©ç®¡ç†ç³»çµ±
         */
        initThemeColorManager() {
          console.log('åˆå§‹åŒ–çµ±ä¸€ä¸»é¡Œè‰²å½©ç®¡ç†ç³»çµ±...');
          
          this.themeColors = {
            dark: {
              // èƒŒæ™¯è‰²å½© - é™ä½äº®åº¦é¿å…æ¶çœ¼
              backgroundColor: 0x0a0a0a,
              gradientStart: 0x1a0033,
              gradientEnd: 0x660099,
              
              // ç²’å­è‰²å½© - èª¿ä½é€æ˜åº¦å¹³è¡¡
              particleOpacity: {
                dataFlow: 0.5, // å¾0.8é™ä½åˆ°0.5
                energy: 0.6,   // å¾0.9é™ä½åˆ°0.6
                glitch: 0.4,   // å¾0.7é™ä½åˆ°0.4
                ambient: 0.3   // å¾0.6é™ä½åˆ°0.3
              },
              
              // å…‰æšˆè‰²å½© - å„ªåŒ–è³½åšé¾å…‹é…è‰²
              glowColors: {
                primary: 0x00e6e6,   // èª¿å’Œé’è‰² (é™ä½é£½å’Œåº¦)
                secondary: 0xe600e6, // èª¿å’Œæ´‹ç´…è‰² (é™ä½é£½å’Œåº¦)
                accent: 0x0099cc,    // æ·±é’è—è‰² (æ›¿ä»£é»ƒè‰²)
                logoGlow: 0x5c8fb3   // æŸ”å’Œè—ç´«è‰²
              },
              
              // å¡ç‰‡ç‰¹æ•ˆè‰²å½© - çµ±ä¸€è³½åšé¾å…‹é¢¨æ ¼
              cardEffects: {
                aura: 0x00cccc,      // æŸ”å’Œé’è‰²å…‰æšˆ
                scanLine: 0xcc00cc,  // æŸ”å’Œæ´‹ç´…æƒæç·š
                edgeGlow: 0x4dd9d9   // æŸ”å’Œé’è‰²é‚Šç·£ç™¼å…‰ (ç§»é™¤é»ƒè‰²)
              },
              
              // ç„¡éšœç¤™å¡ç‰‡è‰²å½©ç³»çµ± - WCAG 4.5:1 å°æ¯”åº¦æ¨™æº–
              accessibleCard: {
                // å¡ç‰‡æ­£é¢ï¼šäº®é‡‘è‰²ä¿æŒé«˜å°æ¯”
                frontColor: 0xffd700,
                frontBorder: 0xffffff,
                
                // å¡ç‰‡èƒŒé¢ï¼šæ·±è‰²èƒŒæ™¯+æ·ºè‰²æ–‡å­—
                backBackground: 0x1a1a1a,    // æ·±ç°é»‘è‰²
                backText: 0xffffff,          // ç´”ç™½æ–‡å­—
                backBorder: 0x00ffff,        // é’è‰²é‚Šæ¡†
                backOverlay: 0x000000,       // é»‘è‰²é®ç½©
                
                // å¼·åŒ–é‚Šæ¡†
                primaryBorder: 0x00ffff,     // é’è‰²ä¸»é‚Šæ¡†
                secondaryBorder: 0xffffff,   // ç™½è‰²å‰¯é‚Šæ¡†
                glowColor: 0x66ffff,         // æ·ºé’è‰²å…‰æšˆ
                
                // é™°å½±ç³»çµ±
                shadowColor: 0x000000,       // ç´”é»‘é™°å½±
                shadowIntensity: 0.8
              },
              
              // å•†æ¨™è‰²å½©
              logoOpacity: 0.3,
              logoColorTint: 0x8888cc,
              
              // å…‰ç’°é€æ˜åº¦ä¿‚æ•¸ - é™ä½å¼·åº¦
              ringOpacityMultiplier: 0.8, // å¾1.2é™ä½åˆ°0.8
              neonIntensity: 0.6          // å¾1.0é™ä½åˆ°0.6
            },
            
            light: {
              // èƒŒæ™¯è‰²å½©
              backgroundColor: 0x2a2a3a,
              gradientStart: 0x3a3a4a,
              gradientEnd: 0x4a4a5a,
              
              // ç²’å­è‰²å½©
              particleOpacity: {
                dataFlow: 0.5,
                energy: 0.6,
                glitch: 0.4,
                ambient: 0.3
              },
              
              // å…‰æšˆè‰²å½©ï¼ˆæ·¡è‰²æ¨¡å¼å„ªåŒ–ï¼‰
              glowColors: {
                primary: 0x5cb3b3,   // æ·¡é’è‰² (é€²ä¸€æ­¥é™ä½é£½å’Œåº¦)
                secondary: 0xb35cb3, // æ·¡æ´‹ç´…è‰² (é€²ä¸€æ­¥é™ä½é£½å’Œåº¦)
                accent: 0x5c99b3,    // æ·¡è—è‰²èª¿ (æ›¿ä»£é»ƒè‰²)
                logoGlow: 0x8099cc   // æ·¡è—ç´«è‰²
              },
              
              // å¡ç‰‡ç‰¹æ•ˆè‰²å½© - æ·¡è‰²æ¨¡å¼çµ±ä¸€é¢¨æ ¼
              cardEffects: {
                aura: 0x66b3b3,      // æ·¡é’è‰²å…‰æšˆ
                scanLine: 0xb366b3,  // æ·¡æ´‹ç´…æƒæç·š
                edgeGlow: 0x66b3cc   // æ·¡è—è‰²é‚Šç·£ç™¼å…‰ (ç§»é™¤é»ƒè‰²)
              },
              
              // ç„¡éšœç¤™å¡ç‰‡è‰²å½©ç³»çµ± - æ·ºè‰²æ¨¡å¼
              accessibleCard: {
                // å¡ç‰‡æ­£é¢ï¼šæ·±é‡‘è‰²ä¿æŒå°æ¯”
                frontColor: 0xcc9900,
                frontBorder: 0x333333,
                
                // å¡ç‰‡èƒŒé¢ï¼šæ·ºè‰²èƒŒæ™¯+æ·±è‰²æ–‡å­—
                backBackground: 0xf5f5f5,    // æ·ºç°ç™½è‰²
                backText: 0x222222,          // æ·±ç°é»‘è‰²æ–‡å­—
                backBorder: 0x0066cc,        // æ·±è—è‰²é‚Šæ¡†
                backOverlay: 0xffffff,       // ç™½è‰²é®ç½©
                
                // å¼·åŒ–é‚Šæ¡†
                primaryBorder: 0x0066cc,     // æ·±è—è‰²ä¸»é‚Šæ¡†
                secondaryBorder: 0x333333,   // æ·±ç°è‰²å‰¯é‚Šæ¡†
                glowColor: 0x4488cc,         // ä¸­è—è‰²å…‰æšˆ
                
                // é™°å½±ç³»çµ±
                shadowColor: 0x000000,       // ç´”é»‘é™°å½±
                shadowIntensity: 0.6
              },
              
              // å•†æ¨™è‰²å½©
              logoOpacity: 0.2,
              logoColorTint: 0xaaaadd,
              
              // å…‰ç’°é€æ˜åº¦ä¿‚æ•¸
              ringOpacityMultiplier: 0.7,
              neonIntensity: 0.6
            }
          };
          
          // ç•¶å‰ä¸»é¡Œ
          this.currentTheme = 'dark';
          
          console.log('ä¸»é¡Œè‰²å½©ç®¡ç†ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
        }

        /**
         * å–å¾—ç•¶å‰ä¸»é¡Œçš„è‰²å½©é…ç½®
         */
        getCurrentThemeColors() {
          return this.themeColors[this.currentTheme];
        }

        init() {
          this.container = document.getElementById('threeContainer');
          
          if (!this.container) {
            console.error('Three.js container not found');
            return false;
          }

          console.log('Container found:', this.container);
          
          // Force container to be visible and get computed style
          this.container.style.display = 'block';
          
          // Wait a moment for CSS to apply, then get dimensions
          setTimeout(() => {
            const rect = this.container.getBoundingClientRect();
            console.log('Container getBoundingClientRect:', rect);
          }, 10);
          
          // Use fallback dimensions if container reports 0 size
          let width = this.container.clientWidth || 1200;
          let height = this.container.clientHeight || 700;
          
          // If still 0, use window dimensions as fallback
          if (width === 0 || height === 0) {
            width = Math.min(window.innerWidth * 0.9, 1200);
            height = Math.min(window.innerHeight * 0.9, 700);
            console.log('Using fallback dimensions:', width, 'x', height);
          }
          
          console.log('Final container dimensions:', width, 'x', height);

          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
          this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          
          this.renderer.setSize(width, height);
          // ä½¿ç”¨æ·±è—è‰²èƒŒæ™¯ï¼Œå®Œå…¨ä¸é€æ˜ï¼Œé¿å…è©­ç•°çš„è¦–è¦ºæ•ˆæœ
          this.renderer.setClearColor(0x1a1a2e, 1.0);
          
          // å•Ÿç”¨æ·±åº¦æ¸¬è©¦å’Œæ¸²æŸ“é †åºæ’åº
          this.renderer.sortObjects = true;
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½å„ªåŒ–
          
          // Style the canvas to ensure it's visible
          this.renderer.domElement.style.position = 'absolute';
          this.renderer.domElement.style.top = '0';
          this.renderer.domElement.style.left = '0';
          this.renderer.domElement.style.width = '100%';
          this.renderer.domElement.style.height = '100%';
          this.renderer.domElement.style.zIndex = '1';
          
          this.container.appendChild(this.renderer.domElement);
          
          // è¨­ç½®é©ç•¶çš„å…‰ç…§ç³»çµ±
          // ç’°å¢ƒå…‰ï¼šæä¾›åŸºç¤ç…§æ˜
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
          this.scene.add(ambientLight);
          
          // ä¸»æ–¹å‘å…‰ï¼šæ¨¡æ“¬å¤ªé™½å…‰
          const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
          mainLight.position.set(5, 10, 5);
          mainLight.castShadow = false; // é—œé–‰é™°å½±ä»¥æé«˜æ€§èƒ½
          this.scene.add(mainLight);
          
          // è£œå…‰ï¼šå¾å¦ä¸€å€‹è§’åº¦æä¾›æŸ”å’Œç…§æ˜
          const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
          fillLight.position.set(-5, 0, 3);
          this.scene.add(fillLight);
          
          console.log('å…‰ç…§ç³»çµ±è¨­ç½®å®Œæˆ');
          
          // è¨­ç½®ç›¸æ©Ÿä½ç½®ï¼Œæä¾›æœ€ä½³è¦–è§’
          this.camera.position.set(0, 2, 12); // ç¨å¾®æé«˜ä¸¦é é›¢ï¼Œç²å¾—æ›´å¥½çš„è¦–è§’
          this.camera.lookAt(0, 0, 0);
          
          // è¨­ç½®ç›¸æ©Ÿåƒæ•¸
          this.camera.near = 0.1;
          this.camera.far = 100;
          this.camera.updateProjectionMatrix();
          
          console.log('ç›¸æ©Ÿè¨­ç½®å®Œæˆï¼Œä½ç½®:', this.camera.position);
          
          // åˆå§‹åŒ–è³½åšé¾å…‹èƒŒæ™¯æ•ˆæœ
          console.log('åˆå§‹åŒ–è³½åšé¾å…‹èƒŒæ™¯æ•ˆæœ...');
          this.createModaSvgTexture();
          this.createBackgroundPlane();
          // æš«æ™‚è¨»è§£ç²’å­ç³»çµ±ä»¥å¯¦ç¾ç°¡ç´„é¢¨æ ¼
          // this.initParticleSystem();
          
          console.log('Three.js initialized successfully');
          console.log('Scene objects count:', this.scene.children.length);
          console.log('Camera position:', this.camera.position);
          console.log('Renderer size:', this.renderer.getSize(new THREE.Vector2()));

          // å•Ÿå‹•æ€§èƒ½ç›£æ§ç³»çµ±
          this.initPerformanceMonitoring();
          
          // è¨­å®šé¼ æ¨™äº’å‹•äº‹ä»¶ç›£è½å™¨
          this.setupMouseEventListeners();

          window.addEventListener('resize', () => this.onWindowResize(), false);
          return true;
        }

        onWindowResize() {
          if (!this.camera || !this.renderer || !this.container) return;
          
          this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        }

        createCard(name, scaleFactor = 1.0, glowIntensity = 1.0, focusEnhancement = {}) {
          console.log('Creating card for:', name, { scaleFactor, glowIntensity });
          
          // ç²å–ç•¶å‰ä¸»é¡Œçš„ç„¡éšœç¤™é…è‰²
          const colors = this.getCurrentThemeColors();
          const cardColors = colors.accessibleCard;
          
          // å‰µå»ºå‹•æ…‹å°ºå¯¸çš„å¡ç‰‡ - æ ¹æ“š scaleFactor èª¿æ•´å¹¾ä½•é«”å°ºå¯¸
          const baseWidth = 2;
          const baseHeight = 3;
          const geometry = new THREE.PlaneGeometry(
            baseWidth * scaleFactor, 
            baseHeight * scaleFactor
          );
          
          // å¡ç‰‡æ­£é¢ï¼šä½¿ç”¨ç„¡éšœç¤™é…è‰²
          const frontMaterial = new THREE.MeshLambertMaterial({ 
            color: cardColors.frontColor,
            side: THREE.DoubleSide
          });
          
          // å¡ç‰‡èƒŒé¢ï¼šè¼‰å…¥é«˜å°æ¯”åº¦æ–‡å­—è²¼åœ–
          let backTexture = null;
          let backMaterial = null;
          
          try {
            backTexture = this.createAccessibleTextTexture(name, cardColors);
            
            // æª¢æŸ¥è²¼åœ–æ˜¯å¦æˆåŠŸå‰µå»º
            if (backTexture && backTexture.image) {
              backMaterial = new THREE.MeshLambertMaterial({ 
                map: backTexture,
                side: THREE.DoubleSide,
                color: 0xffffff,
                transparent: false
              });
              console.log('ç„¡éšœç¤™è²¼åœ–è¼‰å…¥æˆåŠŸ:', name);
            } else {
              throw new Error('è²¼åœ–å‰µå»ºå¤±æ•—');
            }
          } catch (error) {
            console.warn('è²¼åœ–è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨å¾Œå‚™æè³ª:', error);
            // å¾Œå‚™æè³ªï¼šä½¿ç”¨ç„¡éšœç¤™é…è‰²
            backMaterial = new THREE.MeshLambertMaterial({
              color: cardColors.backBackground,
              side: THREE.DoubleSide
            });
          }
          
          const card = new THREE.Mesh(geometry, frontMaterial);
          
          // è¨­å®šå¡ç‰‡æ¸²æŸ“é †åºç‚ºæœ€é«˜å„ªå…ˆç´šï¼ˆç¢ºä¿æ°¸é åœ¨æœ€å‰æ™¯ï¼‰
          card.renderOrder = 1000; // æœ€é«˜æ¸²æŸ“é †åº
          
          // å‰µå»ºå¡ç‰‡å…‰æšˆå’Œæƒå…‰æ•ˆæœ - æ‡‰ç”¨å‹•æ…‹å¼·åº¦
          const cardEffects = this.createCardEffects(scaleFactor, glowIntensity, focusEnhancement);
          
          card.userData = {
            frontMaterial: frontMaterial,
            backMaterial: backMaterial,
            isFlipped: false,
            name: name,
            settled: false,
            clickable: false,
            effects: cardEffects,
            scaleFactor: scaleFactor, // å„²å­˜ç¸®æ”¾å› å­ä¾›å¾ŒçºŒä½¿ç”¨
            glowIntensity: glowIntensity, // å„²å­˜å…‰æšˆå¼·åº¦
            focusEnhancement: focusEnhancement // å„²å­˜ç„¦é»å¼·åŒ–åƒæ•¸
          };
          
          // å°‡ç‰¹æ•ˆæ·»åŠ ç‚ºå¡ç‰‡çš„å­ç‰©ä»¶
          if (cardEffects.aura) card.add(cardEffects.aura);
          if (cardEffects.scanLine) card.add(cardEffects.scanLine);
          if (cardEffects.edgeGlowLayers) {
            cardEffects.edgeGlowLayers.forEach(layer => card.add(layer));
          }
          if (cardEffects.backMask) card.add(cardEffects.backMask);
          if (cardEffects.frontGlow) card.add(cardEffects.frontGlow);
          if (cardEffects.shadowLayers) {
            cardEffects.shadowLayers.forEach(shadow => card.add(shadow));
          }
          
          console.log('Card created for:', name);
          console.log('Front material color:', frontMaterial.color.getHexString());
          if (backTexture && backTexture.image) {
            console.log('Back texture size:', backTexture.image.width, 'x', backTexture.image.height);
          }
          
          return card;
        }

        /**
         * å‰µå»ºè‡ªè¨‚ Shader Material éœ“è™¹å…‰æšˆæ•ˆæœ
         */
        createNeonShaderMaterial(color, intensity = 1.0) {
          const vertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
              vUv = uv;
              vPosition = position;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `;
          
          const fragmentShader = `
            uniform float time;
            uniform vec3 color;
            uniform float intensity;
            uniform float pulseSpeed;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
              // è·é›¢ä¸­å¿ƒçš„è·é›¢
              vec2 center = vec2(0.5, 0.5);
              float dist = distance(vUv, center);
              
              // è„ˆå‹•æ•ˆæœ
              float pulse = sin(time * pulseSpeed) * 0.3 + 0.7;
              
              // éœ“è™¹å…‰æšˆæ•ˆæœ
              float neonGlow = 1.0 - smoothstep(0.0, 0.5, dist);
              neonGlow = pow(neonGlow, 2.0);
              
              // é‚Šç·£ç™¼å…‰
              float edgeGlow = 1.0 - smoothstep(0.3, 0.5, dist);
              edgeGlow *= 0.8;
              
              // çµ„åˆæ•ˆæœ
              float finalIntensity = (neonGlow + edgeGlow) * intensity * pulse;
              
              gl_FragColor = vec4(color, finalIntensity);
            }
          `;
          
          return new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
              time: { value: 0.0 },
              color: { value: new THREE.Color(color) },
              intensity: { value: intensity },
              pulseSpeed: { value: 2.0 }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
          });
        }

        /**
         * å‰µå»ºæƒå…‰æ¢å¸¶ Shader Material
         */
        createScanLineShaderMaterial(color, speed = 1.0) {
          const vertexShader = `
            varying vec2 vUv;
            
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `;
          
          const fragmentShader = `
            uniform float time;
            uniform vec3 color;
            uniform float speed;
            varying vec2 vUv;
            
            void main() {
              // æƒå…‰æ¢å¸¶ä½ç½®
              float scanPos = mod(time * speed, 2.0) - 1.0; // -1 åˆ° 1
              float scanLine = abs(vUv.y - (scanPos + 1.0) * 0.5);
              
              // æƒå…‰å¼·åº¦
              float intensity = 1.0 - smoothstep(0.0, 0.1, scanLine);
              intensity = pow(intensity, 3.0);
              
              // é »é–ƒæ•ˆæœ
              float flicker = sin(time * 15.0) * 0.1 + 0.9;
              
              gl_FragColor = vec4(color, intensity * flicker);
            }
          `;
          
          return new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
              time: { value: 0.0 },
              color: { value: new THREE.Color(color) },
              speed: { value: speed }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
          });
        }

        /**
         * å‰µå»ºå¡ç‰‡ç‰¹æ•ˆç³»çµ± - ç„¡éšœç¤™å¢å¼·ç‰ˆï¼ˆå‹•æ…‹å¼·åº¦ï¼‰
         */
        createCardEffects(scaleFactor = 1.0, glowIntensity = 1.0, focusEnhancement = {}) {
          const effects = {};
          const colors = this.getCurrentThemeColors();
          const cardColors = colors.accessibleCard;
          
          console.log('å‰µå»ºå¡ç‰‡ç‰¹æ•ˆ:', { scaleFactor, glowIntensity, focusEnhancement });
          
          try {
            // 1. è½åœ°éœ“è™¹å…‰æšˆæ•ˆæœ - ä½¿ç”¨è‡ªè¨‚ Shader Material
            const auraRadius = 2.5 * scaleFactor; // å¢å¼·å…‰æšˆä»¥è£œå„Ÿç²’å­ç§»é™¤
            const auraGeometry = new THREE.RingGeometry(0.1 * scaleFactor, auraRadius, 32);
            const auraMaterial = this.createNeonShaderMaterial(0x00ffff, glowIntensity * 1.2); // å¢å¼·å¼·åº¦
            effects.aura = new THREE.Mesh(auraGeometry, auraMaterial);
            effects.aura.rotation.x = -Math.PI / 2; // å¹³èººåœ¨åœ°é¢
            effects.aura.position.y = -1.5 * scaleFactor; // ä½ç½®éš¨å¡ç‰‡ç¸®æ”¾
            effects.aura.renderOrder = 500; // ä¸­ç­‰æ¸²æŸ“é †åº
            
            // 2. éœ“è™¹æƒå…‰æ¢å¸¶ - ä½¿ç”¨è‡ªè¨‚ Shader Material
            const scanWidth = 2.2 * scaleFactor;
            const scanHeight = 0.1 * scaleFactor;
            const scanGeometry = new THREE.PlaneGeometry(scanWidth, scanHeight);
            const scanMaterial = this.createScanLineShaderMaterial(0xff00ff, 0.8);
            effects.scanLine = new THREE.Mesh(scanGeometry, scanMaterial);
            effects.scanLine.position.z = 0.01 * scaleFactor; // ä½ç½®éš¨å¡ç‰‡ç¸®æ”¾
            effects.scanLine.renderOrder = 600; // è¼ƒé«˜æ¸²æŸ“é †åº
            
            // 3. ç„¡éšœç¤™å¢å¼·é‚Šç·£ç™¼å…‰è¼ªå»“ - å‹•æ…‹å¤šå±¤é«˜å°æ¯”çµæ§‹
            effects.edgeGlowLayers = [];
            
            // è¨ˆç®—å‹•æ…‹å…‰æšˆé€æ˜åº¦
            const baseOpacity = Math.min(1.0, glowIntensity);
            const shadowIntensity = focusEnhancement.shadowIntensity || 1.0;
            
            // æœ€å¤–å±¤é«˜äº®è¼ªå»“ - å¼·çƒˆå°æ¯”
            const superOuterSize = { width: 2.6 * scaleFactor, height: 3.6 * scaleFactor };
            const superOuterGeometry = new THREE.EdgesGeometry(new THREE.PlaneGeometry(superOuterSize.width, superOuterSize.height));
            const superOuterMaterial = new THREE.LineBasicMaterial({
              color: cardColors.primaryBorder,
              transparent: true,
              opacity: baseOpacity * glowIntensity,
              linewidth: Math.max(1, 4 * scaleFactor),
              blending: THREE.AdditiveBlending
            });
            const superOuterGlow = new THREE.LineSegments(superOuterGeometry, superOuterMaterial);
            superOuterGlow.position.z = 0.012 * scaleFactor;
            superOuterGlow.renderOrder = 104;
            effects.edgeGlowLayers.push(superOuterGlow);
            
            // å¤–å±¤å¼·å…‰è¼ªå»“
            const outerSize = { width: 2.4 * scaleFactor, height: 3.4 * scaleFactor };
            const outerEdgeGeometry = new THREE.EdgesGeometry(new THREE.PlaneGeometry(outerSize.width, outerSize.height));
            const outerEdgeMaterial = new THREE.LineBasicMaterial({
              color: cardColors.secondaryBorder,
              transparent: true,
              opacity: 0.9 * glowIntensity,
              linewidth: Math.max(1, 3 * scaleFactor),
              blending: THREE.AdditiveBlending
            });
            const outerEdgeGlow = new THREE.LineSegments(outerEdgeGeometry, outerEdgeMaterial);
            outerEdgeGlow.position.z = 0.010 * scaleFactor;
            outerEdgeGlow.renderOrder = 103;
            effects.edgeGlowLayers.push(outerEdgeGlow);
            
            // å…§å±¤ç²¾ç´°è¼ªå»“
            const innerSize = { width: 2.2 * scaleFactor, height: 3.2 * scaleFactor };
            const innerEdgeGeometry = new THREE.EdgesGeometry(new THREE.PlaneGeometry(innerSize.width, innerSize.height));
            const innerEdgeMaterial = new THREE.LineBasicMaterial({
              color: cardColors.glowColor,
              transparent: true,
              opacity: 0.7 * glowIntensity,
              linewidth: Math.max(1, 2 * scaleFactor),
              blending: THREE.AdditiveBlending
            });
            const innerEdgeGlow = new THREE.LineSegments(innerEdgeGeometry, innerEdgeMaterial);
            innerEdgeGlow.position.z = 0.008 * scaleFactor;
            innerEdgeGlow.renderOrder = 102;
            effects.edgeGlowLayers.push(innerEdgeGlow);
            
            // 4. ç„¡éšœç¤™èƒŒé¢é®ç½©å¢å¼·å°æ¯”
            const backMaskGeometry = new THREE.PlaneGeometry(2.05, 3.05);
            const backMaskMaterial = new THREE.MeshBasicMaterial({
              color: cardColors.backOverlay,
              transparent: true,
              opacity: 0.6, // å¢å¼·é®ç½©å¼·åº¦
              side: THREE.BackSide
            });
            effects.backMask = new THREE.Mesh(backMaskGeometry, backMaskMaterial);
            effects.backMask.position.z = -0.002;
            effects.backMask.renderOrder = 95;
            
            // 5. ç„¡éšœç¤™æ­£é¢å…‰æšˆæ¡†
            const frontGlowGeometry = new THREE.PlaneGeometry(2.5, 3.5);
            const frontGlowMaterial = new THREE.MeshBasicMaterial({
              color: cardColors.frontColor,
              transparent: true,
              opacity: 0.3,
              side: THREE.DoubleSide,
              blending: THREE.AdditiveBlending
            });
            effects.frontGlow = new THREE.Mesh(frontGlowGeometry, frontGlowMaterial);
            effects.frontGlow.position.z = -0.001;
            effects.frontGlow.renderOrder = 96;
            
            // 6. å¢å¼·å‹•æ…‹é™°å½±ç³»çµ±
            effects.shadowLayers = [];
            
            // ä¸»é™°å½± - å¼·çƒˆå°æ¯”
            const mainShadowGeometry = new THREE.PlaneGeometry(2.0, 2.8); // å¾2.8x3.8ç¸®å°è‡³2.0x2.8
            const mainShadowMaterial = new THREE.MeshBasicMaterial({
              color: cardColors.shadowColor,
              transparent: true,
              opacity: cardColors.shadowIntensity,
              side: THREE.DoubleSide
            });
            const mainShadow = new THREE.Mesh(mainShadowGeometry, mainShadowMaterial);
            mainShadow.position.set(0.15, -0.15, -0.005);
            mainShadow.renderOrder = 93;
            effects.shadowLayers.push(mainShadow);
            
            // è»Ÿé™°å½± - æŸ”å’Œéæ¸¡
            const softShadowGeometry = new THREE.PlaneGeometry(2.2, 3.0); // å¾3.0x4.0ç¸®å°è‡³2.2x3.0
            const softShadowMaterial = new THREE.MeshBasicMaterial({
              color: cardColors.shadowColor,
              transparent: true,
              opacity: cardColors.shadowIntensity * 0.4,
              side: THREE.DoubleSide
            });
            const softShadow = new THREE.Mesh(softShadowGeometry, softShadowMaterial);
            softShadow.position.set(0.2, -0.2, -0.006);
            softShadow.renderOrder = 92;
            effects.shadowLayers.push(softShadow);
            
            console.log('å¢å¼·å¡ç‰‡ç‰¹æ•ˆç³»çµ±å‰µå»ºå®Œæˆ');
            
          } catch (error) {
            console.error('å¡ç‰‡ç‰¹æ•ˆç³»çµ±å‰µå»ºå¤±æ•—:', error);
          }
          
          return effects;
        }

        /**
         * è§¸ç™¼å¡ç‰‡è½åœ°å…‰æšˆç‰¹æ•ˆ
         */
        triggerCardLandingEffect(card) {
          if (!card.userData.effects || !card.userData.effects.aura) return;
          
          const aura = card.userData.effects.aura;
          const startTime = Date.now();
          const duration = 1000; // 1ç§’å‹•ç•«
          
          console.log('è§¸ç™¼å¡ç‰‡è½åœ°å…‰æšˆç‰¹æ•ˆ:', card.userData.name);
          
          const animateAura = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // å…‰æšˆæ”¾å¤§ä¸¦æ·¡å‡º
            const scale = 1 + progress * 2; // å¾1å€æ”¾å¤§åˆ°3å€
            const opacity = (1 - progress) * 0.8; // å¾0.8æ·¡å‡ºåˆ°0
            
            aura.scale.setScalar(scale);
            aura.material.opacity = opacity;
            
            if (progress < 1) {
              requestAnimationFrame(animateAura);
            } else {
              // å‹•ç•«çµæŸï¼Œé‡ç½®
              aura.scale.setScalar(1);
              aura.material.opacity = 0;
            }
          };
          
          animateAura();
        }

        /**
         * è§¸ç™¼å¡ç‰‡ç¿»è½‰æƒå…‰ç‰¹æ•ˆ
         */
        triggerCardFlipScanEffect(card) {
          if (!card.userData.effects) return;
          
          const scanLine = card.userData.effects.scanLine;
          const edgeGlow = card.userData.effects.edgeGlow;
          
          if (!scanLine || !edgeGlow) return;
          
          const startTime = Date.now();
          const duration = 500; // 0.5ç§’æƒå…‰
          
          console.log('è§¸ç™¼å¡ç‰‡ç¿»è½‰æƒå…‰ç‰¹æ•ˆ:', card.userData.name);
          
          const animateScan = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // æƒå…‰æ¢å¾ä¸Šåˆ°ä¸‹ç§»å‹•
            const yPos = 1.5 - progress * 3; // å¾é ‚éƒ¨(1.5)ç§»å‹•åˆ°åº•éƒ¨(-1.5)
            scanLine.position.y = yPos;
            scanLine.material.opacity = Math.sin(progress * Math.PI) * 0.8; // å…ˆå¢å¼·å¾Œæ·¡å‡º
            
            // é‚Šç·£ç™¼å…‰é€æ¼¸äº®èµ·
            edgeGlow.material.opacity = Math.sin(progress * Math.PI) * 0.6;
            
            if (progress < 1) {
              requestAnimationFrame(animateScan);
            } else {
              // å‹•ç•«çµæŸï¼Œé‡ç½®
              scanLine.material.opacity = 0;
              edgeGlow.material.opacity = 0;
            }
          };
          
          animateScan();
        }

        /**
         * å‰µå»ºç„¡éšœç¤™æ–‡å­—è²¼åœ– - WCAGå°æ¯”åº¦æ¨™æº–
         */
        createAccessibleTextTexture(text, cardColors) {
          try {
            console.log('å‰µå»ºç„¡éšœç¤™æ–‡å­—è²¼åœ–:', text);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // é«˜è§£æåº¦ç•«å¸ƒ
            canvas.width = 512;
            canvas.height = 768;
            
            // ä½¿ç”¨ç„¡éšœç¤™èƒŒæ™¯è‰²
            ctx.fillStyle = `#${cardColors.backBackground.toString(16).padStart(6, '0')}`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½é«˜å°æ¯”åº¦é‚Šæ¡† - é›™å±¤è¨­è¨ˆ
            // å¤–å±¤é‚Šæ¡†
            ctx.strokeStyle = `#${cardColors.primaryBorder.toString(16).padStart(6, '0')}`;
            ctx.lineWidth = 6;
            ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
            
            // å…§å±¤é‚Šæ¡†
            ctx.strokeStyle = `#${cardColors.secondaryBorder.toString(16).padStart(6, '0')}`;
            ctx.lineWidth = 2;
            ctx.strokeRect(12, 12, canvas.width - 24, canvas.height - 24);
            
            // ç„¡éšœç¤™æ–‡å­—æ¨£å¼
            ctx.fillStyle = `#${cardColors.backText.toString(16).padStart(6, '0')}`;
            ctx.font = 'bold 84px "Noto Sans TC", "Microsoft JhengHei", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // å¢å¼·æ–‡å­—é™°å½±æå‡å¯è®€æ€§
            ctx.shadowColor = `#${cardColors.shadowColor.toString(16).padStart(6, '0')}`;
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // ç¹ªè£½ä¸»æ–‡å­—
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // æ·»åŠ æ–‡å­—æé‚Šå¢å¼·å°æ¯”
            ctx.strokeStyle = ctx.shadowColor;
            ctx.lineWidth = 2;
            ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
            
            // æ·»åŠ å…‰æšˆæ•ˆæœ
            ctx.shadowBlur = 8;
            ctx.shadowColor = `#${cardColors.glowColor.toString(16).padStart(6, '0')}`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // å‰µå»ºè²¼åœ–ä¸¦è¨­å®šæ­£ç¢ºçš„æ–¹å‘
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.flipY = false;
            
            // ä¿®æ­£è²¼åœ–æ–¹å‘
            texture.center = new THREE.Vector2(0.5, 0.5);
            texture.rotation = Math.PI; // 180åº¦æ—‹è½‰ä¿®æ­£æ–¹å‘
            
            texture.needsUpdate = true;
            
            console.log('ç„¡éšœç¤™æ–‡å­—è²¼åœ–å‰µå»ºæˆåŠŸ:', {
              text: text,
              size: `${canvas.width}x${canvas.height}`,
              font: ctx.font,
              backgroundColor: ctx.fillStyle,
              textColor: `#${cardColors.backText.toString(16).padStart(6, '0')}`
            });
            
            return texture;
            
          } catch (error) {
            console.error('ç„¡éšœç¤™æ–‡å­—è²¼åœ–å‰µå»ºå¤±æ•—:', error);
            
            // å‰µå»ºç„¡éšœç¤™å¾Œå‚™è²¼åœ– - WCAG AAAç´šå°æ¯”åº¦
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 768;
            
            // ä½¿ç”¨WCAG AAAç´šé«˜å°æ¯”è‰² (7:1å°æ¯”åº¦)
            ctx.fillStyle = '#000000'; // ç´”é»‘èƒŒæ™¯
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½é«˜å°æ¯”åº¦é‚Šæ¡†
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 6;
            ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
            
            // ä½¿ç”¨ç´”ç™½æ–‡å­—é…é»‘è‰²æé‚Šæå‡å¯è®€æ€§
            ctx.fillStyle = '#ffffff'; // ç´”ç™½æ–‡å­—
            ctx.font = 'bold 64px "Noto Sans TC", "Microsoft JhengHei", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ·»åŠ æ–‡å­—é™°å½±å¢å¼·å¯è®€æ€§
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            ctx.fillText('è¼‰å…¥éŒ¯èª¤', canvas.width / 2, canvas.height / 2);
            
            // æ·»åŠ æ–‡å­—æé‚Š
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText('è¼‰å…¥éŒ¯èª¤', canvas.width / 2, canvas.height / 2);
            
            return new THREE.CanvasTexture(canvas);
          }
        }

        createTextTexture(text) {
          // é‡æ–°å°å‘åˆ°ç„¡éšœç¤™ç‰ˆæœ¬
          const colors = this.getCurrentThemeColors();
          return this.createAccessibleTextTexture(text, colors.accessibleCard);
        }

        async startAnimation(winners, callback) {
          console.log('startAnimation called with winners:', winners);
          if (this.isAnimating) return;
          
          this.isAnimating = true;
          this.animationCallback = callback;
          this.cards = [];
          this.frameCount = 0; // é‡ç½®å¹€è¨ˆæ•¸å™¨
          this.timeoutHandled = false; // é‡ç½®è¶…æ™‚è™•ç†æ¨™èªŒ
          this.clickHandlingEnabled = false; // é‡ç½®é»æ“Šè™•ç†æ¨™èªŒ
          
          console.log('Initializing Three.js...');
          if (!this.init()) {
            console.error('Three.js initialization failed');
            this.isAnimating = false;
            if (callback) callback();
            return;
          }

          console.log('Setting container display to block');
          this.container.style.display = 'block';
          
          // å‹•æ…‹èª¿æ•´æ€§èƒ½è¨­å®š
          this.adjustPerformanceSettings(winners.length);
          
          // æ ¹æ“šå¡ç‰‡æ•¸é‡æ™ºèƒ½èª¿ç¯€èƒŒæ™¯äº®åº¦
          this.adjustBackgroundBrightness(winners.length);
          
          const positions = this.generatePositions(winners.length);
          const { cardScale, scaleFactor, glowIntensity, focusEnhancement } = this.calculateDynamicLayout(winners.length);
          
          winners.forEach((winner, index) => {
            const card = this.createCard(winner, scaleFactor, glowIntensity, focusEnhancement);
            
            // æ‡‰ç”¨å‹•æ…‹å¡ç‰‡ç¸®æ”¾ï¼ˆè®Šæ›ç¸®æ”¾ï¼‰
            card.scale.setScalar(cardScale);
            
            const startPos = {
              x: (Math.random() - 0.5) * 6,  // Smaller random spread
              y: 10 + Math.random() * 2,     // Higher starting position
              z: 0
            };
            
            card.position.set(startPos.x, startPos.y, startPos.z);
            
            card.userData.targetPosition = positions[index].clone();
            card.userData.velocity = {
              x: (Math.random() - 0.5) * 0.02, // æ¸›æ…¢æ°´å¹³é‹å‹•
              y: -0.02 - Math.random() * 0.01, // å¤§å¹…æ¸›æ…¢å‚ç›´é€Ÿåº¦
              z: 0
            };
            card.userData.rotationVelocity = {
              x: (Math.random() - 0.5) * 0.05,
              y: (Math.random() - 0.5) * 0.05,
              z: (Math.random() - 0.5) * 0.05
            };
            
            console.log(`Card ${index} (${winner}):`);
            console.log('  Start position:', startPos);
            console.log('  Target position:', positions[index]);
            console.log('  Target Y after adjustment:', card.userData.targetPosition.y);
            console.log('  Velocity:', card.userData.velocity);
            console.log('  Distance to fall:', startPos.y - card.userData.targetPosition.y);
            
            this.scene.add(card);
            this.cards.push(card);
          });

          console.log('All cards added to scene. Total cards:', this.cards.length);
          console.log('Scene children count:', this.scene.children.length);

          this.animate();
        }

        generatePositions(count) {
          const positions = [];
          
          // å‹•æ…‹èª¿æ•´å¡ç‰‡å°ºå¯¸å’Œé–“è·
          const { cardScale, spacing, layout, scaleFactor, focusEnhancement } = this.calculateDynamicLayout(count);
          
          console.log(`ç”Ÿæˆ ${count} å¼µå¡ç‰‡çš„ ${layout} æ’åˆ—ä½ˆå±€`);
          
          switch (layout) {
            case 'single':
              // å–®å¼µå¡ç‰‡ï¼šå®Œç¾å±…ä¸­ï¼Œç•¥å¾®å‰ç§»çªå‡ºé‡é»
              positions.push(new THREE.Vector3(0, 0, 0.5));
              break;
              
            case 'linear':
              // 2-3å¼µå¡ç‰‡ï¼šå„ªåŒ–å±…ä¸­æ©«å‘æ’åˆ—ï¼Œé–“è·æ›´èˆ’é©
              const interactionBoost = focusEnhancement.interactionBoost || 1.0;
              const adjustedSpacing = spacing.x * interactionBoost; // å°‘é‡å¡ç‰‡æ™‚åŠ å¤§é–“è·
              
              for (let i = 0; i < count; i++) {
                const x = (i - (count - 1) / 2) * adjustedSpacing;
                // æ·»åŠ å¾®å¦™çš„å¼§å½¢æ’åˆ—ï¼Œå¢åŠ è¦–è¦ºå±¤æ¬¡
                const arcOffset = count > 2 ? Math.sin((i / (count - 1)) * Math.PI) * 0.3 : 0;
                const z = arcOffset; // ä¸­é–“å¡ç‰‡ç¨å¾®å‰ç§»
                positions.push(new THREE.Vector3(x, 0, z));
              }
              break;
              
            case 'grid':
              // 4-9å¼µå¡ç‰‡ï¼šå„ªåŒ–ç¶²æ ¼æ’åˆ—ï¼Œç¢ºä¿è¦–è¦ºå¹³è¡¡
              let cols, rows;
              
              // æ™ºèƒ½è¨ˆç®—æœ€ä½³è¡Œåˆ—é…ç½®
              if (count === 4) {
                cols = 2; rows = 2; // 2x2 æ­£æ–¹å½¢
              } else if (count === 5) {
                cols = 3; rows = 2; // 3x2 ä½ˆå±€ï¼ˆç¬¬äºŒè¡Œ2å¼µå±…ä¸­ï¼‰
              } else if (count === 6) {
                cols = 3; rows = 2; // 3x2 å®Œç¾å¡«æ»¿
              } else {
                cols = Math.ceil(Math.sqrt(count));
                rows = Math.ceil(count / cols);
              }
              
              for (let i = 0; i < count; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                // é‡å°ä¸å®Œæ•´è¡Œé€²è¡Œå±…ä¸­èª¿æ•´
                let x, y;
                if (count === 5 && row === 1) {
                  // 5å¼µå¡ç‰‡ï¼šç¬¬äºŒè¡Œ2å¼µå¡ç‰‡å±…ä¸­
                  const lastRowCount = count - cols;
                  const lastRowCol = col;
                  x = (lastRowCol - (lastRowCount - 1) / 2) * spacing.x;
                } else {
                  x = (col - (cols - 1) / 2) * spacing.x;
                }
                
                y = ((rows - 1) / 2 - row) * spacing.y;
                
                // æ·»åŠ è¼•å¾®çš„éš¨æ©Ÿåç§»ï¼Œå¢åŠ è‡ªç„¶æ„Ÿ
                const randomOffset = {
                  x: (Math.random() - 0.5) * 0.1,
                  y: (Math.random() - 0.5) * 0.1,
                  z: Math.random() * 0.1
                };
                
                positions.push(new THREE.Vector3(
                  x + randomOffset.x, 
                  y + randomOffset.y, 
                  randomOffset.z
                ));
              }
              break;
              
            case 'circular':
              // 10+å¼µå¡ç‰‡ï¼šç’°ç‹€æ’åˆ—
              const radius = spacing.radius;
              const angleStep = (Math.PI * 2) / count;
              
              for (let i = 0; i < count; i++) {
                const angle = i * angleStep - Math.PI / 2; // å¾é ‚éƒ¨é–‹å§‹
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                positions.push(new THREE.Vector3(x, y, 0));
              }
              break;
              
            case 'spiral':
              // è¶…å¤šå¼µå¡ç‰‡ï¼šèºæ—‹æ’åˆ—
              const spiralSpacing = spacing.spiral;
              const spiralTurns = Math.ceil(count / 8); // æ¯åœˆ8å¼µå¡ç‰‡
              
              for (let i = 0; i < count; i++) {
                const t = i / count;
                const angle = t * spiralTurns * Math.PI * 2;
                const r = spiralSpacing * (1 + t * 2);
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                positions.push(new THREE.Vector3(x, y, 0));
              }
              break;
          }
          
          console.log(`Generated ${layout} layout for ${count} cards:`, {
            cardScale,
            spacing,
            positions: positions.length
          });
          
          return positions;
        }

        /**
         * è¨ˆç®—å‹•æ…‹ä½ˆå±€åƒæ•¸
         */
        calculateDynamicLayout(count) {
          console.log(`è¨ˆç®—å‹•æ…‹ä½ˆå±€ï¼Œå¡ç‰‡æ•¸é‡: ${count}`);
          
          const config = this.dynamicLayoutConfig;
          const sizeFactors = config.sizeFactors;
          const glowFactors = config.glowFactors;
          const spacingFactors = config.spacingFactors;
          
          let cardScale = 1.0;
          let spacing = { x: 3, y: 2.5 };
          let layout = 'grid';
          let scaleFactor = sizeFactors.standard; // ä½¿ç”¨é…ç½®çš„ç¸®æ”¾å› å­
          let glowIntensity = 1.0;
          
          // 1. å¡ç‰‡å°ºå¯¸å‹•æ…‹èª¿æ•´æ¼”ç®—æ³•ï¼ˆä½¿ç”¨å¯é…ç½®åƒæ•¸ï¼‰
          if (count <= 3) {
            // å°‘é‡å¡ç‰‡ï¼šé¡¯è‘—æ”¾å¤§
            scaleFactor = count === 1 ? sizeFactors.single : 
                         count === 2 ? sizeFactors.dual : sizeFactors.triple;
            cardScale = 1.3; // é¡å¤–çš„è®Šæ›ç¸®æ”¾
            glowIntensity = glowFactors.maxIntensity - (count - 1) * 0.3; // å…‰æšˆéš¨æ•¸é‡æ¸›å°‘è€Œå¢å¼·
            layout = count === 1 ? 'single' : 'linear';
            
            // ä½¿ç”¨é…ç½®çš„é–“è·
            spacing = count === 1 ? spacingFactors.singleCard : 
                     count === 2 ? spacingFactors.dualCard : 
                     spacingFactors.tripleCard;
                     
          } else if (count >= 4 && count <= 6) {
            // ä¸­ç­‰æ•¸é‡ï¼šé©åº¦æ”¾å¤§
            scaleFactor = 1.5 - (count - 4) * 0.1; // 1.5 åˆ° 1.3
            cardScale = 1.2 - (count - 4) * 0.05; // 1.2 åˆ° 1.1
            glowIntensity = 1.3 - (count - 4) * 0.1; // 1.3 åˆ° 1.0
            layout = 'grid';
            
            // å‹•æ…‹èª¿æ•´é–“è·
            spacing = {
              x: 4.0 - (count - 4) * 0.2, // 4.0 åˆ° 3.6
              y: 3.0 - (count - 4) * 0.1  // 3.0 åˆ° 2.8
            };
            
          } else if (count >= 7 && count <= 12) {
            // è¼ƒå¤šå¡ç‰‡ï¼šæ¨™æº–å°ºå¯¸
            scaleFactor = 1.0;
            cardScale = Math.max(0.9, 1.1 - (count - 7) * 0.03); // é€æ¼¸ç¸®å°
            glowIntensity = 1.0;
            layout = 'grid';
            
            spacing = {
              x: Math.max(2.5, 3.5 - (count - 7) * 0.15),
              y: Math.max(2.0, 2.8 - (count - 7) * 0.1)
            };
            
          } else if (count <= 20) {
            // å¤§é‡å¡ç‰‡ï¼šåœ“å½¢æ’åˆ—
            scaleFactor = 0.9;
            cardScale = Math.max(0.7, 1.0 - (count - 13) * 0.03);
            glowIntensity = 0.9;
            layout = 'circular';
            
            spacing = {
              radius: Math.max(10, 6 + count * 0.4)
            };
            
          } else {
            // è¶…å¤šå¡ç‰‡ï¼šèºæ—‹æ’åˆ—
            scaleFactor = 0.8;
            cardScale = Math.max(0.5, 0.8 - (count - 21) * 0.02);
            glowIntensity = 0.8;
            layout = 'spiral';
            
            spacing = {
              spiral: Math.max(1.5, 2.2 - (count - 21) * 0.03)
            };
          }
          
          // 2. è¦–è¦ºç„¦é»å¼·åŒ–ä¿‚æ•¸è¨ˆç®—
          const focusEnhancement = {
            shadowIntensity: Math.min(1.5, glowIntensity * 1.2),
            pulseFrequency: Math.max(0.8, 2.0 - count * 0.1), // å°‘é‡å¡ç‰‡è„ˆå‹•æ›´æ…¢
            interactionBoost: count <= 3 ? 1.5 : 1.0 // å°‘é‡å¡ç‰‡äº’å‹•åŠ å¼·
          };
          
          console.log('å‹•æ…‹ä½ˆå±€è¨ˆç®—çµæœ:', {
            count,
            scaleFactor,
            cardScale,
            glowIntensity,
            layout,
            spacing,
            focusEnhancement
          });
          
          return { 
            cardScale, 
            spacing, 
            layout, 
            scaleFactor, 
            glowIntensity, 
            focusEnhancement 
          };
        }

        animate() {
          if (!this.isAnimating) return;
          
          requestAnimationFrame(() => this.animate());
          
          let allSettled = true;
          
          // Add frame counter for debugging (but don't spam console)
          if (!this.frameCount) this.frameCount = 0;
          this.frameCount++;
          
          // è¶…æ™‚å¼·åˆ¶è½åœ°æ©Ÿåˆ¶ - é¿å…å¡ç‰‡é•·æ™‚é–“é£„æµ®
          const maxFrames = 1200; // 20ç§’è¶…æ™‚ (60fps * 20)
          if (this.frameCount > maxFrames && !this.timeoutHandled) {
            console.log('å‹•ç•«è¶…æ™‚ï¼Œå¼·åˆ¶æ‰€æœ‰å¡ç‰‡è½åœ°');
            this.timeoutHandled = true; // é˜²æ­¢é‡è¤‡è§¸ç™¼
            this.cards.forEach((card, index) => {
              if (!card.userData.settled) {
                card.position.copy(card.userData.targetPosition);
                card.rotation.set(0, 0, 0);
                card.userData.settled = true;
                card.userData.clickable = true;
                card.renderOrder = 10;
                console.log(`å¼·åˆ¶è½åœ°ï¼šå¡ç‰‡ ${index}`);
              }
            });
          }
          
          // æ¸›å°‘è¼¸å‡ºé »ç‡
          if (this.frameCount % 120 === 0) { // æ¯2ç§’è¼¸å‡ºä¸€æ¬¡
            console.log(`å‹•ç•«é€²è¡Œä¸­ï¼Œç¬¬${this.frameCount}å¹€ï¼Œç§»å‹•ä¸­çš„å¡ç‰‡: ${this.cards.filter(c => !c.userData.settled).length}å¼µ`);
          }
          
          this.cards.forEach((card, index) => {
            if (!card.userData.settled) {
              const oldPos = card.position.y;
              card.position.add(card.userData.velocity);
              card.rotation.x += card.userData.rotationVelocity.x;
              card.rotation.y += card.userData.rotationVelocity.y;
              card.rotation.z += card.userData.rotationVelocity.z;
              
              card.userData.velocity.y += -0.002; // æ¸›æ…¢é‡åŠ›åŠ é€Ÿåº¦
              
              // åªåœ¨é—œéµæ™‚åˆ»è¼¸å‡ºé™¤éŒ¯è³‡è¨Š
              if (this.frameCount === 1 || this.frameCount === 30 || this.frameCount % 60 === 0) {
                console.log(`å‹•ç•«ç¬¬${this.frameCount}å¹€ - å¡ç‰‡${index}: Y=${card.position.y.toFixed(1)}, ç›®æ¨™=${card.userData.targetPosition.y.toFixed(1)}, é€Ÿåº¦=${card.userData.velocity.y.toFixed(3)}`);
              }
              
              // æ”¹å–„è½åœ°åˆ¤æ–· - å¢åŠ ç·©è¡å€åŸŸé¿å…ç©¿é€
              const distanceToTarget = card.position.y - card.userData.targetPosition.y;
              const tolerance = 0.1; // ç·©è¡å€åŸŸ
              
              if (distanceToTarget <= tolerance) {
                // ä½ç½®æ ¡æ­£ï¼šç¢ºä¿å¡ç‰‡ç²¾ç¢ºè½åœ¨ç›®æ¨™ä½ç½®
                card.position.copy(card.userData.targetPosition);
                card.rotation.set(0, 0, 0);
                card.userData.settled = true;
                card.userData.clickable = true;
                
                // è¨­å®šæ¸²æŸ“é †åºï¼Œç¢ºä¿å¡ç‰‡åœ¨æ­£ç¢ºå±¤ç´š
                card.renderOrder = 10;
                
                // è§¸ç™¼å¡ç‰‡è½åœ°å…‰æšˆç‰¹æ•ˆ
                this.triggerCardLandingEffect(card);
                
                console.log(`å¡ç‰‡ ${index} (${card.userData.name}) å·²ç©©å®šè½åœ°`);
              } else {
                allSettled = false;
                
                // é™¤éŒ¯è¼¸å‡º
                if (this.frameCount % 120 === 0) {
                  console.log(`å¡ç‰‡ ${index} ä¸‹è½ä¸­: Y=${card.position.y.toFixed(2)}, ç›®æ¨™=${card.userData.targetPosition.y.toFixed(2)}, è·é›¢=${distanceToTarget.toFixed(2)}`);
                }
              }
            }
          });
          
          if (allSettled && !this.allCardsFlipped() && !this.clickHandlingEnabled) {
            console.log('All cards settled, enabling click handling');
            this.enableClickHandling();
            this.clickHandlingEnabled = true; // é˜²æ­¢é‡è¤‡èª¿ç”¨
          }
          
          // æ›´æ–°è³½åšé¾å…‹èƒŒæ™¯æ•ˆæœ - ç²’å­ç³»çµ±å·²æš«æ™‚ç§»é™¤
          // this.updateParticles();
          
          // æ€§èƒ½ç›£æ§è¨ˆæ•¸
          if (this.performanceStats) {
            this.performanceStats.frameCount++;
          }
          
          this.renderer.render(this.scene, this.camera);
          
          if (allSettled && this.allCardsFlipped()) {
            console.log('All cards flipped, ending animation in 2 seconds');
            setTimeout(() => {
              this.endAnimation();
            }, 2000);
          }
        }

        enableClickHandling() {
          if (this.clickHandlerAdded) return;
          
          this.clickHandlerAdded = true;
          this.renderer.domElement.addEventListener('click', (event) => this.onCanvasClick(event), false);
        }

        onCanvasClick(event) {
          const rect = this.renderer.domElement.getBoundingClientRect();
          const mouse = new THREE.Vector2();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, this.camera);
          
          // åªæª¢æ¸¬å·²ç©©å®šä¸”å¯é»æ“Šçš„å¡ç‰‡
          const clickableCards = this.cards.filter(card => 
            card.userData.settled && 
            card.userData.clickable && 
            !card.userData.isFlipped
          );
          
          const intersects = raycaster.intersectObjects(clickableCards);
          
          if (intersects.length > 0) {
            const card = intersects[0].object;
            console.log('é»æ“Šå¡ç‰‡:', card.userData.name);
            this.flipCard(card);
          } else {
            console.log('é»æ“Šä½ç½®ç„¡æœ‰æ•ˆå¡ç‰‡', {
              mousePos: mouse,
              clickableCards: clickableCards.length,
              settledCards: this.cards.filter(c => c.userData.settled).length
            });
          }
        }

        flipCard(card) {
          card.userData.isFlipped = true;
          card.userData.clickable = false;
          
          // è§¸ç™¼ç¿»è½‰æƒå…‰ç‰¹æ•ˆ
          this.triggerCardFlipScanEffect(card);
          
          const duration = 500;
          const startTime = Date.now();
          
          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            card.rotation.y = progress * Math.PI;
            
            if (progress >= 0.5 && card.material === card.userData.frontMaterial) {
              card.material = card.userData.backMaterial;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            }
          };
          
          animate();
        }

        allCardsFlipped() {
          return this.cards.every(card => card.userData.isFlipped);
        }

        endAnimation() {
          this.isAnimating = false;
          this.container.style.display = 'none';
          
          // é‡ç½®æ‰€æœ‰ç‹€æ…‹æ¨™èªŒ
          this.frameCount = 0;
          this.timeoutHandled = false;
          this.clickHandlingEnabled = false;
          
          // æ¸…ç†å¡ç‰‡
          this.cards.forEach(card => {
            this.scene.remove(card);
          });
          this.cards = [];
          
          // æ¸…ç†è³½åšé¾å…‹èƒŒæ™¯æ•ˆæœ (ä½†ä¿ç•™ä»¥ä¾›ä¸‹æ¬¡ä½¿ç”¨)
          // æ³¨æ„ï¼šä¸æ¸…ç†èƒŒæ™¯å’Œç²’å­ï¼Œè®“å®ƒå€‘å¯ä»¥åœ¨ä¸‹æ¬¡å‹•ç•«ä¸­é‡è¤‡ä½¿ç”¨
          
          if (this.clickHandlerAdded && this.renderer && this.renderer.domElement) {
            this.renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
            this.clickHandlerAdded = false;
          }
          
          if (this.renderer && this.container) {
            this.container.removeChild(this.renderer.domElement);
            this.renderer.dispose();
            this.renderer = null;
          }
          
          // é‡ç½®å ´æ™¯ä»¥ä¾›ä¸‹æ¬¡ä½¿ç”¨
          this.scene = null;
          this.camera = null;
          
          if (this.animationCallback) {
            this.animationCallback();
          }
        }

        // === é€²éš3DåŠŸèƒ½å¯¦ç¾ ===
        
        /**
         * å‰µå»ºè³½åšé¾å…‹é¢¨æ ¼çš„MODAå•†æ¨™èƒŒæ™¯ç´‹ç† - å„ªåŒ–ç‰ˆæœ¬
         */
        createModaSvgTexture() {
          console.log('å‰µå»ºè³½åšé¾å…‹MODAèƒŒæ™¯ç´‹ç† - å„ªåŒ–ç‰ˆæœ¬...');
          
          try {
            // è¼‰å…¥å¯¦éš›å•†æ¨™åœ–ç‰‡ä¸¦é€²è¡Œä½é£½å’Œåº¦è™•ç†
            const loader = new THREE.TextureLoader();
            this.logoTexture = loader.load('./logo.jpg', 
              (texture) => {
                console.log('MODAå•†æ¨™åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼Œé–‹å§‹é€²è¡Œä½é£½å’Œåº¦è™•ç†...');
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                
                // é€²è¡Œåœ–åƒå¾Œè™•ç†ä»¥å¯¦ç¾ä½é£½å’Œåº¦å’Œæ¨¡ç³Šæ•ˆæœ
                this.processLogoTexture(texture);
              },
              undefined,
              (error) => {
                console.error('MODAå•†æ¨™åœ–ç‰‡è¼‰å…¥å¤±æ•—:', error);
                // å‰µå»ºå¾Œå‚™å•†æ¨™ç´‹ç†
                this.createFallbackLogoTexture();
              }
            );

            // å‰µå»ºè³½åšé¾å…‹é¢¨æ ¼çš„SVGèƒŒæ™¯
            const svgData = `
              <svg width="1024" height="1024" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <!-- è³½åšé¾å…‹æ¼¸è®Š -->
                  <linearGradient id="cyberpunkGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#0a0a0a;stop-opacity:1" />
                    <stop offset="25%" style="stop-color:#1a0033;stop-opacity:0.9" />
                    <stop offset="50%" style="stop-color:#000066;stop-opacity:0.8" />
                    <stop offset="75%" style="stop-color:#330066;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#660099;stop-opacity:1" />
                  </linearGradient>
                  
                  <!-- éœ“è™¹å…‰æšˆæ¿¾é¡ -->
                  <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                    <feMerge> 
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                  
                  <!-- æ•¸æ“šæµå‹•ç•« -->
                  <pattern id="dataFlowPattern" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse">
                    <rect width="50" height="50" fill="none"/>
                    <line x1="0" y1="25" x2="50" y2="25" stroke="#00ffff" stroke-width="1" opacity="0.3">
                      <animate attributeName="stroke-dasharray" values="0,50;25,25;50,0" dur="2s" repeatCount="indefinite"/>
                    </line>
                    <line x1="25" y1="0" x2="25" y2="50" stroke="#ff00ff" stroke-width="1" opacity="0.2">
                      <animate attributeName="stroke-dasharray" values="0,50;25,25;50,0" dur="3s" repeatCount="indefinite"/>
                    </line>
                  </pattern>
                </defs>
                
                <!-- åŸºç¤èƒŒæ™¯ -->
                <rect width="100%" height="100%" fill="url(#cyberpunkGradient)"/>
                
                <!-- æ•¸æ“šæµç¶²æ ¼ -->
                <rect width="100%" height="100%" fill="url(#dataFlowPattern)" opacity="0.4"/>
                
                <!-- éœ“è™¹å¹¾ä½•å½¢ç‹€ -->
                <circle cx="512" cy="512" r="300" fill="none" stroke="#00ffff" stroke-width="3" opacity="0.6" filter="url(#neonGlow)">
                  <animate attributeName="r" values="300;320;300" dur="3s" repeatCount="indefinite"/>
                </circle>
                
                <circle cx="512" cy="512" r="200" fill="none" stroke="#ff00ff" stroke-width="2" opacity="0.4" filter="url(#neonGlow)">
                  <animate attributeName="r" values="200;210;200" dur="2s" repeatCount="indefinite"/>
                </circle>
                
                <!-- å…­é‚Šå½¢æ¡†æ¶ - æ”¹ç‚ºé’è‰²èª¿ -->
                <polygon points="512,212 612,262 612,362 512,412 412,362 412,262" 
                         fill="none" stroke="#00cccc" stroke-width="2" opacity="0.4" filter="url(#neonGlow)"/>
                
                <!-- æƒæç·šæ•ˆæœ -->
                <rect x="0" y="200" width="1024" height="2" fill="#00ffff" opacity="0.8">
                  <animate attributeName="y" values="0;1024;0" dur="4s" repeatCount="indefinite"/>
                </rect>
              </svg>
            `;
            
            // è½‰æ›ç‚ºè²¼åœ–
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            this.cyberpunkTexture = loader.load(url, 
              (texture) => {
                console.log('è³½åšé¾å…‹èƒŒæ™¯ç´‹ç†è¼‰å…¥æˆåŠŸ');
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                URL.revokeObjectURL(url);
              },
              undefined,
              (error) => {
                console.error('è³½åšé¾å…‹èƒŒæ™¯ç´‹ç†è¼‰å…¥å¤±æ•—:', error);
                URL.revokeObjectURL(url);
              }
            );
            
            return this.cyberpunkTexture;
            
          } catch (error) {
            console.error('å‰µå»ºè³½åšé¾å…‹ç´‹ç†å¤±æ•—:', error);
            return null;
          }
        }

        /**
         * è™•ç†å•†æ¨™è²¼åœ– - ä½é£½å’Œåº¦å’Œæ¨¡ç³Šæ•ˆæœ
         */
        processLogoTexture(texture) {
          console.log('é–‹å§‹è™•ç†å•†æ¨™è²¼åœ–...');
          
          try {
            // å‰µå»ºç•«å¸ƒé€²è¡Œåœ–åƒè™•ç†
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // ç­‰å¾…åœ–åƒè¼‰å…¥å®Œæˆ
            const img = texture.image;
            if (!img.complete) {
              img.onload = () => this.processLogoTexture(texture);
              return;
            }
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            // ç¹ªè£½åŸå§‹åœ–åƒ
            ctx.drawImage(img, 0, 0);
            
            // ç²å–åœ–åƒæ•¸æ“š
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // é€²è¡Œä½é£½å’Œåº¦è™•ç†
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // è½‰æ›ç‚ºç°éš
              const gray = 0.299 * r + 0.587 * g + 0.114 * b;
              
              // é™ä½é£½å’Œåº¦ (ä¿ç•™30%çš„åŸå§‹è‰²å½©)
              const saturationFactor = 0.3;
              data[i] = gray + (r - gray) * saturationFactor;     // R
              data[i + 1] = gray + (g - gray) * saturationFactor; // G
              data[i + 2] = gray + (b - gray) * saturationFactor; // B
              
              // èª¿æ•´ç‚ºè³½åšé¾å…‹è‰²èª¿ (è—ç´«è‰²)
              data[i] = data[i] * 0.8;     // é™ä½ç´…è‰²
              data[i + 1] = data[i + 1] * 0.9; // ç¨å¾®é™ä½ç¶ è‰²
              data[i + 2] = data[i + 2] * 1.2; // å¢å¼·è—è‰²
              
              // æ•´é«”é€æ˜åº¦èª¿æ•´
              data[i + 3] = data[i + 3] * 0.7; // é™ä½é€æ˜åº¦
            }
            
            // å°‡è™•ç†å¾Œçš„æ•¸æ“šå¯«å›ç•«å¸ƒ
            ctx.putImageData(imageData, 0, 0);
            
            // æ‡‰ç”¨æ¨¡ç³Šæ•ˆæœ
            ctx.filter = 'blur(2px)';
            ctx.globalAlpha = 0.8;
            ctx.drawImage(canvas, 0, 0);
            
            // å‰µå»ºæ–°çš„ç´‹ç†
            const processedTexture = new THREE.CanvasTexture(canvas);
            processedTexture.minFilter = THREE.LinearFilter;
            processedTexture.magFilter = THREE.LinearFilter;
            processedTexture.wrapS = THREE.ClampToEdgeWrapping;
            processedTexture.wrapT = THREE.ClampToEdgeWrapping;
            processedTexture.needsUpdate = true;
            
            // æ›¿æ›åŸå§‹ç´‹ç†
            this.logoTexture = processedTexture;
            
            console.log('å•†æ¨™è²¼åœ–è™•ç†å®Œæˆ');
            
          } catch (error) {
            console.error('å•†æ¨™è²¼åœ–è™•ç†å¤±æ•—:', error);
            this.createFallbackLogoTexture();
          }
        }

        /**
         * å‰µå»ºå¾Œå‚™å•†æ¨™ç´‹ç†
         */
        createFallbackLogoTexture() {
          console.log('å‰µå»ºå¾Œå‚™å•†æ¨™ç´‹ç†...');
          
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            
            // å‰µå»ºè³½åšé¾å…‹é¢¨æ ¼çš„MODAæ–‡å­—
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, 'rgba(102, 102, 204, 0.6)');
            gradient.addColorStop(0.5, 'rgba(136, 136, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(170, 170, 255, 0.2)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½MODAæ–‡å­— - å¢å¼·å°æ¯”åº¦å’Œå¯è®€æ€§
            const colors = this.getCurrentThemeColors();
            const isDarkTheme = this.currentTheme === 'dark';
            
            // æ ¹æ“šä¸»é¡Œé¸æ“‡é©ç•¶çš„æ–‡å­—é¡è‰²ï¼Œç¢ºä¿WCAG AAç´šå°æ¯”åº¦ (4.5:1)
            const textColor = isDarkTheme ? 'rgba(255, 255, 255, 0.9)' : 'rgba(51, 51, 51, 0.9)';
            const shadowColor = isDarkTheme ? 'rgba(0, 255, 255, 0.8)' : 'rgba(0, 102, 204, 0.8)';
            const strokeColor = isDarkTheme ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)';
            
            ctx.fillStyle = textColor;
            ctx.font = 'bold 140px "Noto Sans TC", "Microsoft JhengHei", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ·»åŠ æ–‡å­—æé‚Šå¢å¼·å°æ¯”
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 4;
            ctx.strokeText('MODA', canvas.width / 2, canvas.height / 2);
            
            // ç¹ªè£½ä¸»æ–‡å­—
            ctx.fillText('MODA', canvas.width / 2, canvas.height / 2);
            
            // æ·»åŠ å…‰æšˆæ•ˆæœ
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillText('MODA', canvas.width / 2, canvas.height / 2);
            
            const fallbackTexture = new THREE.CanvasTexture(canvas);
            fallbackTexture.minFilter = THREE.LinearFilter;
            fallbackTexture.magFilter = THREE.LinearFilter;
            fallbackTexture.needsUpdate = true;
            
            this.logoTexture = fallbackTexture;
            
            console.log('å¾Œå‚™å•†æ¨™ç´‹ç†å‰µå»ºå®Œæˆ');
            
          } catch (error) {
            console.error('å¾Œå‚™å•†æ¨™ç´‹ç†å‰µå»ºå¤±æ•—:', error);
          }
        }

        /**
         * é åˆå§‹åŒ–3Då ´æ™¯å’Œè³‡æº
         */
        preInitializeScene(container) {
          console.log('é åˆå§‹åŒ–3Då ´æ™¯...');
          
          if (this.scene) {
            console.log('å ´æ™¯å·²å­˜åœ¨ï¼Œè·³éé åˆå§‹åŒ–');
            return true;
          }
          
          try {
            // é å‰µå»ºå ´æ™¯çµ„ä»¶
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, 1200/700, 0.1, 1000);
            
            // é è¼‰å…¥MODAèƒŒæ™¯
            this.createModaSvgTexture();
            
            // å‰µå»ºèƒŒæ™¯å¹³é¢
            this.createBackgroundPlane();
            
            // é ç½®ç²’å­ç³»çµ± - æš«æ™‚ç§»é™¤ä»¥å¯¦ç¾ç°¡ç´„é¢¨æ ¼
            // this.initParticleSystem();
            
            console.log('å ´æ™¯é åˆå§‹åŒ–å®Œæˆ');
            return true;
            
          } catch (error) {
            console.error('å ´æ™¯é åˆå§‹åŒ–å¤±æ•—:', error);
            return false;
          }
        }

        /**
         * åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
         */
        initAudioSystem() {
          console.log('åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±...');
          
          try {
            // é è¼‰å…¥éŸ³æ•ˆæ–‡ä»¶
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // å¡ç‰‡ç¿»è½‰éŸ³æ•ˆ
            this.loadSound('cardFlip', 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGAZCECa0y6r');
            
            // æˆåŠŸéŸ³æ•ˆ
            this.loadSound('success', 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGAZCECa0');
            
            console.log('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–å®Œæˆ');
            return true;
            
          } catch (error) {
            console.warn('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
            return false;
          }
        }

        /**
         * è¼‰å…¥éŸ³æ•ˆæ–‡ä»¶
         */
        loadSound(name, dataUrl) {
          // æ¨¡æ“¬éŸ³æ•ˆè¼‰å…¥ - å¯¦éš›å°ˆæ¡ˆä¸­æœƒè¼‰å…¥çœŸå¯¦éŸ³æ•ˆæ–‡ä»¶
          this.sounds = this.sounds || {};
          this.sounds[name] = { loaded: true, url: dataUrl };
        }

        /**
         * æ’­æ”¾éŸ³æ•ˆ
         */
        playSound(name) {
          if (this.sounds && this.sounds[name] && this.sounds[name].loaded) {
            console.log('æ’­æ”¾éŸ³æ•ˆ:', name);
            // å¯¦éš›æ’­æ”¾é‚è¼¯
          }
        }

        /**
         * å‰µå»ºè³½åšé¾å…‹é¢¨æ ¼çš„MODAèƒŒæ™¯å¹³é¢ - å„ªåŒ–ç‰ˆæœ¬
         */
        createBackgroundPlane() {
          console.log('å‰µå»ºè³½åšé¾å…‹èƒŒæ™¯å¹³é¢ - å„ªåŒ–ç‰ˆæœ¬...');
          
          try {
            // å¤§å‹é æ™¯èƒŒæ™¯å¹³é¢ - ç¢ºä¿è¦†è“‹æ•´å€‹è¦–çª—
            const bgGeometry = new THREE.PlaneGeometry(80, 50);
            
            // è³½åšé¾å…‹æ¼¸è®ŠèƒŒæ™¯
            let bgMaterial;
            if (this.cyberpunkTexture) {
              bgMaterial = new THREE.MeshLambertMaterial({
                map: this.cyberpunkTexture,
                transparent: true,
                opacity: 0.6, // é™ä½é€æ˜åº¦é¿å…æ¶çœ¼
                side: THREE.DoubleSide
              });
            } else {
              // å¾Œå‚™è³½åšé¾å…‹æ¼¸è®Šè‰²å½©
              bgMaterial = new THREE.MeshLambertMaterial({
                color: 0x1a0033, // æ·±ç´«è‰²
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
              });
            }
            
            this.backgroundPlane = new THREE.Mesh(bgGeometry, bgMaterial);
            this.backgroundPlane.position.set(0, 0, -25); // ç½®æ–¼æ›´é è·é›¢ä½œç‚ºé æ™¯
            this.backgroundPlane.renderOrder = -15;
            
            // å•†æ¨™èƒŒæ™¯å¹³é¢ - å¢å¼·è¾¨è­˜åº¦è¨­è¨ˆ
            const logoGeometry = new THREE.PlaneGeometry(24, 24); // å¤§å¹…å¢å¤§å°ºå¯¸
            let logoMaterial;
            
            if (this.logoTexture) {
              logoMaterial = new THREE.MeshLambertMaterial({
                map: this.logoTexture,
                transparent: true,
                opacity: 0.6, // æé«˜é€æ˜åº¦å¢å¼·å¯è¦‹æ€§
                alphaTest: 0.05,
                color: 0xaaaaff, // æé«˜é£½å’Œåº¦å¢å¼·å°æ¯”
                blending: THREE.AdditiveBlending // æ·»åŠ åŠ æ³•æ··åˆå¢å¼·å…‰æ•ˆ
              });
            } else {
              // å¾Œå‚™å•†æ¨™é¡¯ç¤º - å¢å¼·ç‰ˆ
              logoMaterial = new THREE.MeshLambertMaterial({
                color: 0x8888ff, // æé«˜é£½å’Œåº¦
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
              });
            }
            
            this.logoPlane = new THREE.Mesh(logoGeometry, logoMaterial);
            this.logoPlane.position.set(0, 0, -18); // ç§»åˆ°æ›´å‰æ–¹å¢å¼·å¯è¦‹æ€§
            this.logoPlane.renderOrder = -8;
            
            // æ·»åŠ logoå°ˆç”¨è„ˆå‹•å…‰æšˆ
            this.createLogoEnhancedGlow();
            
            // éœ“è™¹å…‰æšˆæ•ˆæœåœˆ - ç‡Ÿé€ é æ™¯éœ§åŒ–æ„Ÿ
            this.createNeonRings();
            this.createLogoGlowEffect();
            
            if (this.scene) {
              this.scene.add(this.backgroundPlane);
              this.scene.add(this.logoPlane);
              console.log('è³½åšé¾å…‹èƒŒæ™¯å’Œå•†æ¨™å¹³é¢å·²æ·»åŠ åˆ°å ´æ™¯');
              console.log('å ´æ™¯ä¸­ç‰©ä»¶æ•¸é‡:', this.scene.children.length);
            } else {
              console.warn('å ´æ™¯ä¸å­˜åœ¨ï¼Œç„¡æ³•æ·»åŠ èƒŒæ™¯å¹³é¢');
            }
            
          } catch (error) {
            console.error('å‰µå»ºèƒŒæ™¯å¹³é¢å¤±æ•—:', error);
          }
        }

        /**
         * å‰µå»ºlogoå¢å¼·è„ˆå‹•å…‰æšˆ
         */
        createLogoEnhancedGlow() {
          console.log('å‰µå»ºlogoå¢å¼·è„ˆå‹•å…‰æšˆ...');
          
          try {
            this.logoEnhancedGlows = [];
            
            // å¤šå±¤å¼·åŒ–å…‰æšˆ
            const enhancedGlows = [
              { radius: 15, opacity: 0.4, color: 0x6666ff, pulseSpeed: 1.0 },
              { radius: 20, opacity: 0.3, color: 0x8888ff, pulseSpeed: 1.2 },
              { radius: 26, opacity: 0.2, color: 0xaaaaff, pulseSpeed: 0.8 },
              { radius: 32, opacity: 0.15, color: 0xccccff, pulseSpeed: 1.5 }
            ];
            
            enhancedGlows.forEach((glowConfig, index) => {
              const glowGeometry = new THREE.RingGeometry(glowConfig.radius * 0.7, glowConfig.radius, 64);
              const glowMaterial = new THREE.MeshBasicMaterial({
                color: glowConfig.color,
                transparent: true,
                opacity: glowConfig.opacity,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
              });
              
              const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
              // èª¿æ•´ä½ç½®é¿å…é®æ“‹å¡ç‰‡å€åŸŸï¼Œç§»è‡³æ›´é èƒŒæ™¯
              glowRing.position.set(0, 0, -25 + index * 0.1);
              glowRing.renderOrder = -10 + index;
              
              // å¢å¼·è„ˆå‹•æ•¸æ“š
              glowRing.userData = {
                rotationSpeed: 0.008 + index * 0.003,
                pulseSpeed: glowConfig.pulseSpeed,
                originalOpacity: glowConfig.opacity,
                scaleAmplitude: 0.15 + index * 0.05, // æ¸›å°ç¸®æ”¾å¹…åº¦é¿å…éåº¦å¹²æ“¾
                colorShift: index * 0.5
              };
              
              this.logoEnhancedGlows.push(glowRing);
              
              if (this.scene) {
                this.scene.add(glowRing);
              }
            });
            
            // å‰µå»ºç²¾ç´°èšå…‰é» - ä½¿ç”¨Shaderå¯¦ç¾ç´°è†©å…‰æšˆ
            const spotGeometry = new THREE.CircleGeometry(3, 32); // é€²ä¸€æ­¥ç¸®å°è‡³3
            const spotMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                opacity: { value: 0.15 },
                color: { value: new THREE.Color(0x4dcccc) },
                intensity: { value: 0.8 }
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float opacity;
                uniform vec3 color;
                uniform float intensity;
                varying vec2 vUv;
                
                void main() {
                  vec2 center = vec2(0.5, 0.5);
                  float dist = distance(vUv, center);
                  
                  // å‰µå»ºå¤šå±¤æ¼¸è®Šå…‰æšˆ
                  float innerGlow = 1.0 - smoothstep(0.0, 0.3, dist);
                  innerGlow = pow(innerGlow, 4.0);
                  
                  float outerGlow = 1.0 - smoothstep(0.0, 0.8, dist);
                  outerGlow = pow(outerGlow, 2.0) * 0.3;
                  
                  // æ·»åŠ æ™‚é–“è®ŠåŒ–
                  float pulse = sin(time * 2.0) * 0.2 + 0.8;
                  
                  float finalAlpha = (innerGlow + outerGlow) * opacity * intensity * pulse;
                  gl_FragColor = vec4(color, finalAlpha);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });
            
            this.logoSpotlight = new THREE.Mesh(spotGeometry, spotMaterial);
            // \u79fb\u81f3\u66f4\u9060\u80cc\u666f\u4f4d\u7f6e\u907f\u514d\u906e\u64cb\u5361\u7247
            this.logoSpotlight.position.set(0, 0, -22);
            this.logoSpotlight.renderOrder = -12;
            this.logoSpotlight.userData = {
              pulseSpeed: 2.0,
              originalOpacity: 0.3
            };
            
            this.logoEnhancedGlows.push(this.logoSpotlight);
            
            if (this.scene) {
              this.scene.add(this.logoSpotlight);
            }
            
            console.log('logoå¢å¼·è„ˆå‹•å…‰æšˆå‰µå»ºå®Œæˆï¼Œæ•¸é‡:', this.logoEnhancedGlows.length);
            
          } catch (error) {
            console.error('å‰µå»ºlogoå¢å¼·å…‰æšˆå¤±æ•—:', error);
          }
        }

        /**
         * å‰µå»ºå•†æ¨™å…‰æšˆæ•ˆæœ - éœ§åŒ–é æ™¯æ„Ÿ
         */
        createLogoGlowEffect() {
          console.log('å‰µå»ºå•†æ¨™å…‰æšˆæ•ˆæœ...');
          
          try {
            // å‰µå»ºå¤šå±¤å…‰æšˆåœˆï¼Œç‡Ÿé€ éœ§åŒ–æ•ˆæœ
            this.logoGlowRings = [];
            
            const glowRings = [
              { radius: 12, opacity: 0.15, color: 0x6666cc },
              { radius: 18, opacity: 0.10, color: 0x8888ff },
              { radius: 24, opacity: 0.06, color: 0xaaaaff }
            ];
            
            glowRings.forEach((glowConfig, index) => {
              const glowGeometry = new THREE.RingGeometry(glowConfig.radius, glowConfig.radius + 1, 32);
              const glowMaterial = new THREE.MeshBasicMaterial({
                color: glowConfig.color,
                transparent: true,
                opacity: glowConfig.opacity,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
              });
              
              const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
              // é€²ä¸€æ­¥å¾Œç§»ï¼Œç¢ºä¿ä¸æœƒå¹²æ“¾å‰æ™¯å…ƒç´ 
              glowRing.position.set(0, 0, -28 + index * 0.1);
              glowRing.renderOrder = -15 + index;
              
              // æ·»åŠ è¼•å¾®æ¨¡ç³Šé‹å‹•
              glowRing.userData = {
                rotationSpeed: 0.005 + index * 0.002,
                pulseSpeed: 1.2 + index * 0.3,
                originalOpacity: glowConfig.opacity
              };
              
              this.logoGlowRings.push(glowRing);
              
              if (this.scene) {
                this.scene.add(glowRing);
              }
            });
            
            console.log('å•†æ¨™å…‰æšˆæ•ˆæœå‰µå»ºå®Œæˆï¼Œæ•¸é‡:', this.logoGlowRings.length);
            
          } catch (error) {
            console.error('å‰µå»ºå•†æ¨™å…‰æšˆæ•ˆæœå¤±æ•—:', error);
          }
        }

        /**
         * å‰µå»ºéœ“è™¹å…‰ç’°æ•ˆæœ
         */
        createNeonRings() {
          console.log('å‰µå»ºéœ“è™¹å…‰ç’°æ•ˆæœ...');
          
          try {
            this.neonRings = [];
            
            // å‰µå»ºå¤šå±¤å…‰ç’° - ç§»é™¤é»ƒè‰²ï¼Œä½¿ç”¨æ¼¸å±¤é’è‰²èª¿
            const ringColors = [0x00e6e6, 0xe600e6, 0x0099cc];
            const ringRadii = [12, 15, 18];
            
            ringColors.forEach((color, index) => {
              const ringGeometry = new THREE.RingGeometry(ringRadii[index], ringRadii[index] + 0.2, 64);
              const ringMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3 - index * 0.05,
                side: THREE.DoubleSide
              });
              
              const ring = new THREE.Mesh(ringGeometry, ringMaterial);
              // èª¿æ•´éœ“è™¹ç’°ä½ç½®è‡³æ›´é èƒŒæ™¯
              ring.position.set(0, 0, -26 + index * 0.1);
              ring.renderOrder = -13 + index;
              
              // æ·»åŠ æ—‹è½‰å‹•ç•«æ•¸æ“š
              ring.userData = {
                rotationSpeed: 0.01 + index * 0.005,
                pulsePeriod: 2 + index,
                originalOpacity: 0.3 - index * 0.05
              };
              
              this.neonRings.push(ring);
              
              if (this.scene) {
                this.scene.add(ring);
              }
            });
            
            console.log('éœ“è™¹å…‰ç’°å‰µå»ºå®Œæˆï¼Œæ•¸é‡:', this.neonRings.length);
            
          } catch (error) {
            console.error('å‰µå»ºéœ“è™¹å…‰ç’°å¤±æ•—:', error);
          }
        }

        /**
         * åˆå§‹åŒ–è³½åšé¾å…‹ç²’å­ç³»çµ± - å‡ç´šç‰ˆ
         */
        initParticleSystem() {
          console.log('åˆå§‹åŒ–è³½åšé¾å…‹ç²’å­ç³»çµ± - å‡ç´šç‰ˆ...');
          
          try {
            // å‰µå»ºç²’å­è²¼åœ–atlas
            this.createParticleTextureAtlas();
            
            // å‰µå»ºå¤šæ¨£åŒ–Spriteç²’å­
            this.createAdvancedSpriteParticles();
            
            // ä¿ç•™åŸæœ‰ç²’å­ç³»çµ±ä½œç‚ºbackup
            this.createDataFlowParticles();
            this.createEnergyParticles();
            this.createGlitchParticles();
            
            // å‰µå»ºå¢å¼·æ›¿ä»£è¦–è¦ºç‰¹æ•ˆ
            this.createEnhancedVisualEffects();
            
            // ç¢ºä¿æ•´é«”é¢¨æ ¼ä¸€è‡´æ€§
            this.ensureCyberpunkThemeConsistency();
            
          } catch (error) {
            console.error('ç²’å­ç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
          }
        }

        /**
         * å‰µå»ºç²’å­è²¼åœ–Atlas - æ•´åˆå¤šç¨®å½¢ç‹€
         */
        createParticleTextureAtlas() {
          console.log('å‰µå»ºç²’å­è²¼åœ–Atlas...');
          
          try {
            // å‰µå»º512x512çš„atlasç•«å¸ƒ
            const atlasCanvas = document.createElement('canvas');
            const ctx = atlasCanvas.getContext('2d');
            atlasCanvas.width = 256; // 4x4æ ¼æ”¯æ´12+ç¨®ç²’å­é¡å‹
            atlasCanvas.height = 256;
            
            // æ¸…ç©ºç•«å¸ƒ
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 256, 256);
            
            // ç²’å­é¡å‹é…ç½® - æ“´å±•ç´°ç·»ç²’å­ç³»çµ±
            const particleTypes = [
              { name: 'circle', size: 64, color: '#00ffff' },      // åœ“å½¢ - 0,0
              { name: 'star', size: 64, color: '#ff00ff' },        // æ˜Ÿå½¢ - 64,0
              { name: 'diamond', size: 64, color: '#0099cc' },     // è±å½¢ - æ·±é’è—è‰²
              { name: 'cross', size: 64, color: '#ff6600' },       // åå­— - 192,0
              { name: 'hexagon', size: 64, color: '#6600ff' },     // å…­é‚Šå½¢ - 256,0
              { name: 'triangle', size: 64, color: '#00ff66' },    // ä¸‰è§’å½¢ - 320,0
              { name: 'line', size: 64, color: '#ff0066' },        // ç·šæ¢ - 0,64
              { name: 'dot', size: 64, color: '#66ff00' },         // é» - 64,64
              // æ–°å¢ç´°ç·»ç²’å­é¡å‹
              { name: 'smallCircle', size: 32, color: '#80cccc' }, // å°åœ“é»
              { name: 'microDot', size: 16, color: '#66b3b3' },    // å¾®é»
              { name: 'tinyLine', size: 24, color: '#4d9999' },    // ç´°ç·š
              { name: 'sparkle', size: 20, color: '#33cccc' }      // é–ƒé»
            ];
            
            // ç¹ªè£½å„ç¨®ç²’å­å½¢ç‹€
            particleTypes.forEach((type, index) => {
              const x = (index % 4) * 64 + 32; // 4åˆ—æ’åˆ—æ”¯æ´æ›´å¤šç²’å­é¡å‹
              const y = Math.floor(index / 4) * 64 + 32; // æ¯è¡Œ64åƒç´ 
              
              ctx.save();
              ctx.translate(x, y);
              
              // è¨­å®šç™¼å…‰æ•ˆæœ
              ctx.shadowColor = type.color;
              ctx.shadowBlur = 8;
              ctx.fillStyle = type.color;
              ctx.strokeStyle = type.color;
              ctx.lineWidth = 2;
              
              // ç¹ªè£½ä¸åŒå½¢ç‹€
              switch(type.name) {
                case 'circle':
                  ctx.beginPath();
                  ctx.arc(0, 0, 20, 0, Math.PI * 2);
                  ctx.fill();
                  break;
                  
                case 'star':
                  this.drawStar(ctx, 0, 0, 5, 20, 10);
                  ctx.fill();
                  break;
                  
                case 'diamond':
                  ctx.beginPath();
                  ctx.moveTo(0, -20);
                  ctx.lineTo(15, 0);
                  ctx.lineTo(0, 20);
                  ctx.lineTo(-15, 0);
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'cross':
                  ctx.beginPath();
                  ctx.moveTo(-15, -3);
                  ctx.lineTo(-3, -3);
                  ctx.lineTo(-3, -15);
                  ctx.lineTo(3, -15);
                  ctx.lineTo(3, -3);
                  ctx.lineTo(15, -3);
                  ctx.lineTo(15, 3);
                  ctx.lineTo(3, 3);
                  ctx.lineTo(3, 15);
                  ctx.lineTo(-3, 15);
                  ctx.lineTo(-3, 3);
                  ctx.lineTo(-15, 3);
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'hexagon':
                  this.drawHexagon(ctx, 0, 0, 18);
                  ctx.fill();
                  break;
                  
                case 'triangle':
                  ctx.beginPath();
                  ctx.moveTo(0, -18);
                  ctx.lineTo(16, 12);
                  ctx.lineTo(-16, 12);
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'line':
                  ctx.beginPath();
                  ctx.moveTo(-20, 0);
                  ctx.lineTo(20, 0);
                  ctx.lineWidth = 4;
                  ctx.stroke();
                  break;
                  
                case 'dot':
                  ctx.beginPath();
                  ctx.arc(0, 0, 8, 0, Math.PI * 2);
                  ctx.fill();
                  // åŠ ä¸Šå°å…‰ç’°
                  ctx.beginPath();
                  ctx.arc(0, 0, 15, 0, Math.PI * 2);
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  break;
                  
                // æ–°å¢ç´°ç·»ç²’å­é¡å‹ç¹ªè£½
                case 'smallCircle':
                  ctx.beginPath();
                  ctx.arc(0, 0, 6, 0, Math.PI * 2); // å°åœ“é»
                  ctx.fill();
                  break;
                  
                case 'microDot':
                  ctx.beginPath();
                  ctx.arc(0, 0, 3, 0, Math.PI * 2); // å¾®é»
                  ctx.fill();
                  // æ·»åŠ ç´°ç·»å…‰æšˆ
                  ctx.beginPath();
                  ctx.arc(0, 0, 8, 0, Math.PI * 2);
                  ctx.lineWidth = 0.5;
                  ctx.stroke();
                  break;
                  
                case 'tinyLine':
                  ctx.beginPath();
                  ctx.moveTo(-8, 0); // ç´°ç·š
                  ctx.lineTo(8, 0);
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  // äº¤å‰ç´°ç·š
                  ctx.beginPath();
                  ctx.moveTo(0, -8);
                  ctx.lineTo(0, 8);
                  ctx.stroke();
                  break;
                  
                case 'sparkle':
                  // é–ƒçˆæ˜Ÿå½¢æ•ˆæœ
                  ctx.beginPath();
                  ctx.moveTo(0, -6);
                  ctx.lineTo(1.5, -1.5);
                  ctx.lineTo(6, 0);
                  ctx.lineTo(1.5, 1.5);
                  ctx.lineTo(0, 6);
                  ctx.lineTo(-1.5, 1.5);
                  ctx.lineTo(-6, 0);
                  ctx.lineTo(-1.5, -1.5);
                  ctx.closePath();
                  ctx.fill();
                  break;
              }
              
              ctx.restore();
            });
            
            // å‰µå»ºThree.jsç´‹ç†
            this.particleAtlasTexture = new THREE.CanvasTexture(atlasCanvas);
            this.particleAtlasTexture.minFilter = THREE.LinearFilter;
            this.particleAtlasTexture.magFilter = THREE.LinearFilter;
            this.particleAtlasTexture.needsUpdate = true;
            
            // ä¿å­˜ç²’å­é¡å‹é…ç½®ç”¨æ–¼UVæ˜ å°„
            this.particleAtlasMap = particleTypes.map((type, index) => ({
              name: type.name,
              color: type.color,
              uvOffset: {
                x: (index % 4) / 4, // 4x4æ ¼å¸ƒå±€
                y: Math.floor(index / 4) / 4
              },
              uvScale: { x: 1/4, y: 1/4 } // æ›´æ–°UVç¸®æ”¾
            }));
            
            console.log('ç²’å­è²¼åœ–Atlaså‰µå»ºå®Œæˆï¼ŒåŒ…å«', particleTypes.length, 'ç¨®å½¢ç‹€');
            
          } catch (error) {
            console.error('ç²’å­è²¼åœ–Atlaså‰µå»ºå¤±æ•—:', error);
          }
        }

        /**
         * ç¹ªè£½æ˜Ÿå½¢è¼”åŠ©å‡½æ•¸
         */
        drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
          let rot = Math.PI / 2 * 3;
          let x = cx;
          let y = cy;
          const step = Math.PI / spikes;

          ctx.beginPath();
          ctx.moveTo(cx, cy - outerRadius);
          
          for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
          }
          
          ctx.lineTo(cx, cy - outerRadius);
          ctx.closePath();
        }

        /**
         * ç¹ªè£½å…­é‚Šå½¢è¼”åŠ©å‡½æ•¸
         */
        drawHexagon(ctx, cx, cy, radius) {
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = cx + radius * Math.cos(angle);
            const y = cy + radius * Math.sin(angle);
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
        }

        /**
         * å‰µå»ºé€²éšSpriteç²’å­ç³»çµ±
         */
        createAdvancedSpriteParticles() {
          console.log('å‰µå»ºé€²éšSpriteç²’å­ç³»çµ±...');
          
          try {
            if (!this.particleAtlasTexture) {
              console.warn('ç²’å­Atlasæœªæº–å‚™å°±ç·’ï¼Œè·³éSpriteç²’å­å‰µå»º');
              return;
            }
            
            // å‰µå»ºå¤šå€‹ç²’å­ç¾¤çµ„
            this.spriteParticleGroups = [];
            
            // æ•¸æ“šæµç²’å­ç¾¤çµ„ - é¿é–‹ä¸­å¿ƒå€åŸŸï¼Œå¢å¼·æ‹–å°¾æ•ˆæœ
            this.createSpriteGroup('dataFlow', {
              count: 35, // æ¸›å°‘æ•¸é‡é™ä½å¹²æ“¾
              particleTypes: ['microDot', 'tinyLine', 'smallCircle', 'sparkle'], // ä½¿ç”¨æ–°çš„ç´°ç·»ç²’å­
              area: { width: 40, height: 15, depth: 6 }, // ç¸®å°åˆ†å¸ƒå€åŸŸæå‡ç´°è†©åº¦
              movement: { type: 'flow', speed: 0.04 }, // ç¨å¾®æ¸›é€Ÿ
              rhythm: { frequency: 1.5, amplitude: 0.2, phaseShift: 0 }, // çµ±ä¸€ç¯€å¥é »ç‡
              trail: { enabled: true, length: 6, fade: 0.85 }, // ç¸®çŸ­æ‹–å°¾
              randomSize: { min: 0.4, max: 1.5 } // ç¸®å°å°ºå¯¸ç¯„åœ
            });
            
            // èƒ½é‡ç’°ç²’å­ç¾¤çµ„ - ç¸®å°è»Œé“åŠå¾‘é¿å…é®æ“‹
            this.createSpriteGroup('energyRing', {
              count: 25, // æ¸›å°‘æ•¸é‡
              particleTypes: ['smallCircle', 'microDot', 'sparkle'], // æ›´å°çš„èƒ½é‡ç’°ç²’å­
              area: { width: 12, height: 12, depth: 2 }, // é€²ä¸€æ­¥ç¸®å°æå‡ç²¾ç´°åº¦
              movement: { type: 'orbital', radius: 8, speed: 0.015 }, // ç¸®å°è»Œé“åŠå¾‘
              rhythm: { frequency: 1.5, amplitude: 0.25, phaseShift: Math.PI/3 }, // çµ±ä¸€ç¯€å¥é »ç‡
              trail: { enabled: true, length: 4, fade: 0.75 }, // ç¸®çŸ­æ‹–å°¾
              randomSize: { min: 0.6, max: 1.2 } // ç¸®å°å°ºå¯¸
            });
            
            // æ•…éšœé–ƒçˆç²’å­ç¾¤çµ„ - éš¨æ©Ÿå½¢ç‹€è®ŠåŒ–
            this.createSpriteGroup('glitch', {
              count: 20,
              particleTypes: ['cross', 'triangle', 'diamond', 'star'],
              area: { width: 25, height: 18, depth: 5 }, // ç¸®å°æ•…éšœç²’å­å€åŸŸ
              movement: { type: 'random', speed: 0.01 },
              rhythm: { frequency: 8.0, amplitude: 0.6, phaseShift: Math.PI/2 },
              trail: { enabled: false }, // æ•…éšœç²’å­ä¸ä½¿ç”¨æ‹–å°¾
              randomSize: { min: 0.3, max: 2.5 },
              shapeVariation: true // å•Ÿç”¨å½¢ç‹€è®ŠåŒ–
            });
            
            // èƒŒæ™¯å…‰é»ç¾¤çµ„ - å¤šå±¤æ¬¡æ·±åº¦
            this.createSpriteGroup('ambient', {
              count: 60,
              particleTypes: ['microDot', 'smallCircle', 'tinyLine'], // ç´°ç·»èƒŒæ™¯ç²’å­
              area: { width: 50, height: 30, depth: 10 }, // ç¸®å°èƒŒæ™¯ç²’å­å€åŸŸ
              movement: { type: 'drift', speed: 0.005 },
              rhythm: { frequency: 1.0, amplitude: 0.18, phaseShift: Math.PI }, // èª¿æ•´ç‚ºèˆ‡ä¸»èª¿ç›¸ç¬¦
              trail: { enabled: true, length: 3, fade: 0.95 },
              randomSize: { min: 0.2, max: 1.0 }
            });
            
            // æ–°å¢ï¼šéœ“è™¹æ‹–å°¾ç²’å­ç¾¤çµ„
            this.createSpriteGroup('neonTrails', {
              count: 25,
              particleTypes: ['tinyLine', 'sparkle'], // ç´°ç·»èƒ½é‡æµç²’å­
              area: { width: 35, height: 25, depth: 8 }, // ç¸®å°èƒ½é‡æµç²’å­å€åŸŸ
              movement: { type: 'wave', amplitude: 3, frequency: 0.5 },
              rhythm: { frequency: 1.5, amplitude: 0.4, phaseShift: Math.PI/4 }, // çµ±ä¸€ç¯€å¥é »ç‡
              trail: { enabled: true, length: 12, fade: 0.85 },
              randomSize: { min: 1.0, max: 2.5 },
              neonGlow: true
            });
            
            console.log('é€²éšSpriteç²’å­ç³»çµ±å‰µå»ºå®Œæˆï¼Œå…±', this.spriteParticleGroups.length, 'å€‹ç¾¤çµ„');
            
          } catch (error) {
            console.error('é€²éšSpriteç²’å­ç³»çµ±å‰µå»ºå¤±æ•—:', error);
          }
        }

        /**
         * å‰µå»ºSpriteç²’å­ç¾¤çµ„
         */
        createSpriteGroup(groupName, config) {
          try {
            const group = new THREE.Group();
            group.name = groupName;
            
            const sprites = [];
            
            for (let i = 0; i < config.count; i++) {
              // éš¨æ©Ÿé¸æ“‡ç²’å­é¡å‹
              const particleType = config.particleTypes[Math.floor(Math.random() * config.particleTypes.length)];
              const atlasInfo = this.particleAtlasMap.find(p => p.name === particleType);
              
              if (!atlasInfo) continue;
              
              // å‰µå»ºSpriteæè³ª
              const spriteMaterial = new THREE.SpriteMaterial({
                map: this.particleAtlasTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                alphaTest: 0.1
              });
              
              // è¨­å®šUVæ˜ å°„åˆ°Atlasçš„æ­£ç¢ºä½ç½®
              spriteMaterial.map.offset.set(atlasInfo.uvOffset.x, atlasInfo.uvOffset.y);
              spriteMaterial.map.repeat.set(atlasInfo.uvScale.x, atlasInfo.uvScale.y);
              
              const sprite = new THREE.Sprite(spriteMaterial);
              
              // è¨­å®šåˆå§‹ä½ç½®
              sprite.position.set(
                (Math.random() - 0.5) * config.area.width,
                (Math.random() - 0.5) * config.area.height,
                (Math.random() - 0.5) * config.area.depth
              );
              
              // è¨­å®šéš¨æ©Ÿå°ºå¯¸
              let size;
              if (config.randomSize) {
                size = config.randomSize.min + Math.random() * (config.randomSize.max - config.randomSize.min);
              } else {
                size = 0.5 + Math.random() * 1.5;
              }
              sprite.scale.setScalar(size);
              
              // å‰µå»ºæ‹–å°¾æ•ˆæœ
              let trailSprites = [];
              if (config.trail && config.trail.enabled) {
                for (let t = 0; t < config.trail.length; t++) {
                  const trailMaterial = new THREE.SpriteMaterial({
                    map: this.particleAtlasTexture,
                    transparent: true,
                    opacity: spriteMaterial.opacity * Math.pow(config.trail.fade, t + 1),
                    blending: THREE.AdditiveBlending,
                    alphaTest: 0.1
                  });
                  
                  trailMaterial.map.offset.set(atlasInfo.uvOffset.x, atlasInfo.uvOffset.y);
                  trailMaterial.map.repeat.set(atlasInfo.uvScale.x, atlasInfo.uvScale.y);
                  
                  const trailSprite = new THREE.Sprite(trailMaterial);
                  trailSprite.position.copy(sprite.position);
                  trailSprite.scale.setScalar(size * (1 - t * 0.1));
                  trailSprite.renderOrder = sprite.renderOrder - t - 1;
                  
                  group.add(trailSprite);
                  trailSprites.push(trailSprite);
                }
              }
              
              // ä¿å­˜å‹•ç•«æ•¸æ“š
              sprite.userData = {
                particleType: particleType,
                originalPosition: sprite.position.clone(),
                originalOpacity: spriteMaterial.opacity,
                originalScale: size,
                movement: config.movement,
                rhythm: {
                  frequency: config.rhythm.frequency + (Math.random() - 0.5) * 0.5,
                  amplitude: config.rhythm.amplitude + (Math.random() - 0.5) * 0.2,
                  phase: Math.random() * Math.PI * 2 + config.rhythm.phaseShift,
                  baseOpacity: spriteMaterial.opacity
                },
                velocity: new THREE.Vector3(
                  (Math.random() - 0.5) * 0.02,
                  (Math.random() - 0.5) * 0.02,
                  (Math.random() - 0.5) * 0.01
                ),
                orbitalAngle: Math.random() * Math.PI * 2,
                glitchTimer: Math.random() * 5,
                trailSprites: trailSprites, // æ‹–å°¾ç²¾éˆé™£åˆ—
                trailPositions: [], // ä½ç½®æ­·å²è¨˜éŒ„
                shapeVariation: config.shapeVariation || false,
                neonGlow: config.neonGlow || false
              };
              
              group.add(sprite);
              sprites.push(sprite);
            }
            
            // ä¿å­˜ç¾¤çµ„è³‡è¨Š
            const groupData = {
              name: groupName,
              group: group,
              sprites: sprites,
              config: config
            };
            
            this.spriteParticleGroups.push(groupData);
            
            if (this.scene) {
              this.scene.add(group);
              console.log(`Spriteç²’å­ç¾¤çµ„ "${groupName}" å·²æ·»åŠ åˆ°å ´æ™¯ï¼ŒåŒ…å«${sprites.length}å€‹ç²’å­`);
            }
            
          } catch (error) {
            console.error(`å‰µå»ºSpriteç²’å­ç¾¤çµ„ "${groupName}" å¤±æ•—:`, error);
          }
        }

        /**
         * å‰µå»ºæ•¸æ“šæµç²’å­æ•ˆæœ
         */
        createDataFlowParticles() {
          const particleCount = 100;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          const velocities = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // ä½ç½® - åˆ†å¸ƒåœ¨å±å¹•é‚Šç·£ï¼Œæ¨¡æ“¬æ•¸æ“šæµå…¥
            if (Math.random() < 0.5) {
              // æ°´å¹³æµå‹•
              positions[i3] = Math.random() < 0.5 ? -25 : 25;
              positions[i3 + 1] = (Math.random() - 0.5) * 20;
              velocities[i3] = Math.random() < 0.5 ? 0.1 : -0.1;
              velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
            } else {
              // å‚ç›´æµå‹•  
              positions[i3] = (Math.random() - 0.5) * 20;
              positions[i3 + 1] = Math.random() < 0.5 ? -15 : 15;
              velocities[i3] = (Math.random() - 0.5) * 0.02;
              velocities[i3 + 1] = Math.random() < 0.5 ? 0.08 : -0.08;
            }
            positions[i3 + 2] = (Math.random() - 0.5) * 5;
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
            
            // è³½åšé¾å…‹è‰²å½© - é’è‰²ç³»
            colors[i3] = 0.0;     // r
            colors[i3 + 1] = 1.0; // g
            colors[i3 + 2] = 1.0; // b
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
          
          const material = new THREE.PointsMaterial({
            size: 1.5, // å¾ 3 ç¸®å°è‡³ 1.5ï¼Œæ¸›å°‘å¤§æ–‘å¡Š
            vertexColors: true,
            transparent: true,
            opacity: 0.5, // é™ä½é€æ˜åº¦å¢å¼·ç´°è†©æ„Ÿ
            blending: THREE.AdditiveBlending
          });
          
          this.dataFlowParticles = new THREE.Points(geometry, material);
          this.dataFlowParticles.renderOrder = 2;
          
          if (this.scene) {
            this.scene.add(this.dataFlowParticles);
            console.log('æ•¸æ“šæµç²’å­å·²æ·»åŠ åˆ°å ´æ™¯');
          }
        }

        /**
         * å‰µå»ºèƒ½é‡ç²’å­æ•ˆæœ
         */
        createEnergyParticles() {
          const particleCount = 50;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // åœ“å½¢åˆ†å¸ƒåœ¨å•†æ¨™å‘¨åœ
            const angle = (i / particleCount) * Math.PI * 2;
            const radius = 10 + Math.random() * 5;
            positions[i3] = Math.cos(angle) * radius;
            positions[i3 + 1] = Math.sin(angle) * radius;
            positions[i3 + 2] = -15 + Math.random() * 2;
            
            // ç´«ç´…è‰²èƒ½é‡
            colors[i3] = 1.0;     // r
            colors[i3 + 1] = 0.0; // g  
            colors[i3 + 2] = 1.0; // b
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          
          const material = new THREE.PointsMaterial({
            size: 2.5, // å¾ 6 ç¸®å°è‡³ 2.5ï¼Œå¤§å¹…æ¸›å°‘æ–‘å¡Šå°ºå¯¸
            vertexColors: true,
            transparent: true,
            opacity: 0.5, // é™ä½é€æ˜åº¦é¿å…éæ–¼çªå‡º
            blending: THREE.AdditiveBlending
          });
          
          this.energyParticles = new THREE.Points(geometry, material);
          this.energyParticles.renderOrder = 3;
          
          if (this.scene) {
            this.scene.add(this.energyParticles);
            console.log('èƒ½é‡ç²’å­å·²æ·»åŠ åˆ°å ´æ™¯');
          }
        }

        /**
         * å‰µå»ºæ•…éšœé–ƒçˆç²’å­æ•ˆæœ
         */
        createGlitchParticles() {
          const particleCount = 30;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // éš¨æ©Ÿä½ç½®
            positions[i3] = (Math.random() - 0.5) * 30;
            positions[i3 + 1] = (Math.random() - 0.5) * 20;
            positions[i3 + 2] = (Math.random() - 0.5) * 8;
            
            // é»ƒè‰²æ•…éšœæ•ˆæœ
            colors[i3] = 1.0;     // r
            colors[i3 + 1] = 1.0; // g
            colors[i3 + 2] = 0.0; // b
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          
          const material = new THREE.PointsMaterial({
            size: 3.0, // å¾ 8 ç¸®å°è‡³ 3ï¼Œé¡¯è‘—æ¸›å°‘æ•…éšœç²’å­çš„æ–‘å¡Šæ„Ÿ
            vertexColors: true,
            transparent: true,
            opacity: 0.4, // é€²ä¸€æ­¥é™ä½é€æ˜åº¦
            blending: THREE.AdditiveBlending
          });
          
          this.glitchParticles = new THREE.Points(geometry, material);
          this.glitchParticles.renderOrder = 4;
          
          if (this.scene) {
            this.scene.add(this.glitchParticles);
            console.log('æ•…éšœç²’å­å·²æ·»åŠ åˆ°å ´æ™¯');
          }
        }

        /**
         * å‰µå»ºå¢å¼·æ›¿ä»£è¦–è¦ºç‰¹æ•ˆ - ç´°ç·»å…‰æšˆã€æƒå…‰æ¢å¸¶ã€æ¼¸å±¤æ•ˆæœ
         */
        createEnhancedVisualEffects() {
          if (!this.scene) return;
          
          try {
            // 1. å‰µå»ºç´°ç·»æ¼¸å±¤å…‰æšˆç³»çµ±
            this.createGradientHaloSystem();
            
            // 2. å‰µå»ºå‹•æ…‹æƒå…‰æ¢å¸¶
            this.createScanLightStrips();
            
            // 3. å‰µå»ºç’°å¢ƒå…‰å±¤
            this.createAmbientLightLayers();
            
            console.log('å¢å¼·è¦–è¦ºç‰¹æ•ˆç³»çµ±å·²å‰µå»º');
          } catch (error) {
            console.warn('å¢å¼·è¦–è¦ºç‰¹æ•ˆå‰µå»ºå¤±æ•—:', error);
          }
        }

        /**
         * å‰µå»ºæ¼¸å±¤å…‰æšˆç³»çµ±
         */
        createGradientHaloSystem() {
          this.gradientHalos = [];
          
          const haloConfigs = [
            { radius: 12, intensity: 0.20, color: 0x00cccc, pulse: 1.2 }, // å¢å¼·å…§å±¤å…‰æšˆ
            { radius: 18, intensity: 0.15, color: 0x0099cc, pulse: 1.0 }, // å¢å¼·ä¸­å±¤å…‰æšˆ
            { radius: 25, intensity: 0.10, color: 0x0066cc, pulse: 0.8 }, // å¢å¼·å¤–å±¤å…‰æšˆ
            { radius: 35, intensity: 0.06, color: 0x004488, pulse: 0.6 }  // æ–°å¢é æ™¯å…‰æšˆ
          ];
          
          haloConfigs.forEach((config, index) => {
            const haloGeometry = new THREE.RingGeometry(config.radius, config.radius + 3, 64);
            const haloMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                intensity: { value: config.intensity },
                color: { value: new THREE.Color(config.color) },
                pulseSpeed: { value: config.pulse }
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float intensity;
                uniform vec3 color;
                uniform float pulseSpeed;
                varying vec2 vUv;
                
                void main() {
                  vec2 center = vec2(0.5, 0.5);
                  float dist = distance(vUv, center);
                  
                  // å‰µå»ºå¤šå±¤æ¬¡æŸ”å’Œæ¼¸å±¤
                  float innerGradient = 1.0 - smoothstep(0.0, 0.2, dist);
                  innerGradient = pow(innerGradient, 4.0);
                  
                  float midGradient = 1.0 - smoothstep(0.1, 0.4, dist);
                  midGradient = pow(midGradient, 2.5) * 0.6;
                  
                  float outerGradient = 1.0 - smoothstep(0.2, 0.5, dist);
                  outerGradient = pow(outerGradient, 1.5) * 0.3;
                  
                  // çµ„åˆæ¼¸å±¤æ•ˆæœ
                  float combinedGradient = innerGradient + midGradient + outerGradient;
                  
                  // å¢å¼·è„ˆå‹•æ•ˆæœ
                  float pulse = sin(time * pulseSpeed) * 0.25 + 0.75;
                  float microPulse = sin(time * pulseSpeed * 3.0) * 0.1 + 0.9;
                  
                  // å‹•æ…‹è‰²å½©è®ŠåŒ–
                  vec3 dynamicColor = color;
                  float colorShift = sin(time * 0.5) * 0.1;
                  dynamicColor.rgb += vec3(colorShift * 0.5, colorShift, colorShift * 0.3);
                  
                  // æœ€çµ‚é€æ˜åº¦èˆ‡è‰²å½©
                  float alpha = combinedGradient * intensity * pulse * microPulse;
                  
                  gl_FragColor = vec4(dynamicColor, alpha);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              side: THREE.DoubleSide
            });
            
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 0, -30 - index * 0.5);
            halo.renderOrder = -20 - index;
            
            this.gradientHalos.push(halo);
            this.scene.add(halo);
          });
        }

        /**
         * å‰µå»ºå‹•æ…‹æƒå…‰æ¢å¸¶
         */
        createScanLightStrips() {
          this.scanStrips = [];
          
          // å¢å¼·æƒå…‰æ¢å¸¶ç³»çµ± - æ›¿ä»£ç²’å­æ•ˆæœ
          for (let i = 0; i < 5; i++) { // å¢åŠ æ•¸é‡
            const stripGeometry = new THREE.PlaneGeometry(60, 0.8); // ç¨å¾®æ”¾å¤§ä»¥è£œå„Ÿç²’å­ç§»é™¤
            const stripMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                speed: { value: 0.3 + i * 0.15 }, // å¤šæ¨£åŒ–é€Ÿåº¦
                intensity: { value: 0.25 - i * 0.04 }, // å¢å¼·å¼·åº¦
                color: { value: new THREE.Color(i % 2 === 0 ? 0x00cccc : 0x0099cc) } // äº¤æ›¿è‰²å½©
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float speed;
                uniform float intensity;
                uniform vec3 color;
                varying vec2 vUv;
                
                void main() {
                  // å‰µå»ºç§»å‹•æƒå…‰æ•ˆæœ
                  float scan = sin((vUv.x + time * speed) * 3.14159 * 4.0);
                  scan = pow(max(0.0, scan), 2.0);
                  
                  // é‚Šç·£æ¼¸è®Š
                  float edgeFade = 1.0 - abs(vUv.x - 0.5) * 2.0;
                  edgeFade = pow(edgeFade, 2.0);
                  
                  float alpha = scan * intensity * edgeFade;
                  gl_FragColor = vec4(color, alpha);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              side: THREE.DoubleSide
            });
            
            const strip = new THREE.Mesh(stripGeometry, stripMaterial);
            // æ›´å¥½çš„åˆ†ä½ˆå®šä½
            strip.position.set(0, 12 - i * 6, -30 - i * 2); // æ›´åˆ†æ•£çš„å‚ç›´åˆ†ä½ˆ
            strip.renderOrder = -20 - i;
            
            this.scanStrips.push(strip);
            this.scene.add(strip);
          }
        }

        /**
         * å‰µå»ºç’°å¢ƒå…‰å±¤
         */
        createAmbientLightLayers() {
          this.ambientLayers = [];
          
          const layerConfigs = [
            { size: 70, opacity: 0.08, color: 0x003333, z: -35 }, // å¢å¼·è¿‘æ™¯ç’°å¢ƒå…‰
            { size: 90, opacity: 0.06, color: 0x004444, z: -40 }, // å¢å¼·ä¸­æ™¯ç’°å¢ƒå…‰
            { size: 110, opacity: 0.04, color: 0x002244, z: -45 }, // å¢å¼·é æ™¯ç’°å¢ƒå…‰
            { size: 130, opacity: 0.03, color: 0x001122, z: -50 }, // æ–°å¢æœ€é èƒŒæ™¯
            { size: 150, opacity: 0.02, color: 0x000033, z: -55 }  // æ·±é èƒŒæ™¯å±¤
          ];
          
          layerConfigs.forEach((config, index) => {
            const layerGeometry = new THREE.PlaneGeometry(config.size, config.size);
            const layerMaterial = new THREE.MeshBasicMaterial({
              color: config.color,
              transparent: true,
              opacity: config.opacity,
              blending: THREE.AdditiveBlending
            });
            
            const layer = new THREE.Mesh(layerGeometry, layerMaterial);
            layer.position.set(0, 0, config.z);
            layer.renderOrder = -30 - index;
            
            this.ambientLayers.push(layer);
            this.scene.add(layer);
          });
        }

        /**
         * ç¢ºä¿è³½åšé¾å…‹ä¸»é¡Œä¸€è‡´æ€§èˆ‡è¦–è¦ºå¹³è¡¡
         */
        ensureCyberpunkThemeConsistency() {
          const themeColors = this.getCurrentThemeColors();
          
          // å®šç¾©ç°¡ç´„é¢¨æ ¼çš„è¦–è¦ºå¹³è¡¡æ¯”ä¾‹
          const backgroundIntensityMultiplier = 1.0; // ç„¡ç²’å­æ™‚ä¿æŒèƒŒæ™¯å¼·åº¦
          const focusEnhancement = 1.5; // æ›´å¼·çš„å‰æ™¯å¢å¼·ä»¥çªå‡ºå¡ç‰‡
          
          // 1. èª¿æ•´æ¼¸å±¤å…‰æšˆ - èƒŒæ™¯å±¤ç´š
          if (this.gradientHalos) {
            this.gradientHalos.forEach((halo, index) => {
              if (halo.material.uniforms) {
                const themeIntensity = this.currentTheme === 'dark' ? 0.8 : 0.5;
                const depthFactor = 1.0 - (index * 0.2); // è·é›¢è¶Šé å¼·åº¦è¶Šä½
                halo.material.uniforms.intensity.value = 
                  halo.material.uniforms.intensity.value * themeIntensity * backgroundIntensityMultiplier * depthFactor;
              }
            });
          }
          
          // 2. èª¿æ•´æƒå…‰æ¢å¸¶ - èƒŒæ™¯ç‰¹æ•ˆ
          if (this.scanStrips) {
            this.scanStrips.forEach((strip, index) => {
              if (strip.material.uniforms) {
                const baseIntensity = this.currentTheme === 'dark' ? 0.12 : 0.08;
                const layerFactor = 1.0 - (index * 0.15);
                strip.material.uniforms.intensity.value = baseIntensity * backgroundIntensityMultiplier * layerFactor;
              }
            });
          }
          
          // 3. èª¿æ•´ç’°å¢ƒå…‰å±¤ - æœ€é èƒŒæ™¯
          if (this.ambientLayers) {
            this.ambientLayers.forEach((layer, index) => {
              const baseOpacity = this.currentTheme === 'dark' ? 0.04 : 0.025;
              const distanceFactor = 1.0 - (index * 0.3);
              layer.material.opacity = baseOpacity * backgroundIntensityMultiplier * distanceFactor;
            });
          }
          
          // 4. èª¿æ•´ç²’å­ç³»çµ±æ•´é«”å¼·åº¦ - åˆ†å±¤è™•ç†
          if (this.spriteParticleGroups) {
            this.spriteParticleGroups.forEach((groupData, groupIndex) => {
              const groupType = groupData.name;
              let intensityFactor = backgroundIntensityMultiplier;
              
              // æ ¹æ“šç²’å­ç¾¤çµ„é¡å‹èª¿æ•´
              switch(groupType) {
                case 'glitch':
                  intensityFactor *= 0.7; // æ•…éšœç²’å­æ›´åŠ å¾®å¦™
                  break;
                case 'backgroundAmbient':
                  intensityFactor *= 0.5; // èƒŒæ™¯ç²’å­æœ€ä½
                  break;
                case 'energyRing':
                  intensityFactor *= 0.8; // èƒ½é‡ç’°ä¸­ç­‰
                  break;
                default:
                  intensityFactor *= 0.75; // å…¶ä»–ç²’å­é©ä¸­
              }
              
              groupData.sprites.forEach(sprite => {
                if (sprite.userData.rhythm) {
                  sprite.userData.rhythm.baseOpacity *= intensityFactor;
                  sprite.userData.originalScale *= (intensityFactor + 0.2); // å°ºå¯¸ç¨å¾®æº«å’Œèª¿æ•´
                }
              });
            });
          }
          
          // 5. èª¿æ•´Logoå…‰æšˆæ•ˆæœ - ä¸­æ™¯å…ƒç´ 
          if (this.logoEnhancedGlows) {
            this.logoEnhancedGlows.forEach((glow, index) => {
              if (glow.userData) {
                const logoFactor = 0.7; // Logoæ•ˆæœé©åº¦é™ä½
                if (glow.material.uniforms) {
                  glow.userData.originalOpacity *= logoFactor;
                } else {
                  glow.userData.originalOpacity *= logoFactor;
                }
              }
            });
          }
          
          // 6. èª¿æ•´éœ“è™¹å…‰ç’° - ä¸­æ™¯è£é£¾
          if (this.neonRings) {
            this.neonRings.forEach((ring, index) => {
              const neonFactor = 0.6;
              ring.material.opacity *= neonFactor;
            });
          }
          
          console.log('ç°¡ç´„è³½åšé¾å…‹é¢¨æ ¼èª¿æ•´å®Œæˆ (ç„¡ç²’å­ç³»çµ±)');
          console.log('èƒŒæ™¯å¼·åº¦å€æ•¸:', backgroundIntensityMultiplier);
          console.log('å‰æ™¯å¢å¼·å€æ•¸:', focusEnhancement);
        }

        /**
         * æ›´æ–°å¢å¼·è¦–è¦ºç‰¹æ•ˆ
         */
        updateEnhancedVisualEffects(time) {
          // æ›´æ–°æ¼¸å±¤å…‰æšˆ
          if (this.gradientHalos) {
            this.gradientHalos.forEach((halo, index) => {
              if (halo.material.uniforms) {
                halo.material.uniforms.time.value = time;
                halo.rotation.z = time * 0.1 * (1 + index * 0.5);
              }
            });
          }
          
          // æ›´æ–°æƒå…‰æ¢å¸¶
          if (this.scanStrips) {
            this.scanStrips.forEach((strip, index) => {
              if (strip.material.uniforms) {
                strip.material.uniforms.time.value = time;
              }
            });
          }
          
          // æ›´æ–°ç’°å¢ƒå…‰å±¤
          if (this.ambientLayers) {
            this.ambientLayers.forEach((layer, index) => {
              layer.rotation.z = time * 0.05 * (1 - index * 0.2);
            });
          }
        }

        /**
         * æ›´æ–°è³½åšé¾å…‹å‹•ç•«æ•ˆæœ - å‡ç´šç‰ˆæœ¬
         */
        updateParticles() {
          const time = Date.now() * 0.001;
          
          // æ€§èƒ½å„ªåŒ–ï¼šé™ä½æ›´æ–°é »ç‡
          if (!this.lastUpdateTime) this.lastUpdateTime = 0;
          const deltaTime = time - this.lastUpdateTime;
          
          // æ¯ç§’30å¹€æ›´æ–°ï¼Œè€Œé60å¹€ï¼Œç¯€çœæ€§èƒ½
          if (deltaTime < 0.033) return;
          this.lastUpdateTime = time;
          
          // æ›´æ–°é€²éšSpriteç²’å­ç³»çµ±
          if (this.spriteParticleGroups && this.spriteParticleGroups.length > 0) {
            this.updateAdvancedSpriteParticles(time, deltaTime);
          }
          
          // æ›´æ–°æ•¸æ“šæµç²’å­ï¼ˆè¼ƒä½é »ç‡ï¼‰
          if (this.dataFlowParticles && time % 0.1 < 0.033) {
            this.updateDataFlowParticles(time);
          }
          
          // æ›´æ–°èƒ½é‡ç²’å­
          if (this.energyParticles) {
            this.updateEnergyParticles(time);
          }
          
          // æ›´æ–°æ•…éšœç²’å­ï¼ˆä½é »ç‡ï¼Œç¯€çœæ€§èƒ½ï¼‰
          if (this.glitchParticles && time % 0.2 < 0.033) {
            this.updateGlitchParticles(time);
          }
          
          // æ›´æ–°å¢å¼·è¦–è¦ºç‰¹æ•ˆç³»çµ±
          this.updateEnhancedVisualEffects(time);
          
          // æ›´æ–°éœ“è™¹å…‰ç’°
          if (this.neonRings && this.neonRings.length > 0) {
            this.updateNeonRings(time);
          }
          
          // æ›´æ–°å•†æ¨™å‹•ç•«
          if (this.logoPlane) {
            this.updateLogoAnimation(time);
          }
          
          // æ›´æ–°ç„¡éšœç¤™å¡ç‰‡å‹•æ…‹ç‰¹æ•ˆè¼”åŠ©è¾¨è­˜
          if (this.cards && this.cards.length > 0) {
            this.updateAccessibilityCardEffects(time, deltaTime);
          }
          
          // æ›´æ–°è‡ªè¨‚ Shader Material çš„ uniforms
          this.updateShaderMaterials(time);
          
          // æ›´æ–°é¼ æ¨™äº’å‹•æ•ˆæœ
          this.updateMouseEffects(time);
        }

        /**
         * æ›´æ–°è‡ªè¨‚ Shader Material çš„ uniforms
         */
        updateShaderMaterials(time) {
          if (!this.cards || this.cards.length === 0) return;
          
          this.cards.forEach(card => {
            if (!card.userData.effects) return;
            
            const effects = card.userData.effects;
            
            // æ›´æ–°éœ“è™¹å…‰æšˆ shader uniforms
            if (effects.aura && effects.aura.material.uniforms) {
              effects.aura.material.uniforms.time.value = time;
            }
            
            // æ›´æ–°æƒå…‰æ¢å¸¶ shader uniforms
            if (effects.scanLine && effects.scanLine.material.uniforms) {
              effects.scanLine.material.uniforms.time.value = time;
            }
          });
        }

        /**
         * æ›´æ–°ç„¡éšœç¤™å¡ç‰‡å‹•æ…‹ç‰¹æ•ˆè¼”åŠ©è¾¨è­˜
         */
        updateAccessibilityCardEffects(time, deltaTime) {
          if (!this.cards || this.cards.length === 0) return;
          
          const colors = this.getCurrentThemeColors();
          const cardColors = colors.accessibleCard;
          
          this.cards.forEach((card, index) => {
            if (!card.userData.effects) return;
            
            const effects = card.userData.effects;
            const isFlipped = card.userData.isFlipped;
            const isClickable = card.userData.clickable;
            
            // ä½¿ç”¨å¡ç‰‡å„²å­˜çš„å‹•æ…‹åƒæ•¸
            const scaleFactor = card.userData.scaleFactor || 1.0;
            const glowIntensity = card.userData.glowIntensity || 1.0;
            const focusEnhancement = card.userData.focusEnhancement || {};
            
            // 1. é‚Šç·£ç™¼å…‰è„ˆå‹•æ•ˆæœ - å‹•æ…‹å¼·åº¦å¢å¼·è¾¨è­˜åº¦
            if (effects.edgeGlowLayers) {
              // ä½¿ç”¨å‹•æ…‹è„ˆå‹•é »ç‡
              const pulsePeriod = focusEnhancement.pulseFrequency || (2.0 + (index * 0.3));
              const basePulseIntensity = Math.sin(time * pulsePeriod) * 0.3 + 0.7;
              const enhancedPulseIntensity = basePulseIntensity * glowIntensity;
              
              effects.edgeGlowLayers.forEach((layer, layerIndex) => {
                if (!layer.material) return;
                
                // å¤šå±¤å…‰æšˆå…·æœ‰ä¸åŒå¼·åº¦ï¼Œå— scaleFactor å½±éŸ¿
                const layerIntensity = enhancedPulseIntensity * (1 - layerIndex * 0.1) * Math.min(1.5, scaleFactor);
                layer.material.opacity = Math.max(0.2, layerIntensity);
                
                // å¯é»æ“Šæ™‚æ ¹æ“šäº’å‹•å¼·åŒ–ä¿‚æ•¸åŠ å¼·ç™¼å…‰
                if (isClickable) {
                  const interactionBoost = focusEnhancement.interactionBoost || 1.0;
                  layer.material.opacity *= (1.3 + interactionBoost * 0.3);
                }
                
                // å°‘é‡å¡ç‰‡æ™‚é¡å¤–å¢å¼·é‚Šç·£å…‰æšˆ
                if (scaleFactor > 1.3) {
                  layer.material.opacity *= 1.2;
                }
              });
            }
            
            // 2. å¡ç‰‡æ•´é«”äº®åº¦èª¿ç¯€ - æå‡å°æ¯”åº¦
            if (isFlipped) {
              // ç¿»è½‰å¾Œçš„å¡ç‰‡ï¼šé€±æœŸæ€§äº®åº¦è®ŠåŒ–
              const brightnessCycle = Math.sin(time * 1.5 + index * 0.5) * 0.15 + 1.0;
              
              // èª¿æ•´æ­£é¢æè³ªäº®åº¦
              if (card.userData.frontMaterial) {
                const frontColor = card.userData.frontMaterial.color;
                const baseColor = new THREE.Color(cardColors.frontColor);
                frontColor.copy(baseColor.multiplyScalar(brightnessCycle));
              }
            } else {
              // èƒŒé¢å¡ç‰‡ï¼šç©©å®šé«˜å°æ¯”åº¦
              if (card.userData.backMaterial) {
                const backColor = card.userData.backMaterial.color;
                const baseColor = new THREE.Color(cardColors.backBackground);
                backColor.copy(baseColor);
              }
            }
            
            // 3. é™°å½±å‹•æ…‹èª¿æ•´ - å¢å¼·ç«‹é«”æ„Ÿ
            if (effects.shadowLayers) {
              const shadowIntensity = Math.sin(time * 0.8 + index * 0.3) * 0.2 + 0.8;
              
              effects.shadowLayers.forEach((shadow, shadowIndex) => {
                if (!shadow.material) return;
                
                const baseShadowOpacity = shadowIndex === 0 ? 
                  cardColors.shadowIntensity : 
                  cardColors.shadowIntensity * 0.4;
                
                shadow.material.opacity = baseShadowOpacity * shadowIntensity;
                
                // è¼•å¾®é™°å½±ä½ç§»å¢å¼·å‹•æ…‹æ„Ÿ
                const offsetX = Math.sin(time * 0.5 + index * 0.4) * 0.05;
                const offsetY = Math.cos(time * 0.6 + index * 0.4) * 0.05;
                shadow.position.x = 0.15 + offsetX;
                shadow.position.y = -0.15 + offsetY;
              });
            }
            
            // 4. ç‰¹æ®Šé–ƒçˆæç¤º - å¯é»æ“Šç‹€æ…‹æŒ‡ç¤º
            if (isClickable) {
              const flashFrequency = 2.5; // æ¯ç§’2.5æ¬¡é–ƒçˆ
              const flashIntensity = Math.sin(time * flashFrequency * Math.PI * 2) * 0.5 + 0.5;
              
              // å‰æ™¯å…‰æšˆé–ƒçˆ
              if (effects.frontGlow) {
                effects.frontGlow.material.opacity = 0.3 + flashIntensity * 0.4;
              }
              
              // èƒŒæ™¯é®ç½©é–ƒçˆ
              if (effects.backMask) {
                effects.backMask.material.opacity = 0.6 + flashIntensity * 0.2;
              }
            }
            
            // 5. é¡è‰²æº«åº¦èª¿ç¯€ - æ ¹æ“šä¸»é¡Œå„ªåŒ–
            const isDarkTheme = this.currentTheme === 'dark';
            if (isDarkTheme) {
              // æ·±è‰²ä¸»é¡Œï¼šåå†·è‰²èª¿å¢å¼·å°æ¯”
              if (effects.edgeGlowLayers) {
                effects.edgeGlowLayers.forEach(layer => {
                  if (layer.material && layer.material.color) {
                    const coolTint = new THREE.Color(cardColors.primaryBorder);
                    layer.material.color.lerp(coolTint, 0.1);
                  }
                });
              }
            } else {
              // æ·ºè‰²ä¸»é¡Œï¼šåæš–è‰²èª¿ä¿æŒèˆ’é©
              if (effects.edgeGlowLayers) {
                effects.edgeGlowLayers.forEach(layer => {
                  if (layer.material && layer.material.color) {
                    const warmTint = new THREE.Color(cardColors.glowColor);
                    layer.material.color.lerp(warmTint, 0.1);
                  }
                });
              }
            }
            
            // 6. äº’å‹•é«”é©—æå‡ - å°‘é‡å¡ç‰‡æ™‚çš„æµ®å‹•å‹•ç•«
            if (scaleFactor > 1.3) { // å°‘é‡å¡ç‰‡æ‰å•Ÿç”¨æµ®å‹•æ•ˆæœ
              // è¼•å¾®çš„æµ®å‹•å‹•ç•«ï¼Œå¢åŠ ç”Ÿå‹•æ„Ÿ
              const floatFrequency = 0.8 + index * 0.1; // æ¯å¼µå¡ç‰‡ä¸åŒé »ç‡
              const floatAmplitude = 0.05 * scaleFactor; // æŒ¯å¹…éš¨å¤§å°èª¿æ•´
              
              const floatOffset = Math.sin(time * floatFrequency) * floatAmplitude;
              const originalY = card.userData.targetPosition ? card.userData.targetPosition.y : 0;
              
              // åªåœ¨å¡ç‰‡å·²ç©©å®šè½åœ°å¾Œæ‰æ‡‰ç”¨æµ®å‹•
              if (card.userData.settled) {
                card.position.y = originalY + floatOffset;
                
                // è¼•å¾®çš„æ—‹è½‰å‹•ç•«
                const rotationAmplitude = 0.02; // ç´„1åº¦
                const rotationOffset = Math.sin(time * floatFrequency * 0.7 + index) * rotationAmplitude;
                card.rotation.z = rotationOffset;
              }
              
              // å¯é»æ“Šç‹€æ…‹ä¸‹çš„é¡å¤–hoveræ•ˆæœ
              if (isClickable) {
                // æ¨¡æ“¬hoveræ•ˆæœçš„è¼•å¾®æ”¾å¤§
                const hoverScale = 1 + Math.sin(time * 3) * 0.02; // 2%çš„ç¸®æ”¾è®ŠåŒ–
                const currentScale = card.scale.x; // ç²å–ç•¶å‰ç¸®æ”¾
                card.scale.setScalar(currentScale * hoverScale);
              }
            }
            
            // 7. é»æ“Šåé¥‹å‹•ç•«æº–å‚™ï¼ˆç‚ºå°‡ä¾†çš„é»æ“Šäº‹ä»¶åšæº–å‚™ï¼‰
            if (!card.userData.animationState) {
              card.userData.animationState = {
                isHovered: false,
                clickAnimation: false,
                lastClickTime: 0
              };
            }
          });
        }

        /**
         * æ›´æ–°é€²éšSpriteç²’å­ç³»çµ± - ç¯€å¥åŒ–é–ƒçˆ
         */
        updateAdvancedSpriteParticles(time, deltaTime) {
          if (!this.spriteParticleGroups) return;
          
          // å¦‚æœæ²’æœ‰å‚³å…¥deltaTimeï¼Œå‰‡è¨ˆç®—å®ƒ
          if (deltaTime === undefined) {
            if (!this.lastSpriteUpdateTime) this.lastSpriteUpdateTime = time;
            deltaTime = time - this.lastSpriteUpdateTime;
            this.lastSpriteUpdateTime = time;
          }
          
          this.spriteParticleGroups.forEach(groupData => {
            groupData.sprites.forEach(sprite => {
              const userData = sprite.userData;
              const rhythm = userData.rhythm;
              
              // è¨˜éŒ„ç•¶å‰ä½ç½®ç”¨æ–¼æ‹–å°¾æ•ˆæœ
              if (userData.trailSprites && userData.trailSprites.length > 0) {
                userData.trailPositions.unshift(sprite.position.clone());
                if (userData.trailPositions.length > userData.trailSprites.length) {
                  userData.trailPositions.pop();
                }
              }
              
              // 1. å¢å¼·ç¯€å¥åŒ–é€æ˜åº¦é–ƒçˆ - æ·»åŠ å¾®å°é–ƒçˆæ•ˆæœ
              const baseRhythmOpacity = rhythm.baseOpacity + 
                Math.sin(time * rhythm.frequency + rhythm.phase) * rhythm.amplitude;
              
              // æ·»åŠ é«˜é »å¾®é–ƒçˆæ•ˆæœ
              const microFlicker = Math.sin(time * 15 + userData.rhythm.phase * 3) * 0.05;
              const subtleFlicker = Math.sin(time * 8 + userData.rhythm.phase * 2) * 0.08;
              
              // çµ„åˆæ‰€æœ‰é–ƒçˆæ•ˆæœ
              const finalOpacity = baseRhythmOpacity + microFlicker + subtleFlicker;
              sprite.material.opacity = Math.max(0.05, Math.min(0.9, finalOpacity));
              
              // 2. å¢å¼·ç¯€å¥åŒ–å°ºå¯¸è®ŠåŒ– - æ·»åŠ ç´°å¾®æµ®å‹•
              const baseRhythmScale = userData.originalScale + 
                Math.sin(time * rhythm.frequency * 0.7 + rhythm.phase) * userData.originalScale * 0.2;
              
              // æ·»åŠ ç·©æ…¢æµ®å‹•æ•ˆæœ
              const slowFloat = Math.sin(time * 0.5 + userData.rhythm.phase) * userData.originalScale * 0.1;
              const microPulse = Math.sin(time * 12 + userData.rhythm.phase * 4) * userData.originalScale * 0.03;
              
              // çµ„åˆæ‰€æœ‰å°ºå¯¸è®ŠåŒ–
              const finalScale = baseRhythmScale + slowFloat + microPulse;
              sprite.scale.setScalar(Math.max(0.1, Math.min(2.0, finalScale)));
              
              // 2.5. éœ“è™¹å…‰æšˆæ•ˆæœ
              if (userData.neonGlow) {
                const glowPulse = Math.sin(time * 3 + rhythm.phase) * 0.3 + 0.7;
                sprite.material.opacity *= glowPulse;
              }
              
              // 3. å…¨åŸŸç´°å¾®ä½ç½®æµ®å‹•æ•ˆæœ
              const globalFloatX = Math.sin(time * 0.3 + userData.rhythm.phase) * 0.08;
              const globalFloatY = Math.cos(time * 0.25 + userData.rhythm.phase * 1.5) * 0.06;
              const microTremor = {
                x: Math.sin(time * 18 + userData.rhythm.phase * 5) * 0.02,
                y: Math.cos(time * 20 + userData.rhythm.phase * 6) * 0.015
              };
              
              // 4. æ ¹æ“šé‹å‹•é¡å‹æ›´æ–°ä½ç½®
              switch (userData.movement.type) {
                case 'flow':
                  // æ•¸æ“šæµï¼šç·šæ€§ç§»å‹• + ç´°å¾®æµ®å‹•
                  sprite.position.add(userData.velocity);
                  sprite.position.x += globalFloatX + microTremor.x;
                  sprite.position.y += globalFloatY + microTremor.y;
                  
                  // é‚Šç•Œé‡ç½®
                  if (Math.abs(sprite.position.x) > 30) {
                    sprite.position.x = -Math.sign(sprite.position.x) * 30;
                  }
                  if (Math.abs(sprite.position.y) > 20) {
                    sprite.position.y = -Math.sign(sprite.position.y) * 20;
                  }
                  break;
                  
                case 'orbital':
                  // è»Œé“é‹å‹•ï¼šåœ“å½¢è·¯å¾‘ + ç´°å¾®éœ‡é¡«
                  userData.orbitalAngle += userData.movement.speed;
                  const radius = userData.movement.radius + Math.sin(time + userData.rhythm.phase) * 1.5;
                  sprite.position.x = Math.cos(userData.orbitalAngle) * radius + globalFloatX + microTremor.x;
                  sprite.position.y = Math.sin(userData.orbitalAngle) * radius + globalFloatY + microTremor.y;
                  sprite.position.z = userData.originalPosition.z + Math.sin(time * 0.5 + userData.rhythm.phase) * 1.5;
                  break;
                  
                case 'random':
                  // æ•…éšœéš¨æ©Ÿç§»å‹•
                  userData.glitchTimer -= deltaTime;
                  if (userData.glitchTimer <= 0) {
                    // éš¨æ©Ÿç¬ç§»
                    sprite.position.x += (Math.random() - 0.5) * 4;
                    sprite.position.y += (Math.random() - 0.5) * 4;
                    sprite.position.z += (Math.random() - 0.5) * 1;
                    userData.glitchTimer = 0.5 + Math.random() * 2;
                    
                    // é‡ç½®åˆ°é‚Šç•Œå…§
                    sprite.position.x = Math.max(-25, Math.min(25, sprite.position.x));
                    sprite.position.y = Math.max(-15, Math.min(15, sprite.position.y));
                  }
                  break;
                  
                case 'drift':
                  // ç·©æ…¢æ¼‚ç§»
                  sprite.position.add(userData.velocity);
                  sprite.position.x += Math.sin(time * 0.3 + userData.rhythm.phase) * 0.01;
                  sprite.position.y += Math.cos(time * 0.25 + userData.rhythm.phase) * 0.008;
                  
                  // é‚Šç•Œå¾ªç’°
                  if (Math.abs(sprite.position.x) > 45) {
                    sprite.position.x = -Math.sign(sprite.position.x) * 45;
                  }
                  if (Math.abs(sprite.position.y) > 30) {
                    sprite.position.y = -Math.sign(sprite.position.y) * 30;
                  }
                  break;
                  
                case 'wave':
                  // æ³¢æµªé‹å‹• - éœ“è™¹æ‹–å°¾å°ˆç”¨
                  const waveAmplitude = userData.movement.amplitude || 3;
                  const waveFrequency = userData.movement.frequency || 0.5;
                  
                  // åŸºç¤ç§»å‹•
                  sprite.position.add(userData.velocity);
                  
                  // æ³¢æµªæ•ˆæœ
                  const waveOffset = Math.sin(time * waveFrequency + userData.rhythm.phase) * waveAmplitude;
                  sprite.position.y = userData.originalPosition.y + waveOffset;
                  
                  // Zè»¸èºæ—‹é‹å‹•
                  sprite.position.z = userData.originalPosition.z + Math.sin(time * 0.8 + userData.rhythm.phase) * 1.5;
                  
                  // é‚Šç•Œé‡ç½®
                  if (Math.abs(sprite.position.x) > 35) {
                    sprite.position.x = -Math.sign(sprite.position.x) * 35;
                    userData.originalPosition.y = sprite.position.y; // æ›´æ–°åŸºæº–Yä½ç½®
                  }
                  break;
              }
              
              // 4. ç‰¹æ®Šæ•ˆæœï¼šé¡è‰²è„ˆå‹•ï¼ˆæ”¹è®Šspriteçš„æè³ªè‰²èª¿ï¼‰
              if (userData.particleType === 'star' || userData.particleType === 'hexagon') {
                // å°ç‰¹å®šé¡å‹ç²’å­æ·»åŠ è‰²å½©è®Šæ›
                const colorPhase = time * 2 + userData.rhythm.phase;
                const hue = (Math.sin(colorPhase) + 1) * 0.5; // 0-1ç¯„åœ
                // é€™è£¡å¯ä»¥é€šéä¿®æ”¹æè³ªä¾†å¯¦ç¾è‰²å½©è®ŠåŒ–ï¼Œä½†éœ€è¦è¤‡è£½æè³ªé¿å…å½±éŸ¿å…¶ä»–ç²’å­
              }
              
              // 5. æ›´æ–°æ‹–å°¾æ•ˆæœ
              if (userData.trailSprites && userData.trailSprites.length > 0 && userData.trailPositions.length > 0) {
                userData.trailSprites.forEach((trailSprite, trailIndex) => {
                  if (userData.trailPositions[trailIndex]) {
                    // ä½¿ç”¨æ­·å²ä½ç½®æ›´æ–°æ‹–å°¾
                    trailSprite.position.copy(userData.trailPositions[trailIndex]);
                    
                    // æ‹–å°¾é€æ˜åº¦éš¨è·é›¢è¡°æ¸›
                    const fadeMultiplier = Math.pow(groupData.config.trail.fade, trailIndex + 1);
                    trailSprite.material.opacity = sprite.material.opacity * fadeMultiplier;
                    
                    // æ‹–å°¾å°ºå¯¸è¡°æ¸›
                    const scaleMultiplier = 1 - (trailIndex * 0.1);
                    trailSprite.scale.setScalar(sprite.scale.x * scaleMultiplier);
                  }
                });
              }
              
              // 6. å½¢ç‹€è®ŠåŒ–æ•ˆæœ
              if (userData.shapeVariation && Math.random() < 0.01) { // 1%æ©Ÿç‡è®ŠåŒ–
                // éš¨æ©Ÿåˆ‡æ›åˆ°ç¾¤çµ„ä¸­çš„å…¶ä»–ç²’å­é¡å‹
                const newType = groupData.config.particleTypes[Math.floor(Math.random() * groupData.config.particleTypes.length)];
                const newAtlasInfo = this.particleAtlasMap.find(p => p.name === newType);
                if (newAtlasInfo && newType !== userData.particleType) {
                  sprite.material.map.offset.set(newAtlasInfo.uvOffset.x, newAtlasInfo.uvOffset.y);
                  sprite.material.map.repeat.set(newAtlasInfo.uvScale.x, newAtlasInfo.uvScale.y);
                  userData.particleType = newType;
                }
              }
            });
          });
        }

        /**
         * æ›´æ–°æ•¸æ“šæµç²’å­å‹•ç•«
         */
        updateDataFlowParticles(time) {
          const positions = this.dataFlowParticles.geometry.attributes.position.array;
          const velocities = this.dataFlowParticles.geometry.attributes.velocity.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            // æ ¹æ“šé€Ÿåº¦ç§»å‹•ç²’å­
            positions[i] += velocities[i];
            positions[i + 1] += velocities[i + 1];
            positions[i + 2] += velocities[i + 2];
            
            // é‚Šç•Œé‡ç½® - å‰µå»ºå¾ªç’°æ•ˆæœ
            if (Math.abs(positions[i]) > 25) {
              positions[i] = -Math.sign(positions[i]) * 25;
            }
            if (Math.abs(positions[i + 1]) > 15) {
              positions[i + 1] = -Math.sign(positions[i + 1]) * 15;
            }
          }
          
          this.dataFlowParticles.geometry.attributes.position.needsUpdate = true;
        }

        /**
         * æ›´æ–°èƒ½é‡ç²’å­å‹•ç•«
         */
        updateEnergyParticles(time) {
          const positions = this.energyParticles.geometry.attributes.position.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            const particleIndex = i / 3;
            const angle = (particleIndex / (positions.length / 3)) * Math.PI * 2 + time * 0.5;
            const radius = 10 + Math.sin(time * 2 + particleIndex) * 2;
            
            // åœ“å½¢è»Œé“é‹å‹•
            positions[i] = Math.cos(angle) * radius;
            positions[i + 1] = Math.sin(angle) * radius;
            positions[i + 2] = -15 + Math.sin(time * 3 + particleIndex) * 1;
          }
          
          this.energyParticles.geometry.attributes.position.needsUpdate = true;
          this.energyParticles.rotation.z += 0.01;
        }

        /**
         * æ›´æ–°æ•…éšœç²’å­å‹•ç•«
         */
        updateGlitchParticles(time) {
          // æ•…éšœæ•ˆæœ - éš¨æ©Ÿé–ƒçˆå’Œä½ç§»
          if (Math.random() < 0.1) { // 10% æ©Ÿç‡è§¸ç™¼æ•…éšœ
            const positions = this.glitchParticles.geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
              if (Math.random() < 0.3) { // 30% çš„ç²’å­åƒèˆ‡æ•…éšœ
                positions[i] += (Math.random() - 0.5) * 2;
                positions[i + 1] += (Math.random() - 0.5) * 2;
              }
            }
            
            this.glitchParticles.geometry.attributes.position.needsUpdate = true;
          }
          
          // é€æ˜åº¦é–ƒçˆ
          this.glitchParticles.material.opacity = 0.3 + Math.sin(time * 10) * 0.3;
        }

        /**
         * æ›´æ–°éœ“è™¹å…‰ç’°å‹•ç•«
         */
        updateNeonRings(time) {
          this.neonRings.forEach((ring, index) => {
            // æŒçºŒæ—‹è½‰
            ring.rotation.z += ring.userData.rotationSpeed;
            
            // è„ˆå‹•æ•ˆæœ
            const pulse = Math.sin(time * ring.userData.pulsePeriod) * 0.3 + 0.7;
            ring.material.opacity = ring.userData.originalOpacity * pulse;
            
            // è¼•å¾®å°ºå¯¸è®ŠåŒ–
            const scale = 1 + Math.sin(time * 1.5 + index) * 0.05;
            ring.scale.setScalar(scale);
          });
        }

        /**
         * æ›´æ–°å•†æ¨™å‹•ç•« - å¢å¼·ç‰ˆèƒŒæ™¯å‹•æ•ˆ
         */
        updateLogoAnimation(time) {
          // å•†æ¨™å¹³é¢å¢å¼·å‹•æ•ˆ
          if (this.logoPlane) {
            this.logoPlane.rotation.z = Math.sin(time * 0.2) * 0.12; // ç¨å¾®å¢å¼·æ—‹è½‰
            
            // å¢å¼·æµ®å‹•æ•ˆæœ
            this.logoPlane.position.x = Math.sin(time * 0.3) * 0.8;
            this.logoPlane.position.y = Math.cos(time * 0.25) * 0.6;
            
            // å¢å¼·å‘¼å¸å¼é€æ˜åº¦è®ŠåŒ–
            const baseOpacity = 0.6; // æé«˜åŸºç¤é€æ˜åº¦
            this.logoPlane.material.opacity = baseOpacity + Math.sin(time * 0.8) * 0.2;
            
            // å¢å¼·å°ºå¯¸è„ˆå‹•
            const scale = 1 + Math.sin(time * 1.2) * 0.15;
            this.logoPlane.scale.setScalar(scale);
          }
          
          // æ›´æ–°logoå¢å¼·å…‰æšˆ
          if (this.logoEnhancedGlows && this.logoEnhancedGlows.length > 0) {
            this.logoEnhancedGlows.forEach((glow, index) => {
              // ç¨ç«‹æ—‹è½‰
              glow.rotation.z += glow.userData.rotationSpeed;
              
              // å¼·åŒ–è„ˆå‹•æ•ˆæœ - æ”¯æ´Shaderæè³ª
              const pulse = Math.sin(time * glow.userData.pulseSpeed + glow.userData.colorShift) * 0.6 + 0.4;
              
              if (glow.material.uniforms) {
                // Shaderæè³ªæ›´æ–°
                glow.material.uniforms.time.value = time;
                glow.material.uniforms.opacity.value = glow.userData.originalOpacity * pulse;
              } else {
                // æ™®é€šæè³ªæ›´æ–°
                glow.material.opacity = glow.userData.originalOpacity * pulse;
              }
              
              // å‹•æ…‹å°ºå¯¸è®ŠåŒ–
              const scaleBase = 1 + Math.sin(time * glow.userData.pulseSpeed * 0.5 + index) * glow.userData.scaleAmplitude;
              glow.scale.setScalar(scaleBase);
              
              // åŒæ­¥ä½ç½®é£„ç§»
              glow.position.x = Math.sin(time * 0.3) * 0.8;
              glow.position.y = Math.cos(time * 0.25) * 0.6;
            });
          }
          
          // æ›´æ–°åŸæœ‰å•†æ¨™å…‰æšˆæ•ˆæœ
          if (this.logoGlowRings && this.logoGlowRings.length > 0) {
            this.logoGlowRings.forEach((ring, index) => {
              // ç¨ç«‹çš„æ—‹è½‰é€Ÿåº¦
              ring.rotation.z += ring.userData.rotationSpeed;
              
              // è„ˆå‹•æ•ˆæœï¼Œå‰µé€ éœ§åŒ–æ„Ÿ
              const pulse = Math.sin(time * ring.userData.pulseSpeed + index) * 0.4 + 0.6;
              ring.material.opacity = ring.userData.originalOpacity * pulse;
              
              // è¼•å¾®çš„å°ºå¯¸è®ŠåŒ–
              const scale = 1 + Math.sin(time * 0.5 + index * 0.5) * 0.1;
              ring.scale.setScalar(scale);
              
              // åŒæ­¥ä½ç½®é£„ç§»
              ring.position.x = Math.sin(time * 0.3) * 0.8;
              ring.position.y = Math.cos(time * 0.25) * 0.6;
            });
          }
          
          // æ›´æ–°èƒŒæ™¯å¹³é¢å‹•ç•«
          if (this.backgroundPlane) {
            // æ¥µç·©æ…¢çš„èƒŒæ™¯ç§»å‹•
            this.backgroundPlane.position.x = Math.sin(time * 0.05) * 1;
            this.backgroundPlane.position.y = Math.cos(time * 0.04) * 0.5;
            
            // èƒŒæ™¯é€æ˜åº¦å¾®èª¿
            const bgOpacity = 0.4 + Math.sin(time * 0.3) * 0.1;
            this.backgroundPlane.material.opacity = Math.min(bgOpacity, 0.6);
          }
        }

        /**
         * æ ¹æ“šä¸»é¡Œåˆ‡æ›èª¿æ•´è‰²å½©æ–¹æ¡ˆ - çµ±ä¸€ç®¡ç†ç‰ˆæœ¬
         */
        updateThemeColors(isDarkMode) {
          console.log('æ›´æ–°ä¸»é¡Œè‰²å½©:', isDarkMode ? 'æ·±è‰²æ¨¡å¼' : 'æ·ºè‰²æ¨¡å¼');
          
          try {
            // æ›´æ–°ç•¶å‰ä¸»é¡Œ
            this.currentTheme = isDarkMode ? 'dark' : 'light';
            const colors = this.getCurrentThemeColors();
            
            // 1. æ›´æ–°æ¸²æŸ“å™¨èƒŒæ™¯è‰²
            if (this.renderer) {
              this.renderer.setClearColor(colors.backgroundColor, 1.0);
            }
            
            // 2. æ›´æ–°éœ“è™¹å…‰ç’°
            if (this.neonRings) {
              this.neonRings.forEach((ring, index) => {
                ring.material.color.setHex(colors.glowColors.primary);
                ring.userData.originalOpacity = (0.3 - index * 0.05) * colors.ringOpacityMultiplier;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 3. æ›´æ–°å‚³çµ±ç²’å­ç³»çµ±
            if (this.dataFlowParticles) {
              this.dataFlowParticles.material.opacity = colors.particleOpacity.dataFlow;
            }
            if (this.energyParticles) {
              this.energyParticles.material.opacity = colors.particleOpacity.energy;
            }
            if (this.glitchParticles) {
              this.glitchParticles.material.opacity = colors.particleOpacity.glitch;
            }
            
            // 4. æ›´æ–°Spriteç²’å­ç³»çµ±
            if (this.spriteParticleGroups) {
              this.spriteParticleGroups.forEach(groupData => {
                const opacityKey = this.getSpriteGroupOpacityKey(groupData.name);
                const targetOpacity = colors.particleOpacity[opacityKey] || colors.particleOpacity.ambient;
                
                groupData.sprites.forEach(sprite => {
                  sprite.userData.rhythm.baseOpacity = targetOpacity;
                  sprite.material.opacity = targetOpacity;
                });
              });
            }
            
            // 5. æ›´æ–°å•†æ¨™å’Œå•†æ¨™å…‰æšˆ
            if (this.logoPlane) {
              this.logoPlane.material.opacity = colors.logoOpacity;
              this.logoPlane.material.color.setHex(colors.logoColorTint);
            }
            
            if (this.logoGlowRings) {
              this.logoGlowRings.forEach((ring, index) => {
                ring.material.color.setHex(colors.glowColors.logoGlow);
                ring.userData.originalOpacity = (0.15 - index * 0.03) * colors.neonIntensity;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 6. æ›´æ–°æ‰€æœ‰å¡ç‰‡ç„¡éšœç¤™ç‰¹æ•ˆè‰²å½©
            if (this.cards) {
              this.cards.forEach(card => {
                this.updateCardAccessibilityColors(card, colors);
              });
            }
            
            console.log('ä¸»é¡Œè‰²å½©æ›´æ–°å®Œæˆï¼Œå¥—ç”¨é…è‰²:', colors);
            
          } catch (error) {
            console.error('ä¸»é¡Œè‰²å½©æ›´æ–°å¤±æ•—:', error);
          }
        }

        /**
         * æ›´æ–°å–®å¼µå¡ç‰‡çš„ç„¡éšœç¤™ç‰¹æ•ˆè‰²å½©
         */
        updateCardAccessibilityColors(card, colors) {
          if (!card.userData.effects) return;
          
          const effects = card.userData.effects;
          const cardColors = colors.accessibleCard;
          
          try {
            // 1. æ›´æ–°å…‰æšˆæ•ˆæœè‰²å½©
            if (effects.aura) {
              effects.aura.material.color.setHex(colors.cardEffects.aura);
            }
            
            // 2. æ›´æ–°æƒå…‰ç·šè‰²å½©
            if (effects.scanLine) {
              effects.scanLine.material.color.setHex(colors.cardEffects.scanLine);
            }
            
            // 3. æ›´æ–°å¤šå±¤é‚Šç·£ç™¼å…‰è‰²å½©
            if (effects.edgeGlowLayers) {
              effects.edgeGlowLayers.forEach((layer, index) => {
                if (!layer.material) return;
                
                switch (index) {
                  case 0: // æœ€å¤–å±¤
                    layer.material.color.setHex(cardColors.primaryBorder);
                    break;
                  case 1: // ä¸­é–“å±¤
                    layer.material.color.setHex(cardColors.secondaryBorder);
                    break;
                  case 2: // å…§å±¤
                    layer.material.color.setHex(cardColors.glowColor);
                    break;
                  default:
                    layer.material.color.setHex(cardColors.glowColor);
                }
              });
            }
            
            // 4. æ›´æ–°èƒŒæ™¯é®ç½©è‰²å½©
            if (effects.backMask) {
              effects.backMask.material.color.setHex(cardColors.backOverlay);
            }
            
            // 5. æ›´æ–°å‰æ™¯å…‰æšˆè‰²å½©
            if (effects.frontGlow) {
              effects.frontGlow.material.color.setHex(cardColors.frontColor);
            }
            
            // 6. æ›´æ–°é™°å½±ç³»çµ±è‰²å½©
            if (effects.shadowLayers) {
              effects.shadowLayers.forEach(shadow => {
                if (shadow.material) {
                  shadow.material.color.setHex(cardColors.shadowColor);
                }
              });
            }
            
            // 7. æ›´æ–°å¡ç‰‡æè³ªè‰²å½©
            if (card.userData.frontMaterial) {
              card.userData.frontMaterial.color.setHex(cardColors.frontColor);
            }
            
            if (card.userData.backMaterial) {
              card.userData.backMaterial.color.setHex(cardColors.backBackground);
              
              // é‡æ–°å‰µå»ºèƒŒé¢ç´‹ç†ä»¥æ‡‰ç”¨æ–°è‰²å½©
              if (card.userData.name) {
                const newBackTexture = this.createAccessibleTextTexture(card.userData.name, cardColors);
                card.userData.backMaterial.map = newBackTexture;
                card.userData.backMaterial.needsUpdate = true;
              }
            }
            
            console.log('å¡ç‰‡ç„¡éšœç¤™è‰²å½©æ›´æ–°å®Œæˆ:', card.userData.name);
            
          } catch (error) {
            console.error('å¡ç‰‡è‰²å½©æ›´æ–°å¤±æ•—:', card.userData.name, error);
          }
        }

        /**
         * æ ¹æ“šSpriteç¾¤çµ„åç¨±æ˜ å°„åˆ°é€æ˜åº¦è¨­å®škey
         */
        getSpriteGroupOpacityKey(groupName) {
          const mapping = {
            'dataFlow': 'dataFlow',
            'energyRing': 'energy',
            'glitch': 'glitch',
            'ambient': 'ambient'
          };
          return mapping[groupName] || 'ambient';
        }

        /**
         * æ¸¬è©¦æ¸²æŸ“å‡½æ•¸ - ç«‹å³æ¸²æŸ“ä¸€å¹€æª¢æŸ¥å ´æ™¯
         */
        testRender() {
          if (!this.renderer || !this.scene || !this.camera) {
            console.warn('ç„¡æ³•æ¸¬è©¦æ¸²æŸ“ - ç¼ºå°‘å¿…è¦çµ„ä»¶');
            return;
          }
          
          console.log('åŸ·è¡Œæ¸¬è©¦æ¸²æŸ“...');
          console.log('å ´æ™¯ç‰©ä»¶:', this.scene.children.map(child => child.type));
          
          // æ›´æ–°ç²’å­ï¼ˆå¦‚æœå­˜åœ¨ï¼‰- ç²’å­ç³»çµ±å·²æš«æ™‚ç§»é™¤
          // this.updateParticles();
          
          // æ¸²æŸ“ä¸€å¹€
          this.renderer.render(this.scene, this.camera);
          
          console.log('æ¸¬è©¦æ¸²æŸ“å®Œæˆ');
        }

        /**
         * æ€§èƒ½ç›£æ§å’Œèª¿æ•´ç³»çµ±
         */
        initPerformanceMonitoring() {
          this.performanceStats = {
            frameCount: 0,
            lastFPSCheck: Date.now(),
            averageFPS: 60,
            lowFPSThreshold: 30,
            veryLowFPSThreshold: 20,
            optimizationLevel: 0, // 0-3ç´šå„ªåŒ–
            maxOptimizationLevel: 3
          };
          
          // æ¯ç§’æª¢æŸ¥ä¸€æ¬¡FPS
          setInterval(() => {
            this.checkPerformanceAndAdjust();
          }, 1000);
          
          console.log('å¢å¼·æ€§èƒ½ç›£æ§ç³»çµ±å·²å•Ÿå‹•');
        }

        /**
         * æª¢æŸ¥æ€§èƒ½ä¸¦è‡ªå‹•èª¿æ•´è¦–è¦ºæ•ˆæœ - å¤šç´šå„ªåŒ–
         */
        checkPerformanceAndAdjust() {
          const now = Date.now();
          const timeDiff = now - this.performanceStats.lastFPSCheck;
          const currentFPS = (this.performanceStats.frameCount * 1000) / timeDiff;
          
          this.performanceStats.averageFPS = (this.performanceStats.averageFPS + currentFPS) / 2;
          this.performanceStats.frameCount = 0;
          this.performanceStats.lastFPSCheck = now;
          
          const stats = this.performanceStats;
          
          // å¤šç´šæ€§èƒ½å„ªåŒ–ç­–ç•¥
          if (stats.averageFPS < stats.veryLowFPSThreshold && stats.optimizationLevel < 3) {
            // æ¥µä½FPSï¼šæœ€é«˜ç´šå„ªåŒ–
            stats.optimizationLevel = 3;
            this.applyOptimization(3);
            console.log('æ¥µä½FPSæª¢æ¸¬ï¼Œå•Ÿç”¨æœ€é«˜ç´šå„ªåŒ–:', stats.averageFPS.toFixed(1));
            
          } else if (stats.averageFPS < stats.lowFPSThreshold && stats.optimizationLevel < 2) {
            // ä½FPSï¼šä¸­ç´šå„ªåŒ–
            stats.optimizationLevel = Math.min(2, stats.optimizationLevel + 1);
            this.applyOptimization(stats.optimizationLevel);
            console.log('ä½FPSæª¢æ¸¬ï¼Œå„ªåŒ–ç­‰ç´šæå‡è‡³:', stats.optimizationLevel);
            
          } else if (stats.averageFPS > stats.lowFPSThreshold + 10 && stats.optimizationLevel > 0) {
            // FPSæ¢å¾©ï¼šé™ä½å„ªåŒ–ç­‰ç´š
            stats.optimizationLevel = Math.max(0, stats.optimizationLevel - 1);
            this.applyOptimization(stats.optimizationLevel);
            console.log('FPSæ¢å¾©ï¼Œå„ªåŒ–ç­‰ç´šé™ä½è‡³:', stats.optimizationLevel);
          }
        }

        /**
         * æ‡‰ç”¨å¤šç´šæ€§èƒ½å„ªåŒ–
         */
        applyOptimization(level) {
          const config = this.dynamicLayoutConfig.performance;
          
          switch (level) {
            case 0: // ç„¡å„ªåŒ– - å…¨ç‰¹æ•ˆ
              config.enableFloatAnimation = true;
              config.enableHoverEffect = true;
              config.updateFrequency = 0.033; // 30fps
              this.setParticleQuality(1.0);
              this.setShaderQuality('high');
              break;
              
            case 1: // è¼•åº¦å„ªåŒ–
              config.enableFloatAnimation = true;
              config.enableHoverEffect = true;
              config.updateFrequency = 0.04; // 25fps
              this.setParticleQuality(0.8);
              this.setShaderQuality('medium');
              break;
              
            case 2: // ä¸­åº¦å„ªåŒ–
              config.enableFloatAnimation = false;
              config.enableHoverEffect = true;
              config.updateFrequency = 0.05; // 20fps
              this.setParticleQuality(0.6);
              this.setShaderQuality('medium');
              break;
              
            case 3: // é‡åº¦å„ªåŒ–
              config.enableFloatAnimation = false;
              config.enableHoverEffect = false;
              config.updateFrequency = 0.067; // 15fps
              this.setParticleQuality(0.4);
              this.setShaderQuality('low');
              this.disableMouseEffects();
              break;
          }
          
          console.log(`æ‡‰ç”¨å„ªåŒ–ç­‰ç´š ${level}:`, config);
        }

        /**
         * è¨­å®šç²’å­ç³»çµ±å“è³ª
         */
        setParticleQuality(quality) {
          if (!this.spriteParticleGroups) return;
          
          this.spriteParticleGroups.forEach(groupData => {
            groupData.sprites.forEach(sprite => {
              // èª¿æ•´ç²’å­é€æ˜åº¦
              if (sprite.material) {
                sprite.material.opacity *= quality;
              }
              
              // ç¦ç”¨éƒ¨åˆ†æ‹–å°¾æ•ˆæœ
              if (quality < 0.6 && sprite.userData.trailSprites) {
                sprite.userData.trailSprites.forEach(trailSprite => {
                  trailSprite.visible = false;
                });
              }
            });
          });
        }

        /**
         * è¨­å®šShaderå“è³ª
         */
        setShaderQuality(quality) {
          if (!this.cards) return;
          
          this.cards.forEach(card => {
            if (!card.userData.effects) return;
            
            const effects = card.userData.effects;
            
            // èª¿æ•´Shaderçš„è¤‡é›œåº¦
            if (effects.aura && effects.aura.material.uniforms) {
              switch (quality) {
                case 'high':
                  effects.aura.material.uniforms.pulseSpeed.value = 2.0;
                  break;
                case 'medium':
                  effects.aura.material.uniforms.pulseSpeed.value = 1.0;
                  break;
                case 'low':
                  effects.aura.material.uniforms.pulseSpeed.value = 0.5;
                  effects.aura.visible = false; // å®Œå…¨éš±è—è¤‡é›œshader
                  break;
              }
            }
            
            if (effects.scanLine && quality === 'low') {
              effects.scanLine.visible = false;
            }
          });
        }

        /**
         * ç¦ç”¨é¼ æ¨™ç‰¹æ•ˆï¼ˆé‡åº¦å„ªåŒ–æ™‚ï¼‰
         */
        disableMouseEffects() {
          // æ¸…é™¤æ‰€æœ‰æ³¢ç´‹æ•ˆæœ
          if (this.mouseEffects.ripples) {
            this.mouseEffects.ripples.forEach(rippleData => {
              if (this.scene) {
                this.scene.remove(rippleData.mesh);
              }
              rippleData.mesh.geometry.dispose();
              rippleData.mesh.material.dispose();
            });
            this.mouseEffects.ripples = [];
          }
          
          // ç¦ç”¨å¼•åŠ›å ´
          this.mouseState.isMoving = false;
        }

        /**
         * æ™ºèƒ½èƒŒæ™¯äº®åº¦èª¿ç¯€ - æ ¹æ“šå¡ç‰‡æ•¸é‡å‹•æ…‹èª¿æ•´
         */
        adjustBackgroundBrightness(cardCount) {
          console.log('æ ¹æ“šå¡ç‰‡æ•¸é‡èª¿æ•´èƒŒæ™¯äº®åº¦:', cardCount);
          
          try {
            // è¨ˆç®—èƒŒæ™¯äº®åº¦ä¿‚æ•¸ - å¡ç‰‡è¶Šå¤šï¼ŒèƒŒæ™¯è¶Šæš—
            const brightnessReduction = Math.min(0.7, cardCount * 0.05);
            const finalMultiplier = 1 - brightnessReduction;
            
            // èª¿æ•´æ‰€æœ‰èƒŒæ™¯å…ƒç´ 
            const elements = [
              { items: this.spriteParticleGroups, type: 'sprite' },
              { items: this.neonRings, type: 'neon' },
              { items: this.logoGlowRings, type: 'logoGlow' },
              { items: this.logoEnhancedGlows, type: 'logoEnhanced' }
            ];
            
            elements.forEach(element => {
              if (!element.items) return;
              
              if (element.type === 'sprite') {
                element.items.forEach(groupData => {
                  groupData.sprites.forEach(sprite => {
                    sprite.userData.rhythm.baseOpacity *= finalMultiplier;
                  });
                });
              } else {
                element.items.forEach(item => {
                  if (item.userData && item.userData.originalOpacity !== undefined) {
                    item.userData.originalOpacity *= finalMultiplier;
                    item.material.opacity = item.userData.originalOpacity;
                  }
                });
              }
            });
            
            // èª¿æ•´èƒŒæ™¯å¹³é¢é€æ˜åº¦
            if (this.backgroundPlane) {
              this.backgroundPlane.material.opacity *= finalMultiplier;
            }
            
            console.log(`èƒŒæ™¯äº®åº¦å·²èª¿ç¯€ï¼Œæ¸›å°‘${(brightnessReduction * 100).toFixed(1)}%`);
            
          } catch (error) {
            console.error('èƒŒæ™¯äº®åº¦èª¿ç¯€å¤±æ•—:', error);
          }
        }

        /**
         * ç‚ºä½æ€§èƒ½è¨­å‚™å„ªåŒ–è¦–è¦ºæ•ˆæœ - é€²éšç‰ˆæœ¬
         */
        optimizeForPerformance() {
          try {
            // 1. æ¸›å°‘å‚³çµ±ç²’å­æ•¸é‡å’Œé€æ˜åº¦
            if (this.dataFlowParticles) {
              this.dataFlowParticles.material.opacity *= 0.7;
            }
            if (this.energyParticles) {
              this.energyParticles.material.opacity *= 0.7;
            }
            if (this.glitchParticles) {
              this.glitchParticles.material.opacity *= 0.6;
            }
            
            // 2. å„ªåŒ–Spriteç²’å­ç³»çµ± - æ¸›å°‘ç²’å­æ•¸é‡
            if (this.spriteParticleGroups) {
              this.spriteParticleGroups.forEach(groupData => {
                // éš±è—ä¸€åŠçš„ç²’å­ä¾†ç¯€çœæ€§èƒ½
                groupData.sprites.forEach((sprite, index) => {
                  if (index % 2 === 0) {
                    sprite.visible = false;
                  } else {
                    sprite.userData.rhythm.baseOpacity *= 0.7;
                  }
                });
              });
            }
            
            // 3. é™ä½å…‰ç’°æ•ˆæœ
            if (this.neonRings) {
              this.neonRings.forEach(ring => {
                ring.userData.originalOpacity *= 0.6;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 4. é™ä½å•†æ¨™å…‰æšˆæ•ˆæœ
            if (this.logoGlowRings) {
              this.logoGlowRings.forEach(ring => {
                ring.userData.originalOpacity *= 0.7;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 5. é™ä½æ¸²æŸ“è§£æåº¦
            if (this.renderer && this.container) {
              const pixelRatio = Math.min(window.devicePixelRatio, 1.5); // é™åˆ¶æœ€å¤§åƒç´ æ¯”
              this.renderer.setPixelRatio(pixelRatio);
              console.log('é™ä½æ¸²æŸ“åƒç´ æ¯”è‡³:', pixelRatio);
            }
            
            // 6. ç°¡åŒ–ç´‹ç†éæ¿¾
            if (this.particleAtlasTexture) {
              this.particleAtlasTexture.minFilter = THREE.LinearFilter;
              this.particleAtlasTexture.magFilter = THREE.LinearFilter;
              this.particleAtlasTexture.generateMipmaps = false;
            }
            
            console.log('å·²åŸ·è¡Œé€²éšæ€§èƒ½å„ªåŒ–');
            
          } catch (error) {
            console.error('æ€§èƒ½å„ªåŒ–åŸ·è¡Œå¤±æ•—:', error);
          }
        }

        /**
         * çµ±è¨ˆæ•ˆèƒ½è³‡è¨Š
         */
        getPerformanceStats() {
          const stats = {
            triangles: 0,
            geometries: 0,
            textures: 0,
            materials: 0,
            sprites: 0,
            lights: 0
          };
          
          if (this.renderer && this.renderer.info) {
            const info = this.renderer.info;
            stats.triangles = info.render.triangles;
            stats.geometries = info.memory.geometries;
            stats.textures = info.memory.textures;
            stats.materials = info.programs?.length || 0;
          }
          
          if (this.scene) {
            this.scene.traverse(object => {
              if (object.type === 'Sprite') stats.sprites++;
              if (object.type === 'DirectionalLight' || object.type === 'AmbientLight') stats.lights++;
            });
          }
          
          if (this.spriteParticleGroups) {
            this.spriteParticleGroups.forEach(group => {
              stats.sprites += group.sprites.length;
            });
          }
          
          return stats;
        }

        /**
         * éŠ·æ¯€ä¸¦æ¸…ç†æ‰€æœ‰Three.jsè³‡æº
         */
        dispose() {
          console.log('é–‹å§‹æ¸…ç†Three.jsè³‡æº...');
          
          try {
            // åœæ­¢å‹•ç•«
            this.isAnimating = false;
            
            // æ¸…ç†ç´‹ç†
            if (this.logoTexture) {
              this.logoTexture.dispose();
            }
            if (this.cyberpunkTexture) {
              this.cyberpunkTexture.dispose();
            }
            
            // æ¸…ç†å¹¾ä½•é«”å’Œæè³ª
            if (this.scene) {
              this.scene.traverse((object) => {
                if (object.geometry) {
                  object.geometry.dispose();
                }
                if (object.material) {
                  if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                  } else {
                    object.material.dispose();
                  }
                }
              });
            }
            
            // æ¸…ç†æ¸²æŸ“å™¨
            if (this.renderer) {
              this.renderer.dispose();
            }
            
            console.log('Three.jsè³‡æºæ¸…ç†å®Œæˆ');
            
          } catch (error) {
            console.error('è³‡æºæ¸…ç†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:', error);
          }
        }
      }
      
      // Create and expose ThreeJSAnimation instance
      window.threeJSAnimation = new ThreeJSAnimation();
      console.log('Three.js animation instance created and attached to window');
      window.threeJSLoadedSuccessfully = true;
      
    } catch (error) {
      console.error('Failed to create Three.js animation instance:', error);
      window.threeJSLoadedSuccessfully = false;
    }
  </script>
  <script src="js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Theme toggle button -->
  <button id="themeToggle" class="theme-toggle-button" aria-label="åˆ‡æ›è‰²å½©æ¨¡å¼">
    <span class="theme-icon-light">â˜€ï¸</span>
    <span class="theme-icon-dark" style="display:none;">ğŸŒ™</span>
  </button>
</body>
</html>
