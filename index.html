<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>moda_draw_tool</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Roboto:wght@400;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet" />
</head>
<body>
  <header class="app-header text-center py-4">
    <h1>moda 幸運抽獎小工具</h1>
  </header>
  <main class="container py-4">
    <section class="setup-section card shadow-sm mb-4">
      <div class="card-body">
        <h2 class="section-title mb-3">抽獎設定</h2>
        <div class="row">
          <div class="col-lg-4 mb-3">
            <label for="nameList" class="form-label">參與者清單（每行一位）：</label>
            <textarea class="form-control" id="nameList" rows="8" placeholder="輸入參與者名單..."></textarea>
            <p id="participantCount" class="mt-2 text-muted small">目前參與者 0 人</p>
          </div>
          <div class="col-lg-8">
            <div class="row">
              <div class="col-md-6 mb-3">
                <label for="prizeInput" class="form-label">抽獎品項：</label>
                <input type="text" class="form-control" id="prizeInput" placeholder="例如：頭獎 - Switch" />
              </div>
              <div class="col-md-6 mb-3">
                <label for="seedInput" class="form-label">幸運種子（可留空）：</label>
                <input type="text" class="form-control" id="seedInput" placeholder="例如：luckyday2025" />
              </div>
              <div class="col-md-6 mb-3">
                <label for="winnerCount" class="form-label">得獎人數：</label>
                <input type="number" class="form-control" id="winnerCount" value="1" min="1" placeholder="輸入數字" />
              </div>
              <div class="col-md-6 mb-3 align-self-center">
                <div class="form-check mt-3">
                  <input class="form-check-input" type="checkbox" id="allowRepeatCheckbox">
                  <label class="form-check-label" for="allowRepeatCheckbox">允許重複中獎</label>
                </div>
                <small id="repeatHelp" class="form-text text-muted">不勾選時，中獎者將從名單移除。</small>
              </div>
            </div>
          </div>
        </div>
        <div class="text-center mt-3">
          <button id="drawButton" class="btn btn-draw btn-lg px-5">開始抽獎</button>
        </div>
      </div>
    </section>

    <div class="mt-4 text-center" id="seedDisplayBlock" style="display:none;">
      <h5 class="text-muted small">本次幸運種子：<span id="seedDisplay" class="fw-bold"></span></h5>
    </div>

    <section class="results-section mt-4 mb-4">
      <h2 class="section-title text-center mb-3">中獎名單揭曉</h2>
      <div id="winnersContainer" class="row gy-4"></div>
    </section>

    <section id="remainingWrapper" class="remaining-section card shadow-sm mb-4" style="display:none;">
      <div class="card-body">
        <h3 class="section-title-sm mb-2">剩餘參與者</h3>
        <div id="remainingContainer" class="fadeInList"></div>
      </div>
    </section>

    <section class="history-section card shadow-sm">
      <div class="card-body">
        <h2 class="section-title mb-3">抽獎歷史紀錄</h2>
        <div class="row mb-3 align-items-end">
          <div class="col-md-5 mb-2 mb-md-0">
            <label for="prizeFilter" class="form-label">依品項篩選：</label>
            <select id="prizeFilter" class="form-select">
              <option value="全部">顯示全部品項</option>
            </select>
          </div>
          <div class="col-md-7 text-md-end">
            <button id="clearHistory" class="btn btn-clear-history">🗑️ 清除全部紀錄</button>
          </div>
        </div>
        <div id="historyContainer"></div>
        <nav class="pagination-container mt-3">
          <ul id="paginationContainer" class="pagination justify-content-center"></ul>
        </nav>
      </div>
    </section>
  </main>
  <footer class="app-footer text-center py-3 mt-4">
    <p class="mb-0 small">&copy; <span id="currentYear"></span> moda 幸運抽獎. All rights reserved.</p>
  </footer>

  <!-- Overlay for countdown -->
  <div id="overlay" class="overlay">
    <div class="blur-bg"></div>
    <div id="countdownContainer"></div>
  </div>

  <!-- Three.js container for cyberpunk animation -->
  <div id="threeContainer" style="
    position: fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%);
    width: 1200px; 
    height: 700px;
    max-width: 95vw;
    max-height: 95vh;
    z-index: 9999; 
    display: none !important;
    visibility: hidden; 
    background: linear-gradient(135deg, rgba(10,10,10,0.95) 0%, rgba(26,0,51,0.9) 25%, rgba(0,0,102,0.85) 50%, rgba(51,0,102,0.9) 75%, rgba(102,0,153,0.95) 100%);
    border-radius: 15px;
    box-shadow: 0 20px 60px rgba(0,255,255,0.3), 0 0 40px rgba(255,0,255,0.2), inset 0 0 30px rgba(0,255,255,0.1);
    border: 2px solid rgba(0,255,255,0.5);
    overflow: hidden;
    backdrop-filter: blur(5px);
  "></div>

  <!-- 引入 confetti 函式庫 -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>
  <!-- Three.js 動畫系統使用 ES Modules -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    
    console.log('Three.js ES module loaded:', THREE);
    
    // Make THREE available globally
    window.THREE = THREE;
    
    // Import and create animation class
    try {
      // Simple Three.js animation class
      class ThreeJSAnimation {
        constructor() {
          console.log('ES Module ThreeJSAnimation constructor called');
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.cards = [];
          this.container = null;
          this.isAnimating = false;
          this.animationCallback = null;
          this.clickHandlerAdded = false;
          
          // 初始化性能配置與參數管理
          this.initPerformanceConfig();
          
          // 初始化統一主題色彩管理系統
          this.initThemeColorManager();
          
          // 初始化鼠標互動系統
          this.initMouseInteraction();
        }

        /**
         * 初始化鼠標互動系統
         */
        initMouseInteraction() {
          console.log('初始化鼠標互動系統...');
          
          // 鼠標狀態跟蹤
          this.mouseState = {
            position: new THREE.Vector2(),
            normalizedPosition: new THREE.Vector2(),
            isMoving: false,
            lastMoveTime: 0,
            velocity: new THREE.Vector2(),
            lastPosition: new THREE.Vector2()
          };
          
          // Raycaster 用於檢測互動
          this.raycaster = new THREE.Raycaster();
          this.hoveredObjects = [];
          
          // 互動特效
          this.mouseEffects = {
            ripples: [], // 波紋效果陣列
            gravitationalField: null, // 引力場
            cursor: null // 自訂游標效果
          };
          
          console.log('鼠標互動系統初始化完成');
        }

        /**
         * 設定鼠標事件監聽器
         */
        setupMouseEventListeners() {
          if (!this.container) return;
          
          console.log('設定鼠標事件監聽器...');
          
          // 鼠標移動事件
          this.container.addEventListener('mousemove', (event) => {
            this.handleMouseMove(event);
          });
          
          // 鼠標點擊事件
          this.container.addEventListener('click', (event) => {
            this.handleMouseClick(event);
          });
          
          // 鼠標進入和離開事件
          this.container.addEventListener('mouseenter', () => {
            this.mouseState.isMoving = true;
          });
          
          this.container.addEventListener('mouseleave', () => {
            this.mouseState.isMoving = false;
            this.clearHoverEffects();
          });
          
          console.log('鼠標事件監聽器設定完成');
        }

        /**
         * 處理鼠標移動事件
         */
        handleMouseMove(event) {
          if (!this.container || !this.camera) return;
          
          const rect = this.container.getBoundingClientRect();
          
          // 更新鼠標位置
          this.mouseState.lastPosition.copy(this.mouseState.position);
          this.mouseState.position.x = event.clientX - rect.left;
          this.mouseState.position.y = event.clientY - rect.top;
          
          // 標準化座標 (-1 到 1)
          this.mouseState.normalizedPosition.x = (this.mouseState.position.x / rect.width) * 2 - 1;
          this.mouseState.normalizedPosition.y = -(this.mouseState.position.y / rect.height) * 2 + 1;
          
          // 計算鼠標速度
          this.mouseState.velocity.subVectors(this.mouseState.position, this.mouseState.lastPosition);
          
          this.mouseState.isMoving = true;
          this.mouseState.lastMoveTime = Date.now();
          
          // 進行 Raycasting 檢測
          this.performRaycasting();
          
          // 更新引力場效果
          this.updateGravitationalField();
        }

        /**
         * 處理鼠標點擊事件
         */
        handleMouseClick(event) {
          console.log('鼠標點擊事件:', event);
          
          // 創建波紋效果
          this.createRippleEffect(this.mouseState.normalizedPosition.clone());
          
          // 檢測點擊的物件
          this.performRaycasting();
          
          // 如果點擊到卡片，觸發特殊效果
          if (this.hoveredObjects.length > 0) {
            this.hoveredObjects.forEach(intersection => {
              if (intersection.object.userData && intersection.object.userData.name) {
                this.triggerCardClickEffect(intersection.object);
              }
            });
          }
        }

        /**
         * 執行 Raycasting 檢測
         */
        performRaycasting() {
          if (!this.raycaster || !this.camera || !this.scene) return;
          
          // 設定 raycaster
          this.raycaster.setFromCamera(this.mouseState.normalizedPosition, this.camera);
          
          // 檢測所有可互動物件
          const intersectableObjects = [];
          
          // 添加卡片到檢測清單
          if (this.cards) {
            intersectableObjects.push(...this.cards);
          }
          
          // 添加粒子到檢測清單（選擇性）
          if (this.spriteParticleGroups) {
            this.spriteParticleGroups.forEach(group => {
              // 只檢測大尺寸粒子
              const largeParticles = group.sprites.filter(sprite => sprite.scale.x > 1.0);
              intersectableObjects.push(...largeParticles);
            });
          }
          
          // 執行碰撞檢測
          const intersections = this.raycaster.intersectObjects(intersectableObjects);
          
          // 清除之前的hover效果
          this.clearHoverEffects();
          
          // 應用新的hover效果
          this.hoveredObjects = intersections.slice(0, 3); // 限制最多3個物件
          this.applyHoverEffects();
        }

        /**
         * 應用hover效果
         */
        applyHoverEffects() {
          this.hoveredObjects.forEach(intersection => {
            const object = intersection.object;
            
            if (object.userData && object.userData.effects) {
              // 卡片hover效果
              this.applyCardHoverEffect(object);
            } else if (object.material && object.material.opacity !== undefined) {
              // 粒子hover效果
              this.applyParticleHoverEffect(object);
            }
          });
        }

        /**
         * 應用卡片hover效果
         */
        applyCardHoverEffect(card) {
          if (!card.userData.animationState) return;
          
          card.userData.animationState.isHovered = true;
          
          // 增強光暈
          if (card.userData.effects.edgeGlowLayers) {
            card.userData.effects.edgeGlowLayers.forEach(layer => {
              if (layer.material) {
                layer.material.opacity *= 1.5;
              }
            });
          }
          
          // 輕微放大
          const hoverScale = 1.05;
          card.scale.multiplyScalar(hoverScale);
        }

        /**
         * 應用粒子hover效果
         */
        applyParticleHoverEffect(particle) {
          // 增強粒子亮度和尺寸
          if (particle.material) {
            particle.material.opacity = Math.min(1.0, particle.material.opacity * 1.3);
          }
          particle.scale.multiplyScalar(1.2);
        }

        /**
         * 清除hover效果
         */
        clearHoverEffects() {
          this.hoveredObjects.forEach(intersection => {
            const object = intersection.object;
            
            if (object.userData && object.userData.animationState) {
              object.userData.animationState.isHovered = false;
            }
          });
          
          this.hoveredObjects = [];
        }

        /**
         * 創建波紋效果
         */
        createRippleEffect(position) {
          const rippleGeometry = new THREE.RingGeometry(0.1, 0.1, 16);
          const rippleMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
          });
          
          const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
          
          // 將螢幕座標轉換為世界座標
          const worldPosition = new THREE.Vector3(position.x, position.y, 0);
          worldPosition.unproject(this.camera);
          
          ripple.position.copy(worldPosition);
          ripple.position.z = 0; // 確保在合適的深度
          ripple.renderOrder = 999;
          
          const rippleData = {
            mesh: ripple,
            startTime: Date.now(),
            duration: 1000, // 1秒
            maxRadius: 5
          };
          
          this.mouseEffects.ripples.push(rippleData);
          
          if (this.scene) {
            this.scene.add(ripple);
          }
        }

        /**
         * 更新引力場效果
         */
        updateGravitationalField() {
          if (!this.spriteParticleGroups || !this.mouseState.isMoving) return;
          
          const mouseWorldPos = new THREE.Vector3(
            this.mouseState.normalizedPosition.x,
            this.mouseState.normalizedPosition.y,
            0
          );
          mouseWorldPos.unproject(this.camera);
          
          // 影響附近的粒子
          this.spriteParticleGroups.forEach(group => {
            group.sprites.forEach(sprite => {
              const distance = sprite.position.distanceTo(mouseWorldPos);
              
              if (distance < 10) { // 影響範圍
                const force = (10 - distance) / 10; // 力的強度
                const direction = new THREE.Vector3()
                  .subVectors(mouseWorldPos, sprite.position)
                  .normalize()
                  .multiplyScalar(force * 0.02);
                
                // 應用引力或斥力
                if (this.mouseState.velocity.length() > 5) {
                  // 快速移動時產生斥力
                  sprite.position.sub(direction);
                } else {
                  // 慢速移動時產生引力
                  sprite.position.add(direction);
                }
              }
            });
          });
        }

        /**
         * 觸發卡片點擊效果
         */
        triggerCardClickEffect(card) {
          console.log('觸發卡片點擊效果:', card.userData.name);
          
          // 卡片底部光暈效果已完全移除
          /*
          // 創建爆炸式光暈
          if (card.userData.effects.aura) {
            const aura = card.userData.effects.aura;
            
            // 動畫參數
            const startTime = Date.now();
            const duration = 800;
            
            const animateExplosion = () => {
              const elapsed = Date.now() - startTime;
              const progress = elapsed / duration;
              
              if (progress < 1) {
                // 爆炸式放大
                const scale = 1 + progress * 4;
                aura.scale.setScalar(scale);
                
                // 透明度變化
                aura.material.uniforms.intensity.value = (1 - progress) * 2;
                
                requestAnimationFrame(animateExplosion);
              } else {
                // 重置
                aura.scale.setScalar(1);
                aura.material.uniforms.intensity.value = 0;
              }
            };
            
            animateExplosion();
          }
          */
        }

        /**
         * 更新鼠標互動效果
         */
        updateMouseEffects(time) {
          // 更新波紋效果
          this.mouseEffects.ripples = this.mouseEffects.ripples.filter(rippleData => {
            const elapsed = Date.now() - rippleData.startTime;
            const progress = elapsed / rippleData.duration;
            
            if (progress < 1) {
              // 更新波紋
              const currentRadius = rippleData.maxRadius * progress;
              rippleData.mesh.geometry.dispose();
              rippleData.mesh.geometry = new THREE.RingGeometry(
                currentRadius * 0.8, 
                currentRadius, 
                16
              );
              
              rippleData.mesh.material.opacity = (1 - progress) * 0.8;
              
              return true;
            } else {
              // 移除完成的波紋
              if (this.scene) {
                this.scene.remove(rippleData.mesh);
              }
              rippleData.mesh.geometry.dispose();
              rippleData.mesh.material.dispose();
              return false;
            }
          });
          
          // 檢查鼠標靜止狀態
          if (Date.now() - this.mouseState.lastMoveTime > 100) {
            this.mouseState.isMoving = false;
          }
        }

        /**
         * 初始化性能配置與參數管理
         */
        initPerformanceConfig() {
          console.log('初始化性能配置系統...');
          
          // 動態調整配置
          this.dynamicLayoutConfig = {
            // 卡片尺寸配置（可調節）
            sizeFactors: {
              single: 2.0,      // 單張卡片放大係數
              dual: 1.8,        // 兩張卡片放大係數
              triple: 1.5,      // 三張卡片放大係數
              medium: 1.3,      // 中等數量基準係數
              standard: 1.0     // 標準尺寸係數
            },
            
            // 光暈強度配置
            glowFactors: {
              maxIntensity: 2.1,  // 最大光暈強度（1張卡片）
              minIntensity: 0.8,  // 最小光暈強度（超多卡片）
              boostThreshold: 3   // 少量卡片強化閾值
            },
            
            // 間距配置
            spacingFactors: {
              singleCard: { x: 0, y: 0 },
              dualCard: { x: 5.0, y: 0 },
              tripleCard: { x: 4.5, y: 0 },
              gridBase: { x: 4.0, y: 3.0 },
              gridDecrement: { x: 0.2, y: 0.1 }
            },
            
            // 性能優化配置
            performance: {
              maxCardCount: 50,        // 最大支援卡片數量
              floatAnimationThreshold: 3, // 啟用浮動動畫的卡片數量閾值
              updateFrequency: 0.033,  // 更新頻率 (30fps)
              enableHoverEffect: true,  // 是否啟用hover效果
              enableFloatAnimation: true // 是否啟用浮動動畫
            }
          };
          
          // 性能監控
          this.performanceStats = {
            frameCount: 0,
            lastFpsCheck: 0,
            averageFps: 60,
            droppedFrames: 0,
            isLowPerformance: false
          };
          
          console.log('性能配置系統初始化完成', this.dynamicLayoutConfig);
        }

        /**
         * 動態性能調整
         */
        adjustPerformanceSettings(cardCount) {
          const config = this.dynamicLayoutConfig.performance;
          
          // 根據卡片數量自動調整性能設定
          if (cardCount > 20) {
            // 大量卡片時降低效果強度
            config.enableFloatAnimation = false;
            config.enableHoverEffect = false;
            config.updateFrequency = 0.05; // 20fps
          } else if (cardCount > 10) {
            // 中等數量時適度調整
            config.enableFloatAnimation = false;
            config.enableHoverEffect = true;
            config.updateFrequency = 0.04; // 25fps
          } else {
            // 少量卡片時啟用全部效果
            config.enableFloatAnimation = true;
            config.enableHoverEffect = true;
            config.updateFrequency = 0.033; // 30fps
          }
          
          console.log('為 ' + cardCount + ' 張卡片調整性能設定:', config);
        }

        /**
         * 統一主題色彩管理系統
         */
        initThemeColorManager() {
          console.log('初始化統一主題色彩管理系統...');
          
          this.themeColors = {
            dark: {
              // 背景色彩 - 降低亮度避免搶眼
              backgroundColor: 0x0a0a0a,
              gradientStart: 0x1a0033,
              gradientEnd: 0x660099,
              
              // 粒子色彩 - 調低透明度平衡
              particleOpacity: {
                dataFlow: 0.5, // 從0.8降低到0.5
                energy: 0.6,   // 從0.9降低到0.6
                glitch: 0.4,   // 從0.7降低到0.4
                ambient: 0.3   // 從0.6降低到0.3
              },
              
              // 光暈色彩 - 優化賽博龐克配色
              glowColors: {
                primary: 0x00e6e6,   // 調和青色 (降低飽和度)
                secondary: 0xe600e6, // 調和洋紅色 (降低飽和度)
                accent: 0x0099cc,    // 深青藍色 (替代黃色)
                logoGlow: 0x5c8fb3   // 柔和藍紫色
              },
              
              // 卡片特效色彩 - 統一賽博龐克風格
              cardEffects: {
                aura: 0x00cccc,      // 柔和青色光暈
                scanLine: 0xcc00cc,  // 柔和洋紅掃描線
                edgeGlow: 0x4dd9d9   // 柔和青色邊緣發光 (移除黃色)
              },
              
              // 無障礙卡片色彩系統 - WCAG 4.5:1 對比度標準
              accessibleCard: {
                // 卡片正面：亮金色保持高對比
                frontColor: 0xffd700,
                frontBorder: 0xffffff,
                
                // 卡片背面：深色背景+淺色文字
                backBackground: 0x1a1a1a,    // 深灰黑色
                backText: 0xffffff,          // 純白文字
                backBorder: 0x00ffff,        // 青色邊框
                backOverlay: 0x000000,       // 黑色遮罩
                
                // 強化邊框
                primaryBorder: 0x00ffff,     // 青色主邊框
                secondaryBorder: 0xffffff,   // 白色副邊框
                glowColor: 0x66ffff,         // 淺青色光暈
                
                // 陰影系統
                shadowColor: 0x000000,       // 純黑陰影
                shadowIntensity: 0.8
              },
              
              // 商標色彩
              logoOpacity: 0.3,
              logoColorTint: 0x8888cc,
              
              // 光環透明度係數 - 降低強度
              ringOpacityMultiplier: 0.8, // 從1.2降低到0.8
              neonIntensity: 0.6          // 從1.0降低到0.6
            },
            
            light: {
              // 背景色彩
              backgroundColor: 0x2a2a3a,
              gradientStart: 0x3a3a4a,
              gradientEnd: 0x4a4a5a,
              
              // 粒子色彩
              particleOpacity: {
                dataFlow: 0.5,
                energy: 0.6,
                glitch: 0.4,
                ambient: 0.3
              },
              
              // 光暈色彩（淡色模式優化）
              glowColors: {
                primary: 0x5cb3b3,   // 淡青色 (進一步降低飽和度)
                secondary: 0xb35cb3, // 淡洋紅色 (進一步降低飽和度)
                accent: 0x5c99b3,    // 淡藍色調 (替代黃色)
                logoGlow: 0x8099cc   // 淡藍紫色
              },
              
              // 卡片特效色彩 - 淡色模式統一風格
              cardEffects: {
                aura: 0x66b3b3,      // 淡青色光暈
                scanLine: 0xb366b3,  // 淡洋紅掃描線
                edgeGlow: 0x66b3cc   // 淡藍色邊緣發光 (移除黃色)
              },
              
              // 無障礙卡片色彩系統 - 淺色模式
              accessibleCard: {
                // 卡片正面：深金色保持對比
                frontColor: 0xcc9900,
                frontBorder: 0x333333,
                
                // 卡片背面：淺色背景+深色文字
                backBackground: 0xf5f5f5,    // 淺灰白色
                backText: 0x222222,          // 深灰黑色文字
                backBorder: 0x0066cc,        // 深藍色邊框
                backOverlay: 0xffffff,       // 白色遮罩
                
                // 強化邊框
                primaryBorder: 0x0066cc,     // 深藍色主邊框
                secondaryBorder: 0x333333,   // 深灰色副邊框
                glowColor: 0x4488cc,         // 中藍色光暈
                
                // 陰影系統
                shadowColor: 0x000000,       // 純黑陰影
                shadowIntensity: 0.6
              },
              
              // 商標色彩
              logoOpacity: 0.2,
              logoColorTint: 0xaaaadd,
              
              // 光環透明度係數
              ringOpacityMultiplier: 0.7,
              neonIntensity: 0.6
            }
          };
          
          // 當前主題
          this.currentTheme = 'dark';
          
          console.log('主題色彩管理系統初始化完成');
        }

        /**
         * 取得當前主題的色彩配置
         */
        getCurrentThemeColors() {
          return this.themeColors[this.currentTheme];
        }

        init() {
          this.container = document.getElementById('threeContainer');
          
          if (!this.container) {
            console.error('Three.js container not found');
            return false;
          }

          console.log('Container found:', this.container);
          
          // 保持容器隱藏，避免覆蓋畫面問題
          // this.container.style.display = 'block'; // 已註解，使用 DOM 卡片展示
          
          // Wait a moment for CSS to apply, then get dimensions
          setTimeout(() => {
            const rect = this.container.getBoundingClientRect();
            console.log('Container getBoundingClientRect:', rect);
          }, 10);
          
          // Use fallback dimensions if container reports 0 size
          let width = this.container.clientWidth || 1200;
          let height = this.container.clientHeight || 700;
          
          // If still 0, use window dimensions as fallback
          if (width === 0 || height === 0) {
            width = Math.min(window.innerWidth * 0.9, 1200);
            height = Math.min(window.innerHeight * 0.9, 700);
            console.log('Using fallback dimensions:', width, 'x', height);
          }
          
          console.log('Final container dimensions:', width, 'x', height);

          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
          this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
          
          this.renderer.setSize(width, height);
          // 使用深藍色背景，完全不透明，避免詭異的視覺效果
          this.renderer.setClearColor(0x1a1a2e, 1.0);
          
          // 啟用深度測試和渲染順序排序
          this.renderer.sortObjects = true;
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 性能優化
          
          // Style the canvas to ensure it's visible
          this.renderer.domElement.style.position = 'absolute';
          this.renderer.domElement.style.top = '0';
          this.renderer.domElement.style.left = '0';
          this.renderer.domElement.style.width = '100%';
          this.renderer.domElement.style.height = '100%';
          this.renderer.domElement.style.zIndex = '1';
          
          this.container.appendChild(this.renderer.domElement);
          
          // 設置適當的光照系統
          // 環境光：提供基礎照明
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
          this.scene.add(ambientLight);
          
          // 主方向光：模擬太陽光
          const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
          mainLight.position.set(5, 10, 5);
          mainLight.castShadow = false; // 關閉陰影以提高性能
          this.scene.add(mainLight);
          
          // 補光：從另一個角度提供柔和照明
          const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
          fillLight.position.set(-5, 0, 3);
          this.scene.add(fillLight);
          
          console.log('基礎光照系統設置完成');
          
          // 創建動態光影系統
          this.createDynamicLightingSystem();
          
          // 設置相機位置，提供最佳視角
          this.camera.position.set(0, 2, 12); // 稍微提高並遠離，獲得更好的視角
          this.camera.lookAt(0, 0, 0);
          
          // 設置相機參數
          this.camera.near = 0.1;
          this.camera.far = 100;
          this.camera.updateProjectionMatrix();
          
          console.log('相機設置完成，位置:', this.camera.position);
          
          // 初始化賽博龐克背景效果
          console.log('初始化賽博龐克背景效果...');
          this.createModaSvgTexture();
          this.createBackgroundPlane();
          // 暫時註解粒子系統以實現簡約風格
          // this.initParticleSystem();
          
          console.log('Three.js initialized successfully');
          console.log('Scene objects count:', this.scene.children.length);
          console.log('Camera position:', this.camera.position);
          console.log('Renderer size:', this.renderer.getSize(new THREE.Vector2()));

          // 啟動性能監控系統
          this.initPerformanceMonitoring();
          
          // 設定鼠標互動事件監聽器
          this.setupMouseEventListeners();

          window.addEventListener('resize', () => this.onWindowResize(), false);
          return true;
        }

        onWindowResize() {
          if (!this.camera || !this.renderer || !this.container) return;
          
          this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        }

        createCard(name, scaleFactor = 1.0, glowIntensity = 1.0, focusEnhancement = {}) {
          console.log('Creating card for:', name, { scaleFactor, glowIntensity });
          
          // 獲取當前主題的無障礙配色
          const colors = this.getCurrentThemeColors();
          const cardColors = colors.accessibleCard;
          
          // 創建動態尺寸的卡片 - 根據 scaleFactor 調整幾何體尺寸
          const baseWidth = 2;
          const baseHeight = 3;
          const geometry = new THREE.PlaneGeometry(
            baseWidth * scaleFactor, 
            baseHeight * scaleFactor
          );
          
          // 卡片正面：升級為PBR材質，增加金屬感與光澤度
          const frontMaterial = new THREE.MeshStandardMaterial({ 
            color: cardColors.frontColor,
            side: THREE.DoubleSide,
            metalness: 0.3, // 30%金屬感
            roughness: 0.4, // 較低粗糙度增加光澤
            envMapIntensity: 1.0, // 環境反射強度
            transparent: false
          });
          
          // 卡片背面：載入高對比度文字貼圖
          let backTexture = null;
          let backMaterial = null;
          
          try {
            backTexture = this.createAccessibleTextTexture(name, cardColors);
            
            // 檢查貼圖是否成功創建
            if (backTexture && backTexture.image) {
              backMaterial = new THREE.MeshStandardMaterial({ 
                map: backTexture,
                side: THREE.DoubleSide,
                color: 0xffffff,
                metalness: 0.2, // 較低金屬感保持文字清晰
                roughness: 0.6, // 適中粗糙度
                envMapIntensity: 0.8,
                transparent: false
              });
              console.log('無障礙貼圖載入成功:', name);
            } else {
              throw new Error('貼圖創建失敗');
            }
          } catch (error) {
            console.warn('貼圖載入失敗，使用後備材質:', error);
            // 後備材質：升級為PBR材質
            backMaterial = new THREE.MeshStandardMaterial({
              color: cardColors.backBackground,
              side: THREE.DoubleSide,
              metalness: 0.2,
              roughness: 0.6,
              envMapIntensity: 0.8
            });
          }
          
          const card = new THREE.Mesh(geometry, frontMaterial);
          
          // 設定卡片渲染順序為最高優先級（確保永遠在最前景）
          card.renderOrder = 1000; // 最高渲染順序
          
          // 創建增強卡片材質效果
          this.enhanceCardMaterialEffects(frontMaterial, backMaterial, cardColors);
          
          // 創建卡片光暈和掃光效果 - 應用動態強度
          const cardEffects = this.createCardEffects(scaleFactor, glowIntensity, focusEnhancement);
          
          // 創建卡片翻轉與反射動畫效果
          const cardAnimationEffects = this.createCardAnimationEffects(card, scaleFactor, cardColors);
          
          card.userData = {
            frontMaterial: frontMaterial,
            backMaterial: backMaterial,
            isFlipped: false,
            name: name,
            settled: false,
            clickable: false,
            effects: cardEffects,
            animationEffects: cardAnimationEffects, // 新增動畫效果
            scaleFactor: scaleFactor, // 儲存縮放因子供後續使用
            glowIntensity: glowIntensity, // 儲存光暈強度
            focusEnhancement: focusEnhancement, // 儲存焦點強化參數
            // 動畫狀態追蹤
            animationState: {
              isLanding: false,
              isFlipping: false,
              landingProgress: 0,
              flipProgress: 0,
              lastFlipTime: 0
            }
          };
          
          // 將特效添加為卡片的子物件 - 移除底部光暈
          // if (cardEffects.aura) card.add(cardEffects.aura);
          if (cardEffects.scanLine) card.add(cardEffects.scanLine);
          if (cardEffects.edgeGlowLayers) {
            cardEffects.edgeGlowLayers.forEach(layer => card.add(layer));
          }
          if (cardEffects.backMask) card.add(cardEffects.backMask);
          if (cardEffects.frontGlow) card.add(cardEffects.frontGlow);
          if (cardEffects.shadowLayers) {
            cardEffects.shadowLayers.forEach(shadow => card.add(shadow));
          }
          
          // 添加新的動畫效果到卡片
          if (cardAnimationEffects.landingReflection) {
            card.add(cardAnimationEffects.landingReflection);
          }
          if (cardAnimationEffects.flipSweepLight) {
            card.add(cardAnimationEffects.flipSweepLight);
          }
          if (cardAnimationEffects.enhancedEdgeGlow) {
            card.add(cardAnimationEffects.enhancedEdgeGlow);
          }
          
          console.log('Enhanced card created for:', name);
          console.log('Front material color:', frontMaterial.color.getHexString());
          if (backTexture && backTexture.image) {
            console.log('Back texture size:', backTexture.image.width, 'x', backTexture.image.height);
          }
          
          return card;
        }

        /**
         * 增強卡片材質效果 - PBR材質優化
         */
        enhanceCardMaterialEffects(frontMaterial, backMaterial, cardColors) {
          // 為PBR材質添加環境反射立方體貼圖
          if (!this.envMap) {
            this.createEnvironmentMap();
          }
          
          if (this.envMap) {
            frontMaterial.envMap = this.envMap;
            if (backMaterial) {
              backMaterial.envMap = this.envMap;
            }
          }
          
          // 添加法線貼圖提升細節
          if (!this.cardNormalMap) {
            this.cardNormalMap = this.createCardNormalMap();
          }
          
          if (this.cardNormalMap) {
            frontMaterial.normalMap = this.cardNormalMap;
            frontMaterial.normalScale = new THREE.Vector2(0.5, 0.5);
            
            if (backMaterial) {
              backMaterial.normalMap = this.cardNormalMap;
              backMaterial.normalScale = new THREE.Vector2(0.3, 0.3);
            }
          }
          
          // 添加粗糙度貼圖增加真實感
          if (!this.cardRoughnessMap) {
            this.cardRoughnessMap = this.createCardRoughnessMap();
          }
          
          if (this.cardRoughnessMap) {
            frontMaterial.roughnessMap = this.cardRoughnessMap;
            if (backMaterial) {
              backMaterial.roughnessMap = this.cardRoughnessMap;
            }
          }
        }

        /**
         * 創建環境反射貼圖
         */
        createEnvironmentMap() {
          const cubeTextureLoader = new THREE.CubeTextureLoader();
          
          // 創建程序化環境貼圖
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 512;
          const ctx = canvas.getContext('2d');
          
          // 賽博龐克風格漸層
          const gradient = ctx.createLinearGradient(0, 0, 512, 512);
          gradient.addColorStop(0, '#001122');
          gradient.addColorStop(0.5, '#003366');
          gradient.addColorStop(1, '#000011');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 512, 512);
          
          // 添加霓虹點綴
          ctx.fillStyle = '#00ffff';
          ctx.globalAlpha = 0.3;
          for (let i = 0; i < 20; i++) {
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const radius = Math.random() * 3 + 1;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          const texture = new THREE.CanvasTexture(canvas);
          this.envMap = texture;
        }

        /**
         * 創建卡片法線貼圖
         */
        createCardNormalMap() {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
          
          // 創建細微的表面變化
          const imageData = ctx.createImageData(256, 256);
          const data = imageData.data;
          
          for (let i = 0; i < data.length; i += 4) {
            const x = (i / 4) % 256;
            const y = Math.floor((i / 4) / 256);
            
            // 創建細微的波紋效果
            const nx = Math.sin(x * 0.1) * 0.1 + 0.5;
            const ny = Math.sin(y * 0.1) * 0.1 + 0.5;
            
            data[i] = nx * 255;     // R - 法線 X
            data[i + 1] = ny * 255; // G - 法線 Y
            data[i + 2] = 255;      // B - 法線 Z
            data[i + 3] = 255;      // A - 透明度
          }
          
          ctx.putImageData(imageData, 0, 0);
          return new THREE.CanvasTexture(canvas);
        }

        /**
         * 創建卡片粗糙度貼圖
         */
        createCardRoughnessMap() {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
          
          // 創建粗糙度變化
          const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
          gradient.addColorStop(0, '#808080'); // 中心較光滑
          gradient.addColorStop(1, '#404040'); // 邊緣較粗糙
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 256, 256);
          
          return new THREE.CanvasTexture(canvas);
        }

        /**
         * 創建卡片翻轉與反射動畫效果
         */
        createCardAnimationEffects(card, scaleFactor, cardColors) {
          const effects = {};
          
          // 1. 落地反射光暈效果 (已簡化移除)
          // effects.landingReflection = this.createLandingReflectionEffect(scaleFactor, cardColors);
          
          // 2. 翻轉掃光效果 (已簡化移除)
          // effects.flipSweepLight = this.createFlipSweepLightEffect(scaleFactor, cardColors);
          
          // 3. 邊緣強化發光效果 (保留但簡化)
          effects.enhancedEdgeGlow = this.createEnhancedEdgeGlowEffect(scaleFactor, cardColors);
          
          return effects;
        }

        /**
         * 創建落地反射光暈效果
         */
        createLandingReflectionEffect(scaleFactor, cardColors) {
          const reflectionGeometry = new THREE.PlaneGeometry(3.0 * scaleFactor, 3.0 * scaleFactor);
          
          const reflectionMaterial = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0.0 },
              intensity: { value: 0.0 },
              color: { value: new THREE.Color(cardColors.primaryBorder) },
              center: { value: new THREE.Vector2(0.5, 0.5) }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform float time;
              uniform float intensity;
              uniform vec3 color;
              uniform vec2 center;
              varying vec2 vUv;
              
              void main() {
                vec2 pos = vUv - center;
                float dist = length(pos);
                
                // 創建脈動反射效果
                float ripple = sin(dist * 20.0 - time * 8.0) * 0.5 + 0.5;
                float fade = 1.0 - smoothstep(0.0, 0.5, dist);
                
                float alpha = ripple * fade * intensity;
                gl_FragColor = vec4(color, alpha);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
          });
          
          const reflection = new THREE.Mesh(reflectionGeometry, reflectionMaterial);
          reflection.rotation.x = -Math.PI / 2;
          reflection.position.y = -1.6 * scaleFactor;
          reflection.renderOrder = 550;
          
          return reflection;
        }

        /**
         * 創建翻轉掃光效果
         */
        createFlipSweepLightEffect(scaleFactor, cardColors) {
          const sweepGeometry = new THREE.PlaneGeometry(2.2 * scaleFactor, 3.2 * scaleFactor);
          
          const sweepMaterial = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0.0 },
              progress: { value: 0.0 },
              color: { value: new THREE.Color(cardColors.glowColor) },
              sweepAngle: { value: 0.0 }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform float time;
              uniform float progress;
              uniform vec3 color;
              uniform float sweepAngle;
              varying vec2 vUv;
              
              void main() {
                vec2 center = vec2(0.5, 0.5);
                vec2 pos = vUv - center;
                
                // 創建掃光效果
                float angle = atan(pos.y, pos.x) + 3.14159;
                float normalizedAngle = angle / (2.0 * 3.14159);
                
                float sweepWidth = 0.2;
                float sweepPos = mod(sweepAngle / (2.0 * 3.14159), 1.0);
                
                float dist = abs(normalizedAngle - sweepPos);
                dist = min(dist, 1.0 - dist); // 處理環繞
                
                float intensity = 1.0 - smoothstep(0.0, sweepWidth, dist);
                intensity *= progress;
                
                gl_FragColor = vec4(color, intensity);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
          });
          
          const sweep = new THREE.Mesh(sweepGeometry, sweepMaterial);
          sweep.position.z = 0.02 * scaleFactor;
          sweep.renderOrder = 650;
          
          return sweep;
        }

        /**
         * 創建增強邊緣發光效果
         */
        createEnhancedEdgeGlowEffect(scaleFactor, cardColors) {
          const glowGeometry = new THREE.PlaneGeometry(2.4 * scaleFactor, 3.4 * scaleFactor);
          
          const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0.0 },
              intensity: { value: 1.0 },
              primaryColor: { value: new THREE.Color(cardColors.primaryBorder) },
              secondaryColor: { value: new THREE.Color(cardColors.glowColor) },
              pulseSpeed: { value: 2.0 }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform float time;
              uniform float intensity;
              uniform vec3 primaryColor;
              uniform vec3 secondaryColor;
              uniform float pulseSpeed;
              varying vec2 vUv;
              
              void main() {
                vec2 center = vec2(0.5, 0.5);
                vec2 pos = vUv - center;
                
                // 計算距邊緣的距離
                float edgeDist = min(
                  min(vUv.x, 1.0 - vUv.x),
                  min(vUv.y, 1.0 - vUv.y)
                );
                
                // 創建邊緣發光
                float edgeGlow = 1.0 - smoothstep(0.0, 0.1, edgeDist);
                
                // 添加脈動效果
                float pulse = sin(time * pulseSpeed) * 0.3 + 0.7;
                
                // 混合色彩
                vec3 color = mix(primaryColor, secondaryColor, pulse);
                
                float alpha = edgeGlow * intensity * pulse;
                gl_FragColor = vec4(color, alpha);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
          });
          
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.position.z = 0.015 * scaleFactor;
          glow.renderOrder = 680;
          
          return glow;
        }

        /**
         * 創建自訂 Shader Material 霓虹光暈效果
         */
        createNeonShaderMaterial(color, intensity = 1.0) {
          const vertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
              vUv = uv;
              vPosition = position;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `;
          
          const fragmentShader = `
            uniform float time;
            uniform vec3 color;
            uniform float intensity;
            uniform float pulseSpeed;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
              // 距離中心的距離
              vec2 center = vec2(0.5, 0.5);
              float dist = distance(vUv, center);
              
              // 脈動效果
              float pulse = sin(time * pulseSpeed) * 0.3 + 0.7;
              
              // 霓虹光暈效果
              float neonGlow = 1.0 - smoothstep(0.0, 0.5, dist);
              neonGlow = pow(neonGlow, 2.0);
              
              // 邊緣發光
              float edgeGlow = 1.0 - smoothstep(0.3, 0.5, dist);
              edgeGlow *= 0.8;
              
              // 組合效果
              float finalIntensity = (neonGlow + edgeGlow) * intensity * pulse;
              
              gl_FragColor = vec4(color, finalIntensity);
            }
          `;
          
          return new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
              time: { value: 0.0 },
              color: { value: new THREE.Color(color) },
              intensity: { value: intensity },
              pulseSpeed: { value: 2.0 }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
          });
        }

        /**
         * 創建掃光條帶 Shader Material
         */
        createScanLineShaderMaterial(color, speed = 1.0) {
          const vertexShader = `
            varying vec2 vUv;
            
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `;
          
          const fragmentShader = `
            uniform float time;
            uniform vec3 color;
            uniform float speed;
            varying vec2 vUv;
            
            void main() {
              // 掃光條帶位置
              float scanPos = mod(time * speed, 2.0) - 1.0; // -1 到 1
              float scanLine = abs(vUv.y - (scanPos + 1.0) * 0.5);
              
              // 掃光強度
              float intensity = 1.0 - smoothstep(0.0, 0.1, scanLine);
              intensity = pow(intensity, 3.0);
              
              // 頻閃效果
              float flicker = sin(time * 15.0) * 0.1 + 0.9;
              
              gl_FragColor = vec4(color, intensity * flicker);
            }
          `;
          
          return new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
              time: { value: 0.0 },
              color: { value: new THREE.Color(color) },
              speed: { value: speed }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
          });
        }

        /**
         * 創建動態光影系統
         */
        createDynamicLightingSystem() {
          console.log('初始化動態光影系統...');
          
          // 初始化動態光源容器
          this.dynamicLights = {
            pointLights: [],
            spotLights: [],
            movingLights: [],
            ambientController: null
          };
          
          // 1. 創建動態點光源系統
          this.createDynamicPointLights();
          
          // 2. 創建移動聚光燈
          this.createMovingSpotLights();
          
          // 3. 創建環境光控制器
          this.createAmbientLightController();
          
          // 4. 創建漸層光線效果
          this.createGradientLighting();
          
          console.log('動態光影系統初始化完成');
        }

        /**
         * 創建動態點光源系統
         */
        createDynamicPointLights() {
          const colors = this.getCurrentThemeColors();
          
          // 創建多個動態點光源
          const lightConfigs = [
            {
              color: colors.accessibleCard.primaryBorder,
              intensity: 0.8,
              distance: 15,
              position: { x: 5, y: 3, z: 2 },
              moveRadius: 3,
              moveSpeed: 0.5
            },
            {
              color: colors.accessibleCard.glowColor,
              intensity: 0.6,
              distance: 12,
              position: { x: -4, y: 2, z: 3 },
              moveRadius: 2,
              moveSpeed: 0.7
            },
            {
              color: colors.accessibleCard.secondaryBorder,
              intensity: 0.4,
              distance: 10,
              position: { x: 0, y: 4, z: -2 },
              moveRadius: 2.5,
              moveSpeed: 0.3
            }
          ];
          
          lightConfigs.forEach((config, index) => {
            const pointLight = new THREE.PointLight(config.color, config.intensity, config.distance);
            pointLight.position.set(config.position.x, config.position.y, config.position.z);
            
            // 添加動畫參數
            pointLight.userData = {
              originalPosition: { ...config.position },
              moveRadius: config.moveRadius,
              moveSpeed: config.moveSpeed,
              phase: index * (Math.PI / 3), // 相位偏移
              baseIntensity: config.intensity // 基礎強度
            };
            
            this.scene.add(pointLight);
            this.dynamicLights.pointLights.push(pointLight);
            
            console.log('動態點光源 ' + (index + 1) + ' 已添加到場景');
          });
        }

        /**
         * 創建移動聚光燈
         */
        createMovingSpotLights() {
          const colors = this.getCurrentThemeColors();
          
          // 主要移動聚光燈
          const mainSpotLight = new THREE.SpotLight(colors.accessibleCard.primaryBorder, 1.2, 20, Math.PI / 6, 0.3);
          mainSpotLight.position.set(0, 8, 0);
          mainSpotLight.target.position.set(0, 0, 0);
          
          // 聚光燈動畫參數
          mainSpotLight.userData = {
            moveRadius: 4,
            moveSpeed: 0.4,
            originalY: 8,
            heightVariation: 2
          };
          
          this.scene.add(mainSpotLight);
          this.scene.add(mainSpotLight.target);
          this.dynamicLights.spotLights.push(mainSpotLight);
          
          // 次要移動聚光燈
          const secondarySpotLight = new THREE.SpotLight(colors.accessibleCard.glowColor, 0.8, 15, Math.PI / 8, 0.5);
          secondarySpotLight.position.set(-6, 6, 3);
          secondarySpotLight.target.position.set(0, 0, 0);
          
          secondarySpotLight.userData = {
            moveRadius: 3,
            moveSpeed: 0.6,
            originalY: 6,
            heightVariation: 1.5
          };
          
          this.scene.add(secondarySpotLight);
          this.scene.add(secondarySpotLight.target);
          this.dynamicLights.spotLights.push(secondarySpotLight);
          
          console.log('移動聚光燈系統已創建');
        }

        /**
         * 創建環境光控制器
         */
        createAmbientLightController() {
          // 找到現有的環境光或創建新的
          let ambientLight = this.scene.children.find(child => child instanceof THREE.AmbientLight);
          
          if (!ambientLight) {
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            this.scene.add(ambientLight);
          }
          
          // 添加動態控制參數
          ambientLight.userData = {
            baseIntensity: 0.4,
            targetIntensity: 0.4,
            pulsePeriod: 8, // 8秒週期
            colorShiftEnabled: true
          };
          
          this.dynamicLights.ambientController = ambientLight;
          console.log('環境光控制器已設置');
        }

        /**
         * 創建漸層光線效果
         */
        createGradientLighting() {
          const colors = this.getCurrentThemeColors();
          
          // 創建背景漸層光源
          const gradientGeometry = new THREE.PlaneGeometry(30, 30);
          const gradientMaterial = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0.0 },
              color1: { value: new THREE.Color(colors.accessibleCard.primaryBorder) },
              color2: { value: new THREE.Color(colors.accessibleCard.glowColor) },
              intensity: { value: 0.3 }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform float time;
              uniform vec3 color1;
              uniform vec3 color2;
              uniform float intensity;
              varying vec2 vUv;
              
              void main() {
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(vUv, center);
                
                // 創建脈動漸層
                float pulse = sin(time * 0.5) * 0.3 + 0.7;
                float gradient = 1.0 - smoothstep(0.0, 0.8, dist);
                
                vec3 color = mix(color1, color2, gradient * pulse);
                float alpha = gradient * intensity * pulse;
                
                gl_FragColor = vec4(color, alpha);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
          });
          
          const gradientPlane = new THREE.Mesh(gradientGeometry, gradientMaterial);
          gradientPlane.position.set(0, 0, -10);
          gradientPlane.renderOrder = -100; // 最背景
          
          this.scene.add(gradientPlane);
          this.dynamicLights.gradientLighting = gradientPlane;
          
          console.log('漸層光線效果已創建');
        }

        /**
         * 更新動態光影系統
         */
        updateDynamicLighting(time) {
          if (!this.dynamicLights) return;
          
          // 1. 更新動態點光源
          this.dynamicLights.pointLights.forEach(light => {
            const userData = light.userData;
            const moveX = Math.cos(time * userData.moveSpeed + userData.phase) * userData.moveRadius;
            const moveZ = Math.sin(time * userData.moveSpeed + userData.phase) * userData.moveRadius;
            const moveY = Math.sin(time * userData.moveSpeed * 0.7 + userData.phase) * 0.5;
            
            light.position.set(
              userData.originalPosition.x + moveX,
              userData.originalPosition.y + moveY,
              userData.originalPosition.z + moveZ
            );
            
            // 動態強度變化
            const intensityPulse = Math.sin(time * 2 + userData.phase) * 0.2 + 0.8;
            light.intensity = light.userData.baseIntensity * intensityPulse;
          });
          
          // 2. 更新移動聚光燈
          this.dynamicLights.spotLights.forEach((light, index) => {
            const userData = light.userData;
            const phase = index * Math.PI;
            
            const moveX = Math.cos(time * userData.moveSpeed + phase) * userData.moveRadius;
            const moveZ = Math.sin(time * userData.moveSpeed + phase) * userData.moveRadius;
            const moveY = userData.originalY + Math.sin(time * 0.3 + phase) * userData.heightVariation;
            
            light.position.set(moveX, moveY, moveZ);
            
            // 聚光燈目標也輕微移動
            const targetX = Math.sin(time * 0.2 + phase) * 2;
            const targetZ = Math.cos(time * 0.3 + phase) * 2;
            light.target.position.set(targetX, 0, targetZ);
          });
          
          // 3. 更新環境光
          if (this.dynamicLights.ambientController) {
            const ambient = this.dynamicLights.ambientController;
            const userData = ambient.userData;
            
            const pulse = Math.sin(time / userData.pulsePeriod) * 0.2 + 0.8;
            ambient.intensity = userData.baseIntensity * pulse;
            
            // 顏色漸變（可選）
            if (userData.colorShiftEnabled) {
              const hue = (time * 0.1) % 1;
              ambient.color.setHSL(hue * 0.2 + 0.15, 0.3, 0.8); // 青色範圍內變化
            }
          }
          
          // 4. 更新漸層光線
          if (this.dynamicLights.gradientLighting && this.dynamicLights.gradientLighting.material.uniforms) {
            this.dynamicLights.gradientLighting.material.uniforms.time.value = time;
          }
        }

        /**
         * 創建卡片特效系統 - 無障礙增強版（動態強度）
         */
        createCardEffects(scaleFactor = 1.0, glowIntensity = 1.0, focusEnhancement = {}) {
          return this.createUnifiedCardDecorations(scaleFactor, glowIntensity, focusEnhancement);
        }

        /**
         * 統一卡片修飾元素系統 - 使用局部座標系
         */
        createUnifiedCardDecorations(scaleFactor = 1.0, glowIntensity = 1.0, focusEnhancement = {}) {
          const effects = {};
          const colors = this.getCurrentThemeColors();
          const cardColors = colors.accessibleCard;
          
          console.log('創建統一卡片修飾系統:', { scaleFactor, glowIntensity, focusEnhancement });
          
          try {
            // 建立卡片局部座標系統
            const cardLocalSystem = this.createCardLocalCoordinateSystem(scaleFactor);
            
            // 1. 霓虹掃光條帶 - 使用局部座標 (已簡化移除)
            // effects.scanLine = this.createLocalScanLine(cardLocalSystem, cardColors, glowIntensity);
            
            // 2. 統一邊緣發光系統 - 局部座標管理
            effects.edgeGlowLayers = this.createLocalEdgeGlowSystem(cardLocalSystem, cardColors, glowIntensity, focusEnhancement);
            
            // 3. 背面遮罩系統 - 局部座標
            effects.backMask = this.createLocalBackMask(cardLocalSystem, cardColors);
            
            // 4. 正面光暈框系統 - 局部座標
            effects.frontGlow = this.createLocalFrontGlow(cardLocalSystem, cardColors);
            
            // 5. 動態陰影系統 - 局部座標
            effects.shadowLayers = this.createLocalShadowSystem(cardLocalSystem, cardColors, focusEnhancement);
            
            console.log('統一卡片修飾系統創建完成 - 使用局部座標系');
            
          } catch (error) {
            console.error('卡片特效系統創建失敗:', error);
          }
          
          return effects;
        }

        /**
         * 創建卡片局部座標系統 - 增強版
         */
        createCardLocalCoordinateSystem(scaleFactor = 1.0) {
          const baseCardSize = { width: 2.0, height: 3.0 };
          const actualCardSize = { 
            width: baseCardSize.width * scaleFactor, 
            height: baseCardSize.height * scaleFactor 
          };
          
          // 計算視覺密度調整因子（多卡片時防止視覺混亂）
          const visualDensityFactor = Math.max(0.7, Math.min(1.3, 1.0 + (1.0 - scaleFactor) * 0.5));
          
          return {
            scaleFactor: scaleFactor,
            baseSize: baseCardSize,
            actualSize: actualCardSize,
            visualDensityFactor: visualDensityFactor,
            
            // 標準化局部座標 - 支援視覺密度調整
            getLocalPosition: (relativeX, relativeY, relativeZ = 0) => ({
              x: relativeX * actualCardSize.width,
              y: relativeY * actualCardSize.height,
              z: relativeZ * scaleFactor
            }),
            
            // 標準化尺寸計算 - 應用視覺密度調整
            getLocalSize: (relativeWidth, relativeHeight) => ({
              width: relativeWidth * actualCardSize.width,
              height: relativeHeight * actualCardSize.height
            }),
            
            // 智能尺寸計算 - 防止多卡片重疊
            getAdaptiveSize: (relativeWidth, relativeHeight, preventOverlap = true) => ({
              width: relativeWidth * actualCardSize.width * (preventOverlap ? visualDensityFactor : 1.0),
              height: relativeHeight * actualCardSize.height * (preventOverlap ? visualDensityFactor : 1.0)
            }),
            
            // 標準化材質屬性 - 增強適應性
            getLocalMaterialProps: (baseOpacity, baseLineWidth) => ({
              opacity: baseOpacity * (scaleFactor > 1.5 ? 0.9 : 1.0), // 大卡片稍微降低透明度
              linewidth: Math.max(1, baseLineWidth * Math.min(scaleFactor, 2.0)) // 限制線寬最大值
            }),
            
            // 計算最佳間距（用於多卡片佈局）
            getOptimalSpacing: () => ({
              x: actualCardSize.width * 1.2 * visualDensityFactor,
              y: actualCardSize.height * 0.8 * visualDensityFactor
            })
          };
        }

        /**
         * 創建局部座標掃光條帶 - 優化尺寸與位置
         */
        createLocalScanLine(localSystem, cardColors, glowIntensity) {
          // 動態調整掃光條帶尺寸，確保在不同卡片尺寸下保持視覺一致性
          const optimalWidth = Math.min(1.15, 1.0 + (localSystem.scaleFactor - 1.0) * 0.3); // 動態寬度調整
          const optimalHeight = Math.max(0.025, 0.04 / localSystem.scaleFactor); // 逆向高度調整，避免過粗
          
          const size = localSystem.getLocalSize(optimalWidth, optimalHeight);
          const position = localSystem.getLocalPosition(0, 0, 0.005);
          
          const geometry = new THREE.PlaneGeometry(size.width, size.height);
          const material = this.createScanLineShaderMaterial(0xff00ff, 0.8 * glowIntensity);
          
          const scanLine = new THREE.Mesh(geometry, material);
          scanLine.position.set(position.x, position.y, position.z);
          scanLine.renderOrder = 600;
          
          return scanLine;
        }

        /**
         * 創建局部座標邊緣發光系統 - 優化尺寸與位置
         */
        createLocalEdgeGlowSystem(localSystem, cardColors, glowIntensity, focusEnhancement) {
          const edgeGlowLayers = [];
          const baseOpacity = Math.min(1.0, glowIntensity);
          
          // 動態調整邊緣發光層級，確保多卡片排列時不重疊
          const scaleFactor = localSystem.scaleFactor;
          const densityAdjustment = Math.max(0.8, 1.2 - scaleFactor * 0.1); // 密度調整因子
          
          // 邊緣發光層配置 - 優化相對尺寸和間距
          const layerConfigs = [
            { 
              name: 'outer', 
              relativeSize: { 
                width: 1.25 * densityAdjustment, 
                height: 1.15 * densityAdjustment 
              }, 
              relativeZ: 0.006, 
              color: cardColors.primaryBorder, 
              opacity: baseOpacity * glowIntensity, 
              linewidth: Math.max(2, 4 * densityAdjustment),
              renderOrder: 104 
            },
            { 
              name: 'middle', 
              relativeSize: { 
                width: 1.15 * densityAdjustment, 
                height: 1.10 * densityAdjustment 
              }, 
              relativeZ: 0.005, 
              color: cardColors.secondaryBorder, 
              opacity: 0.9 * glowIntensity, 
              linewidth: Math.max(1.5, 3 * densityAdjustment),
              renderOrder: 103 
            },
            { 
              name: 'inner', 
              relativeSize: { 
                width: 1.08 * densityAdjustment, 
                height: 1.05 * densityAdjustment 
              }, 
              relativeZ: 0.004, 
              color: cardColors.glowColor, 
              opacity: 0.7 * glowIntensity, 
              linewidth: Math.max(1, 2 * densityAdjustment),
              renderOrder: 102 
            }
          ];
          
          layerConfigs.forEach(config => {
            const size = localSystem.getAdaptiveSize(config.relativeSize.width, config.relativeSize.height, true);
            const position = localSystem.getLocalPosition(0, 0, config.relativeZ);
            const materialProps = localSystem.getLocalMaterialProps(config.opacity, config.linewidth);
            
            const geometry = new THREE.EdgesGeometry(new THREE.PlaneGeometry(size.width, size.height));
            const material = new THREE.LineBasicMaterial({
              color: config.color,
              transparent: true,
              opacity: materialProps.opacity,
              linewidth: materialProps.linewidth,
              blending: THREE.AdditiveBlending
            });
            
            const edgeGlow = new THREE.LineSegments(geometry, material);
            edgeGlow.position.set(position.x, position.y, position.z);
            edgeGlow.renderOrder = config.renderOrder;
            
            edgeGlowLayers.push(edgeGlow);
          });
          
          return edgeGlowLayers;
        }

        /**
         * 創建局部座標背面遮罩
         */
        createLocalBackMask(localSystem, cardColors) {
          const size = localSystem.getLocalSize(1.025, 1.017); // 稍大於卡片的遮罩
          const position = localSystem.getLocalPosition(0, 0, -0.001);
          
          const geometry = new THREE.PlaneGeometry(size.width, size.height);
          const material = new THREE.MeshBasicMaterial({
            color: cardColors.backOverlay,
            transparent: true,
            opacity: 0.6,
            side: THREE.BackSide
          });
          
          const backMask = new THREE.Mesh(geometry, material);
          backMask.position.set(position.x, position.y, position.z);
          backMask.renderOrder = 95;
          
          return backMask;
        }

        /**
         * 創建局部座標正面光暈框
         */
        createLocalFrontGlow(localSystem, cardColors) {
          const size = localSystem.getLocalSize(1.25, 1.167); // 125%寬度，116.7%高度
          const position = localSystem.getLocalPosition(0, 0, -0.0005);
          
          const geometry = new THREE.PlaneGeometry(size.width, size.height);
          const material = new THREE.MeshBasicMaterial({
            color: cardColors.frontColor,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
          });
          
          const frontGlow = new THREE.Mesh(geometry, material);
          frontGlow.position.set(position.x, position.y, position.z);
          frontGlow.renderOrder = 96;
          
          return frontGlow;
        }

        /**
         * 創建局部座標陰影系統 - 優化尺寸與位置
         */
        createLocalShadowSystem(localSystem, cardColors, focusEnhancement) {
          const shadowLayers = [];
          const shadowIntensity = focusEnhancement.shadowIntensity || 1.0;
          const scaleFactor = localSystem.scaleFactor;
          
          // 動態調整陰影偏移，確保在不同卡片尺寸下保持合適的視覺深度
          const shadowOffsetScale = Math.max(0.6, 1.0 - (scaleFactor - 1.0) * 0.2); // 大卡片減少陰影偏移
          const shadowSizeScale = Math.min(1.1, 0.9 + scaleFactor * 0.1); // 動態調整陰影尺寸
          
          // 陰影層配置 - 使用相對定位與動態調整
          const shadowConfigs = [
            {
              name: 'main',
              relativeSize: { 
                width: 1.0 * shadowSizeScale, 
                height: 0.933 * shadowSizeScale 
              },
              relativePosition: { 
                x: 0.075 * shadowOffsetScale, 
                y: -0.05 * shadowOffsetScale, 
                z: -0.0025 
              },
              opacity: cardColors.shadowIntensity * shadowIntensity,
              renderOrder: 93
            },
            {
              name: 'soft',
              relativeSize: { 
                width: 1.1 * shadowSizeScale, 
                height: 1.0 * shadowSizeScale 
              },
              relativePosition: { 
                x: 0.1 * shadowOffsetScale, 
                y: -0.067 * shadowOffsetScale, 
                z: -0.003 
              },
              opacity: cardColors.shadowIntensity * 0.4 * shadowIntensity,
              renderOrder: 92
            }
          ];
          
          shadowConfigs.forEach(config => {
            const size = localSystem.getLocalSize(config.relativeSize.width, config.relativeSize.height);
            const position = localSystem.getLocalPosition(
              config.relativePosition.x, 
              config.relativePosition.y, 
              config.relativePosition.z
            );
            
            const geometry = new THREE.PlaneGeometry(size.width, size.height);
            const material = new THREE.MeshBasicMaterial({
              color: cardColors.shadowColor,
              transparent: true,
              opacity: config.opacity,
              side: THREE.DoubleSide
            });
            
            const shadow = new THREE.Mesh(geometry, material);
            shadow.position.set(position.x, position.y, position.z);
            shadow.renderOrder = config.renderOrder;
            
            shadowLayers.push(shadow);
          });
          
          return shadowLayers;
        }

        /**
         * 觸發卡片落地光暈特效
         */
        triggerCardLandingEffect(card) {
          if (!card.userData.effects || !card.userData.effects.aura) return;
          
          const aura = card.userData.effects.aura;
          const startTime = Date.now();
          const duration = 1000; // 1秒動畫
          
          console.log('觸發卡片落地光暈特效:', card.userData.name);
          
          const animateAura = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 光暈放大並淡出
            const scale = 1 + progress * 2; // 從1倍放大到3倍
            const opacity = (1 - progress) * 0.8; // 從0.8淡出到0
            
            aura.scale.setScalar(scale);
            aura.material.opacity = opacity;
            
            if (progress < 1) {
              requestAnimationFrame(animateAura);
            } else {
              // 動畫結束，重置
              aura.scale.setScalar(1);
              aura.material.opacity = 0;
            }
          };
          
          animateAura();
        }

        /**
         * 觸發卡片翻轉掃光特效 (已簡化移除)
         */
        /*
        triggerCardFlipScanEffect(card) {
          if (!card.userData.effects) return;
          
          const scanLine = card.userData.effects.scanLine;
          const edgeGlow = card.userData.effects.edgeGlow;
          
          if (!scanLine || !edgeGlow) return;
          
          const startTime = Date.now();
          const duration = 500; // 0.5秒掃光
          
          console.log('觸發卡片翻轉掃光特效:', card.userData.name);
          
          const animateScan = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 掃光條從上到下移動
            const yPos = 1.5 - progress * 3; // 從頂部(1.5)移動到底部(-1.5)
            scanLine.position.y = yPos;
            scanLine.material.opacity = Math.sin(progress * Math.PI) * 0.8; // 先增強後淡出
            
            // 邊緣發光逐漸亮起
            edgeGlow.material.opacity = Math.sin(progress * Math.PI) * 0.6;
            
            if (progress < 1) {
              requestAnimationFrame(animateScan);
            } else {
              // 動畫結束，重置
              scanLine.material.opacity = 0;
              edgeGlow.material.opacity = 0;
            }
          };
          
          animateScan();
        }
        */

        /**
         * 觸發增強卡片落地反射效果
         */
        triggerEnhancedCardLandingEffect(card) {
          if (!card.userData.animationEffects || !card.userData.animationEffects.landingReflection) return;
          
          const reflection = card.userData.animationEffects.landingReflection;
          const startTime = Date.now();
          const duration = 1500; // 1.5秒動畫
          
          console.log('觸發增強卡片落地反射效果:', card.userData.name);
          
          // 標記動畫狀態
          card.userData.animationState.isLanding = true;
          card.userData.animationState.landingProgress = 0;
          
          const animateReflection = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 更新動畫狀態
            card.userData.animationState.landingProgress = progress;
            
            // 反射強度變化 - 強開始，逐漸減弱
            const intensity = Math.max(0, (1 - progress) * 1.5) * Math.sin(progress * Math.PI);
            
            // 更新shader uniforms
            if (reflection.material.uniforms) {
              reflection.material.uniforms.time.value = elapsed * 0.001;
              reflection.material.uniforms.intensity.value = intensity;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animateReflection);
            } else {
              // 動畫結束，重置
              card.userData.animationState.isLanding = false;
              card.userData.animationState.landingProgress = 0;
              if (reflection.material.uniforms) {
                reflection.material.uniforms.intensity.value = 0;
              }
            }
          };
          
          animateReflection();
        }

        /**
         * 觸發增強卡片翻轉掃光效果
         */
        /**
         * 觸發增強卡片翻轉掃光效果 (已簡化移除)
         */
        /*
        triggerEnhancedCardFlipEffect(card) {
          if (!card.userData.animationEffects || !card.userData.animationEffects.flipSweepLight) return;
          
          const sweep = card.userData.animationEffects.flipSweepLight;
          const enhancedGlow = card.userData.animationEffects.enhancedEdgeGlow;
          const startTime = Date.now();
          const duration = 800; // 0.8秒動畫
          
          console.log('觸發增強卡片翻轉掃光效果:', card.userData.name);
          
          // 標記動畫狀態
          card.userData.animationState.isFlipping = true;
          card.userData.animationState.flipProgress = 0;
          card.userData.animationState.lastFlipTime = startTime;
          
          const animateFlip = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 更新動畫狀態
            card.userData.animationState.flipProgress = progress;
            
            // 掃光進度 - 從0度掃到360度
            const sweepAngle = progress * Math.PI * 2;
            const sweepIntensity = Math.sin(progress * Math.PI) * 1.2; // 中間最強
            
            // 邊緣發光強度增強
            const edgeGlowBoost = 1.0 + Math.sin(progress * Math.PI * 2) * 0.5;
            
            // 更新shader uniforms
            if (sweep.material.uniforms) {
              sweep.material.uniforms.time.value = elapsed * 0.001;
              sweep.material.uniforms.progress.value = sweepIntensity;
              sweep.material.uniforms.sweepAngle.value = sweepAngle;
            }
            
            if (enhancedGlow && enhancedGlow.material.uniforms) {
              enhancedGlow.material.uniforms.time.value = elapsed * 0.001;
              enhancedGlow.material.uniforms.intensity.value = edgeGlowBoost;
            }
            
            if (progress < 1) {
              requestAnimationFrame(animateFlip);
            } else {
              // 動畫結束，重置
              card.userData.animationState.isFlipping = false;
              card.userData.animationState.flipProgress = 0;
              
              if (sweep.material.uniforms) {
                sweep.material.uniforms.progress.value = 0;
              }
              if (enhancedGlow && enhancedGlow.material.uniforms) {
                enhancedGlow.material.uniforms.intensity.value = 1.0;
              }
            }
          };
          
          animateFlip();
        }
        */

        /**
         * 更新卡片增強動畫效果
         */
        updateCardEnhancedAnimations(card, time) {
          if (!card.userData.animationEffects) return;
          
          const effects = card.userData.animationEffects;
          const animState = card.userData.animationState;
          
          // 持續更新增強邊緣發光
          if (effects.enhancedEdgeGlow && effects.enhancedEdgeGlow.material.uniforms) {
            const baseIntensity = animState.isFlipping ? 1.5 : 1.0;
            effects.enhancedEdgeGlow.material.uniforms.time.value = time;
            
            if (!animState.isFlipping) {
              effects.enhancedEdgeGlow.material.uniforms.intensity.value = baseIntensity;
            }
          }
          
          // 持續更新落地反射（在非動畫狀態下保持微弱反射）(已簡化移除)
          /*
          if (effects.landingReflection && effects.landingReflection.material.uniforms) {
            effects.landingReflection.material.uniforms.time.value = time;
            
            if (!animState.isLanding && card.userData.settled) {
              // 微弱的持續反射效果
              const subtleReflection = Math.sin(time * 0.5) * 0.05 + 0.05;
              effects.landingReflection.material.uniforms.intensity.value = subtleReflection;
            }
          }
          */
          
          // 翻轉掃光在非動畫狀態下保持靜止 (已簡化移除)
          /*
          if (effects.flipSweepLight && effects.flipSweepLight.material.uniforms && !animState.isFlipping) {
            effects.flipSweepLight.material.uniforms.time.value = time;
            effects.flipSweepLight.material.uniforms.progress.value = 0;
          }
          */
        }

        /**
         * 創建無障礙文字貼圖 - WCAG對比度標準
         */
        createAccessibleTextTexture(text, cardColors) {
          try {
            console.log('創建無障礙文字貼圖:', text);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 高解析度畫布
            canvas.width = 512;
            canvas.height = 768;
            
            // 使用無障礙背景色
            ctx.fillStyle = `#${cardColors.backBackground.toString(16).padStart(6, '0')}`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製高對比度邊框 - 雙層設計
            // 外層邊框
            ctx.strokeStyle = `#${cardColors.primaryBorder.toString(16).padStart(6, '0')}`;
            ctx.lineWidth = 6;
            ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
            
            // 內層邊框
            ctx.strokeStyle = `#${cardColors.secondaryBorder.toString(16).padStart(6, '0')}`;
            ctx.lineWidth = 2;
            ctx.strokeRect(12, 12, canvas.width - 24, canvas.height - 24);
            
            // 無障礙文字樣式
            ctx.fillStyle = `#${cardColors.backText.toString(16).padStart(6, '0')}`;
            ctx.font = 'bold 84px "Noto Sans TC", "Microsoft JhengHei", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // 增強文字陰影提升可讀性
            ctx.shadowColor = `#${cardColors.shadowColor.toString(16).padStart(6, '0')}`;
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // 繪製主文字
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // 添加文字描邊增強對比
            ctx.strokeStyle = ctx.shadowColor;
            ctx.lineWidth = 2;
            ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
            
            // 添加光暈效果
            ctx.shadowBlur = 8;
            ctx.shadowColor = `#${cardColors.glowColor.toString(16).padStart(6, '0')}`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // 創建貼圖並設定正確的方向
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.flipY = false;
            
            // 修正貼圖方向
            texture.center = new THREE.Vector2(0.5, 0.5);
            texture.rotation = Math.PI; // 180度旋轉修正方向
            
            texture.needsUpdate = true;
            
            console.log('無障礙文字貼圖創建成功:', {
              text: text,
              size: `${canvas.width}x${canvas.height}`,
              font: ctx.font,
              backgroundColor: ctx.fillStyle,
              textColor: `#${cardColors.backText.toString(16).padStart(6, '0')}`
            });
            
            return texture;
            
          } catch (error) {
            console.error('無障礙文字貼圖創建失敗:', error);
            
            // 創建無障礙後備貼圖 - WCAG AAA級對比度
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 768;
            
            // 使用WCAG AAA級高對比色 (7:1對比度)
            ctx.fillStyle = '#000000'; // 純黑背景
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製高對比度邊框
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 6;
            ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
            
            // 使用純白文字配黑色描邊提升可讀性
            ctx.fillStyle = '#ffffff'; // 純白文字
            ctx.font = 'bold 64px "Noto Sans TC", "Microsoft JhengHei", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // 添加文字陰影增強可讀性
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            ctx.fillText('載入錯誤', canvas.width / 2, canvas.height / 2);
            
            // 添加文字描邊
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText('載入錯誤', canvas.width / 2, canvas.height / 2);
            
            return new THREE.CanvasTexture(canvas);
          }
        }

        createTextTexture(text) {
          // 重新導向到無障礙版本
          const colors = this.getCurrentThemeColors();
          return this.createAccessibleTextTexture(text, colors.accessibleCard);
        }

        async startAnimation(winners, callback) {
          console.log('startAnimation called with winners:', winners);
          if (this.isAnimating) return;
          
          this.isAnimating = true;
          this.animationCallback = callback;
          this.cards = [];
          this.frameCount = 0; // 重置幀計數器
          this.timeoutHandled = false; // 重置超時處理標誌
          this.clickHandlingEnabled = false; // 重置點擊處理標誌
          
          console.log('Initializing Three.js...');
          if (!this.init()) {
            console.error('Three.js initialization failed');
            this.isAnimating = false;
            if (callback) callback();
            return;
          }

          // 保持容器隱藏，避免覆蓋畫面問題
          console.log('Three.js container 已停用，使用 DOM 卡片展示');
          // this.container.style.display = 'block'; // 已註解，避免覆蓋問題
          
          // 動態調整性能設定
          this.adjustPerformanceSettings(winners.length);
          
          // 根據卡片數量智能調節背景亮度
          this.adjustBackgroundBrightness(winners.length);
          
          const positions = this.generatePositions(winners.length);
          const { cardScale, scaleFactor, glowIntensity, focusEnhancement } = this.calculateDynamicLayout(winners.length);
          
          winners.forEach((winner, index) => {
            const card = this.createCard(winner, scaleFactor, glowIntensity, focusEnhancement);
            
            // 應用動態卡片縮放（變換縮放）
            card.scale.setScalar(cardScale);
            
            const startPos = {
              x: (Math.random() - 0.5) * 6,  // Smaller random spread
              y: 10 + Math.random() * 2,     // Higher starting position
              z: 0
            };
            
            card.position.set(startPos.x, startPos.y, startPos.z);
            
            card.userData.targetPosition = positions[index].clone();
            card.userData.velocity = {
              x: (Math.random() - 0.5) * 0.02, // 減慢水平運動
              y: -0.02 - Math.random() * 0.01, // 大幅減慢垂直速度
              z: 0
            };
            card.userData.rotationVelocity = {
              x: (Math.random() - 0.5) * 0.05,
              y: (Math.random() - 0.5) * 0.05,
              z: (Math.random() - 0.5) * 0.05
            };
            
            console.log(`Card ${index} (${winner}):`);
            console.log('  Start position:', startPos);
            console.log('  Target position:', positions[index]);
            console.log('  Target Y after adjustment:', card.userData.targetPosition.y);
            console.log('  Velocity:', card.userData.velocity);
            console.log('  Distance to fall:', startPos.y - card.userData.targetPosition.y);
            
            this.scene.add(card);
            this.cards.push(card);
          });

          console.log('All cards added to scene. Total cards:', this.cards.length);
          console.log('Scene children count:', this.scene.children.length);

          this.animate();
        }

        generatePositions(count) {
          const positions = [];
          
          // 動態調整卡片尺寸和間距
          const { cardScale, spacing, layout, scaleFactor, focusEnhancement } = this.calculateDynamicLayout(count);
          
          console.log(`生成 ${count} 張卡片的 ${layout} 排列佈局`);
          
          switch (layout) {
            case 'single':
              // 單張卡片：完美居中，略微前移突出重點
              positions.push(new THREE.Vector3(0, 0, 0.5));
              break;
              
            case 'linear':
              // 2-3張卡片：優化居中橫向排列，間距更舒適
              const interactionBoost = focusEnhancement.interactionBoost || 1.0;
              const adjustedSpacing = spacing.x * interactionBoost; // 少量卡片時加大間距
              
              for (let i = 0; i < count; i++) {
                const x = (i - (count - 1) / 2) * adjustedSpacing;
                // 添加微妙的弧形排列，增加視覺層次
                const arcOffset = count > 2 ? Math.sin((i / (count - 1)) * Math.PI) * 0.3 : 0;
                const z = arcOffset; // 中間卡片稍微前移
                positions.push(new THREE.Vector3(x, 0, z));
              }
              break;
              
            case 'grid':
              // 4-9張卡片：優化網格排列，確保視覺平衡
              let cols, rows;
              
              // 智能計算最佳行列配置
              if (count === 4) {
                cols = 2; rows = 2; // 2x2 正方形
              } else if (count === 5) {
                cols = 3; rows = 2; // 3x2 佈局（第二行2張居中）
              } else if (count === 6) {
                cols = 3; rows = 2; // 3x2 完美填滿
              } else {
                cols = Math.ceil(Math.sqrt(count));
                rows = Math.ceil(count / cols);
              }
              
              for (let i = 0; i < count; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                // 針對不完整行進行居中調整
                let x, y;
                if (count === 5 && row === 1) {
                  // 5張卡片：第二行2張卡片居中
                  const lastRowCount = count - cols;
                  const lastRowCol = col;
                  x = (lastRowCol - (lastRowCount - 1) / 2) * spacing.x;
                } else {
                  x = (col - (cols - 1) / 2) * spacing.x;
                }
                
                y = ((rows - 1) / 2 - row) * spacing.y;
                
                // 添加輕微的隨機偏移，增加自然感
                const randomOffset = {
                  x: (Math.random() - 0.5) * 0.1,
                  y: (Math.random() - 0.5) * 0.1,
                  z: Math.random() * 0.1
                };
                
                positions.push(new THREE.Vector3(
                  x + randomOffset.x, 
                  y + randomOffset.y, 
                  randomOffset.z
                ));
              }
              break;
              
            case 'circular':
              // 10+張卡片：環狀排列
              const radius = spacing.radius;
              const angleStep = (Math.PI * 2) / count;
              
              for (let i = 0; i < count; i++) {
                const angle = i * angleStep - Math.PI / 2; // 從頂部開始
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                positions.push(new THREE.Vector3(x, y, 0));
              }
              break;
              
            case 'spiral':
              // 超多張卡片：螺旋排列
              const spiralSpacing = spacing.spiral;
              const spiralTurns = Math.ceil(count / 8); // 每圈8張卡片
              
              for (let i = 0; i < count; i++) {
                const t = i / count;
                const angle = t * spiralTurns * Math.PI * 2;
                const r = spiralSpacing * (1 + t * 2);
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                positions.push(new THREE.Vector3(x, y, 0));
              }
              break;
          }
          
          console.log(`Generated ${layout} layout for ${count} cards:`, {
            cardScale,
            spacing,
            positions: positions.length
          });
          
          return positions;
        }

        /**
         * 計算動態佈局參數
         */
        calculateDynamicLayout(count) {
          console.log(`計算動態佈局，卡片數量: ${count}`);
          
          const config = this.dynamicLayoutConfig;
          const sizeFactors = config.sizeFactors;
          const glowFactors = config.glowFactors;
          const spacingFactors = config.spacingFactors;
          
          let cardScale = 1.0;
          let spacing = { x: 3, y: 2.5 };
          let layout = 'grid';
          let scaleFactor = sizeFactors.standard; // 使用配置的縮放因子
          let glowIntensity = 1.0;
          
          // 1. 卡片尺寸動態調整演算法（使用可配置參數）
          if (count <= 3) {
            // 少量卡片：顯著放大
            scaleFactor = count === 1 ? sizeFactors.single : 
                         count === 2 ? sizeFactors.dual : sizeFactors.triple;
            cardScale = 1.3; // 額外的變換縮放
            glowIntensity = glowFactors.maxIntensity - (count - 1) * 0.3; // 光暈隨數量減少而增強
            layout = count === 1 ? 'single' : 'linear';
            
            // 使用配置的間距
            spacing = count === 1 ? spacingFactors.singleCard : 
                     count === 2 ? spacingFactors.dualCard : 
                     spacingFactors.tripleCard;
                     
          } else if (count >= 4 && count <= 6) {
            // 中等數量：適度放大
            scaleFactor = 1.5 - (count - 4) * 0.1; // 1.5 到 1.3
            cardScale = 1.2 - (count - 4) * 0.05; // 1.2 到 1.1
            glowIntensity = 1.3 - (count - 4) * 0.1; // 1.3 到 1.0
            layout = 'grid';
            
            // 動態調整間距
            spacing = {
              x: 4.0 - (count - 4) * 0.2, // 4.0 到 3.6
              y: 3.0 - (count - 4) * 0.1  // 3.0 到 2.8
            };
            
          } else if (count >= 7 && count <= 12) {
            // 較多卡片：標準尺寸
            scaleFactor = 1.0;
            cardScale = Math.max(0.9, 1.1 - (count - 7) * 0.03); // 逐漸縮小
            glowIntensity = 1.0;
            layout = 'grid';
            
            spacing = {
              x: Math.max(2.5, 3.5 - (count - 7) * 0.15),
              y: Math.max(2.0, 2.8 - (count - 7) * 0.1)
            };
            
          } else if (count <= 20) {
            // 大量卡片：圓形排列
            scaleFactor = 0.9;
            cardScale = Math.max(0.7, 1.0 - (count - 13) * 0.03);
            glowIntensity = 0.9;
            layout = 'circular';
            
            spacing = {
              radius: Math.max(10, 6 + count * 0.4)
            };
            
          } else {
            // 超多卡片：螺旋排列
            scaleFactor = 0.8;
            cardScale = Math.max(0.5, 0.8 - (count - 21) * 0.02);
            glowIntensity = 0.8;
            layout = 'spiral';
            
            spacing = {
              spiral: Math.max(1.5, 2.2 - (count - 21) * 0.03)
            };
          }
          
          // 2. 視覺焦點強化係數計算
          const focusEnhancement = {
            shadowIntensity: Math.min(1.5, glowIntensity * 1.2),
            pulseFrequency: Math.max(0.8, 2.0 - count * 0.1), // 少量卡片脈動更慢
            interactionBoost: count <= 3 ? 1.5 : 1.0 // 少量卡片互動加強
          };
          
          console.log('動態佈局計算結果:', {
            count,
            scaleFactor,
            cardScale,
            glowIntensity,
            layout,
            spacing,
            focusEnhancement
          });
          
          return { 
            cardScale, 
            spacing, 
            layout, 
            scaleFactor, 
            glowIntensity, 
            focusEnhancement 
          };
        }

        animate() {
          if (!this.isAnimating) return;
          
          requestAnimationFrame(() => this.animate());
          
          let allSettled = true;
          
          // Add frame counter for debugging (but don't spam console)
          if (!this.frameCount) this.frameCount = 0;
          this.frameCount++;
          
          // 超時強制落地機制 - 避免卡片長時間飄浮
          const maxFrames = 1200; // 20秒超時 (60fps * 20)
          if (this.frameCount > maxFrames && !this.timeoutHandled) {
            console.log('動畫超時，強制所有卡片落地');
            this.timeoutHandled = true; // 防止重複觸發
            this.cards.forEach((card, index) => {
              if (!card.userData.settled) {
                card.position.copy(card.userData.targetPosition);
                card.rotation.set(0, 0, 0);
                card.userData.settled = true;
                card.userData.clickable = true;
                card.renderOrder = 10;
                console.log(`強制落地：卡片 ${index}`);
              }
            });
          }
          
          // 減少輸出頻率
          if (this.frameCount % 120 === 0) { // 每2秒輸出一次
            console.log(`動畫進行中，第${this.frameCount}幀，移動中的卡片: ${this.cards.filter(c => !c.userData.settled).length}張`);
          }
          
          this.cards.forEach((card, index) => {
            if (!card.userData.settled) {
              const oldPos = card.position.y;
              card.position.add(card.userData.velocity);
              card.rotation.x += card.userData.rotationVelocity.x;
              card.rotation.y += card.userData.rotationVelocity.y;
              card.rotation.z += card.userData.rotationVelocity.z;
              
              card.userData.velocity.y += -0.002; // 減慢重力加速度
              
              // 只在關鍵時刻輸出除錯資訊
              if (this.frameCount === 1 || this.frameCount === 30 || this.frameCount % 60 === 0) {
                console.log(`動畫第${this.frameCount}幀 - 卡片${index}: Y=${card.position.y.toFixed(1)}, 目標=${card.userData.targetPosition.y.toFixed(1)}, 速度=${card.userData.velocity.y.toFixed(3)}`);
              }
              
              // 改善落地判斷 - 增加緩衝區域避免穿透
              const distanceToTarget = card.position.y - card.userData.targetPosition.y;
              const tolerance = 0.1; // 緩衝區域
              
              if (distanceToTarget <= tolerance) {
                // 位置校正：確保卡片精確落在目標位置
                card.position.copy(card.userData.targetPosition);
                card.rotation.set(0, 0, 0);
                card.userData.settled = true;
                card.userData.clickable = true;
                
                // 設定渲染順序，確保卡片在正確層級
                card.renderOrder = 10;
                
                // 觸發增強卡片落地反射特效
                this.triggerEnhancedCardLandingEffect(card);
                
                console.log(`卡片 ${index} (${card.userData.name}) 已穩定落地`);
              } else {
                allSettled = false;
                
                // 除錯輸出
                if (this.frameCount % 120 === 0) {
                  console.log(`卡片 ${index} 下落中: Y=${card.position.y.toFixed(2)}, 目標=${card.userData.targetPosition.y.toFixed(2)}, 距離=${distanceToTarget.toFixed(2)}`);
                }
              }
            }
          });
          
          if (allSettled && !this.allCardsFlipped() && !this.clickHandlingEnabled) {
            console.log('All cards settled, enabling click handling');
            this.enableClickHandling();
            this.clickHandlingEnabled = true; // 防止重複調用
          }
          
          // 更新賽博龐克背景效果 - 粒子系統已暫時移除
          // this.updateParticles();
          
          // 性能監控計數
          if (this.performanceStats) {
            this.performanceStats.frameCount++;
          }
          
          this.renderer.render(this.scene, this.camera);
          
          if (allSettled && this.allCardsFlipped()) {
            console.log('All cards flipped, ending animation in 2 seconds');
            setTimeout(() => {
              this.endAnimation();
            }, 2000);
          }
        }

        enableClickHandling() {
          if (this.clickHandlerAdded) return;
          
          this.clickHandlerAdded = true;
          this.renderer.domElement.addEventListener('click', (event) => this.onCanvasClick(event), false);
        }

        /**
         * 優化的點擊事件處理 - 加入防抖和鎖定機制
         */
        onCanvasClick(event) {
          // 防抖機制：檢查最後點擊時間
          const now = Date.now();
          if (!this.lastClickTime) this.lastClickTime = 0;
          
          const timeSinceLastClick = now - this.lastClickTime;
          if (timeSinceLastClick < 300) { // 300ms防抖間隔
            console.log('點擊過快，忽略 (防抖機制)');
            return;
          }
          
          this.lastClickTime = now;
          
          // 檢查點擊處理是否啟用
          if (!this.clickHandlingEnabled) {
            console.log('點擊處理未啟用');
            return;
          }
          
          // 計算鼠標位置
          const rect = this.renderer.domElement.getBoundingClientRect();
          const mouse = new THREE.Vector2();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          // 使用共享的 raycaster 避免重複創建
          if (!this.clickRaycaster) {
            this.clickRaycaster = new THREE.Raycaster();
          }
          this.clickRaycaster.setFromCamera(mouse, this.camera);
          
          // 只檢測已穩定且可點擊的卡片
          const clickableCards = this.cards.filter(card => 
            card.userData.settled && 
            card.userData.clickable && 
            !card.userData.isFlipped &&
            !card.userData.isFlipping  // 排除正在翻轉的卡片
          );
          
          if (clickableCards.length === 0) {
            console.log('沒有可點擊的卡片');
            return;
          }
          
          const intersects = this.clickRaycaster.intersectObjects(clickableCards);
          
          if (intersects.length > 0) {
            const card = intersects[0].object;
            
            // 雙重檢查卡片狀態
            if (card.userData.isFlipped || card.userData.isFlipping || !card.userData.clickable) {
              console.log('卡片狀態不允許翻轉:', card.userData.name);
              return;
            }
            
            console.log('點擊卡片:', card.userData.name);
            this.flipCard(card);
            
            // 點擊成功後的統計
            const remainingCards = this.cards.filter(c => !c.userData.isFlipped && !c.userData.isFlipping).length;
            console.log('剩餘可翻轉卡片:', remainingCards);
            
          } else {
            console.log('點擊位置無有效卡片', {
              mousePos: mouse,
              clickableCards: clickableCards.length,
              settledCards: this.cards.filter(c => c.userData.settled).length
            });
          }
        }

        /**
         * 重設翻卡動畫 - 簡化穩定版本
         */
        flipCard(card) {
          // 防抖機制：避免重複觸發
          if (card.userData.isFlipping || card.userData.isFlipped) {
            console.log('卡片已在翻轉或已翻轉，忽略點擊');
            return;
          }
          
          // 設置動畫狀態
          card.userData.isFlipping = true;
          card.userData.clickable = false;
          
          const duration = 600; // 稍微延長動畫時間使其更穩定
          const startTime = Date.now();
          let materialSwitched = false;
          
          console.log('開始翻卡動畫:', card.userData.name);
          
          const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 使用 easeInOutQuad 曲線讓動畫更流暢
            const easeProgress = progress < 0.5 
              ? 2 * progress * progress 
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            // 設置Y軸旋轉
            card.rotation.y = easeProgress * Math.PI;
            
            // 在90度時切換材質，避免閃爍
            if (progress >= 0.5 && !materialSwitched) {
              card.material = card.userData.backMaterial;
              materialSwitched = true;
              console.log('切換到背面材質:', card.userData.name);
            }
            
            // 動畫完成處理
            if (progress >= 1) {
              // 確保最終狀態正確
              card.rotation.y = Math.PI;
              card.material = card.userData.backMaterial;
              card.userData.isFlipped = true;
              card.userData.isFlipping = false;
              
              console.log('翻卡動畫完成:', card.userData.name);
              return; // 結束動畫
            }
            
            // 繼續動畫
            requestAnimationFrame(animate);
          };
          
          // 開始動畫
          requestAnimationFrame(animate);
        }

        allCardsFlipped() {
          return this.cards.every(card => card.userData.isFlipped);
        }

        endAnimation() {
          this.isAnimating = false;
          this.container.style.display = 'none';
          
          // 重置所有狀態標誌
          this.frameCount = 0;
          this.timeoutHandled = false;
          this.clickHandlingEnabled = false;
          
          // 清理卡片
          this.cards.forEach(card => {
            this.scene.remove(card);
          });
          this.cards = [];
          
          // 清理賽博龐克背景效果 (但保留以供下次使用)
          // 注意：不清理背景和粒子，讓它們可以在下次動畫中重複使用
          
          if (this.clickHandlerAdded && this.renderer && this.renderer.domElement) {
            this.renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
            this.clickHandlerAdded = false;
          }
          
          if (this.renderer && this.container) {
            this.container.removeChild(this.renderer.domElement);
            this.renderer.dispose();
            this.renderer = null;
          }
          
          // 重置場景以供下次使用
          this.scene = null;
          this.camera = null;
          
          if (this.animationCallback) {
            this.animationCallback();
          }
        }

        // === 進階3D功能實現 ===
        
        /**
         * 創建賽博龐克風格的MODA商標背景紋理 - 優化版本
         */
        createModaSvgTexture() {
          console.log('創建賽博龐克MODA背景紋理 - 優化版本...');
          
          try {
            // 載入實際商標圖片並進行低飽和度處理
            const loader = new THREE.TextureLoader();
            this.logoTexture = loader.load('./logo.jpg', 
              (texture) => {
                console.log('MODA商標圖片載入成功，開始進行低飽和度處理...');
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                
                // 進行圖像後處理以實現低飽和度和模糊效果
                this.processLogoTexture(texture);
              },
              undefined,
              (error) => {
                console.error('MODA商標圖片載入失敗:', error);
                // 創建後備商標紋理
                this.createFallbackLogoTexture();
              }
            );

            // 創建賽博龐克風格的SVG背景
            const svgData = `
              <svg width="1024" height="1024" xmlns="http://www.w3.org/2000/svg">
                <defs>
                  <!-- 賽博龐克漸變 -->
                  <linearGradient id="cyberpunkGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#0a0a0a;stop-opacity:1" />
                    <stop offset="25%" style="stop-color:#1a0033;stop-opacity:0.9" />
                    <stop offset="50%" style="stop-color:#000066;stop-opacity:0.8" />
                    <stop offset="75%" style="stop-color:#330066;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#660099;stop-opacity:1" />
                  </linearGradient>
                  
                  <!-- 霓虹光暈濾鏡 -->
                  <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                    <feMerge> 
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                  
                  <!-- 數據流動畫 -->
                  <pattern id="dataFlowPattern" x="0" y="0" width="50" height="50" patternUnits="userSpaceOnUse">
                    <rect width="50" height="50" fill="none"/>
                    <line x1="0" y1="25" x2="50" y2="25" stroke="#00ffff" stroke-width="1" opacity="0.3">
                      <animate attributeName="stroke-dasharray" values="0,50;25,25;50,0" dur="2s" repeatCount="indefinite"/>
                    </line>
                    <line x1="25" y1="0" x2="25" y2="50" stroke="#ff00ff" stroke-width="1" opacity="0.2">
                      <animate attributeName="stroke-dasharray" values="0,50;25,25;50,0" dur="3s" repeatCount="indefinite"/>
                    </line>
                  </pattern>
                </defs>
                
                <!-- 基礎背景 -->
                <rect width="100%" height="100%" fill="url(#cyberpunkGradient)"/>
                
                <!-- 數據流網格 -->
                <rect width="100%" height="100%" fill="url(#dataFlowPattern)" opacity="0.4"/>
                
                <!-- 霓虹幾何形狀 -->
                <circle cx="512" cy="512" r="300" fill="none" stroke="#00ffff" stroke-width="3" opacity="0.6" filter="url(#neonGlow)">
                  <animate attributeName="r" values="300;320;300" dur="3s" repeatCount="indefinite"/>
                </circle>
                
                <circle cx="512" cy="512" r="200" fill="none" stroke="#ff00ff" stroke-width="2" opacity="0.4" filter="url(#neonGlow)">
                  <animate attributeName="r" values="200;210;200" dur="2s" repeatCount="indefinite"/>
                </circle>
                
                <!-- 六邊形框架 - 改為青色調 -->
                <polygon points="512,212 612,262 612,362 512,412 412,362 412,262" 
                         fill="none" stroke="#00cccc" stroke-width="2" opacity="0.4" filter="url(#neonGlow)"/>
                
                <!-- 掃描線效果 -->
                <rect x="0" y="200" width="1024" height="2" fill="#00ffff" opacity="0.8">
                  <animate attributeName="y" values="0;1024;0" dur="4s" repeatCount="indefinite"/>
                </rect>
              </svg>
            `;
            
            // 轉換為貼圖
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            this.cyberpunkTexture = loader.load(url, 
              (texture) => {
                console.log('賽博龐克背景紋理載入成功');
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                URL.revokeObjectURL(url);
              },
              undefined,
              (error) => {
                console.error('賽博龐克背景紋理載入失敗:', error);
                URL.revokeObjectURL(url);
              }
            );
            
            return this.cyberpunkTexture;
            
          } catch (error) {
            console.error('創建賽博龐克紋理失敗:', error);
            return null;
          }
        }

        /**
         * 處理商標貼圖 - 低飽和度和模糊效果
         */
        processLogoTexture(texture) {
          console.log('開始處理商標貼圖...');
          
          try {
            // 創建畫布進行圖像處理
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 等待圖像載入完成
            const img = texture.image;
            if (!img.complete) {
              img.onload = () => this.processLogoTexture(texture);
              return;
            }
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            // 繪製原始圖像
            ctx.drawImage(img, 0, 0);
            
            // 獲取圖像數據
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 進行低飽和度處理
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // 轉換為灰階
              const gray = 0.299 * r + 0.587 * g + 0.114 * b;
              
              // 降低飽和度 (保留30%的原始色彩)
              const saturationFactor = 0.3;
              data[i] = gray + (r - gray) * saturationFactor;     // R
              data[i + 1] = gray + (g - gray) * saturationFactor; // G
              data[i + 2] = gray + (b - gray) * saturationFactor; // B
              
              // 調整為賽博龐克色調 (藍紫色)
              data[i] = data[i] * 0.8;     // 降低紅色
              data[i + 1] = data[i + 1] * 0.9; // 稍微降低綠色
              data[i + 2] = data[i + 2] * 1.2; // 增強藍色
              
              // 整體透明度調整
              data[i + 3] = data[i + 3] * 0.7; // 降低透明度
            }
            
            // 將處理後的數據寫回畫布
            ctx.putImageData(imageData, 0, 0);
            
            // 應用模糊效果
            ctx.filter = 'blur(2px)';
            ctx.globalAlpha = 0.8;
            ctx.drawImage(canvas, 0, 0);
            
            // 創建新的紋理
            const processedTexture = new THREE.CanvasTexture(canvas);
            processedTexture.minFilter = THREE.LinearFilter;
            processedTexture.magFilter = THREE.LinearFilter;
            processedTexture.wrapS = THREE.ClampToEdgeWrapping;
            processedTexture.wrapT = THREE.ClampToEdgeWrapping;
            processedTexture.needsUpdate = true;
            
            // 替換原始紋理
            this.logoTexture = processedTexture;
            
            console.log('商標貼圖處理完成');
            
          } catch (error) {
            console.error('商標貼圖處理失敗:', error);
            this.createFallbackLogoTexture();
          }
        }

        /**
         * 創建後備商標紋理
         */
        createFallbackLogoTexture() {
          console.log('創建後備商標紋理...');
          
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            
            // 創建賽博龐克風格的MODA文字
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, 'rgba(102, 102, 204, 0.6)');
            gradient.addColorStop(0.5, 'rgba(136, 136, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(170, 170, 255, 0.2)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製MODA文字 - 增強對比度和可讀性
            const colors = this.getCurrentThemeColors();
            const isDarkTheme = this.currentTheme === 'dark';
            
            // 根據主題選擇適當的文字顏色，確保WCAG AA級對比度 (4.5:1)
            const textColor = isDarkTheme ? 'rgba(255, 255, 255, 0.9)' : 'rgba(51, 51, 51, 0.9)';
            const shadowColor = isDarkTheme ? 'rgba(0, 255, 255, 0.8)' : 'rgba(0, 102, 204, 0.8)';
            const strokeColor = isDarkTheme ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)';
            
            ctx.fillStyle = textColor;
            ctx.font = 'bold 140px "Noto Sans TC", "Microsoft JhengHei", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // 添加文字描邊增強對比
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 4;
            ctx.strokeText('MODA', canvas.width / 2, canvas.height / 2);
            
            // 繪製主文字
            ctx.fillText('MODA', canvas.width / 2, canvas.height / 2);
            
            // 添加光暈效果
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 25;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillText('MODA', canvas.width / 2, canvas.height / 2);
            
            const fallbackTexture = new THREE.CanvasTexture(canvas);
            fallbackTexture.minFilter = THREE.LinearFilter;
            fallbackTexture.magFilter = THREE.LinearFilter;
            fallbackTexture.needsUpdate = true;
            
            this.logoTexture = fallbackTexture;
            
            console.log('後備商標紋理創建完成');
            
          } catch (error) {
            console.error('後備商標紋理創建失敗:', error);
          }
        }

        /**
         * 預初始化3D場景和資源
         */
        preInitializeScene(container) {
          console.log('預初始化3D場景...');
          
          if (this.scene) {
            console.log('場景已存在，跳過預初始化');
            return true;
          }
          
          try {
            // 預創建場景組件
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, 1200/700, 0.1, 1000);
            
            // 預載入MODA背景
            this.createModaSvgTexture();
            
            // 創建背景平面
            this.createBackgroundPlane();
            
            // 預置粒子系統 - 暫時移除以實現簡約風格
            // this.initParticleSystem();
            
            console.log('場景預初始化完成');
            return true;
            
          } catch (error) {
            console.error('場景預初始化失敗:', error);
            return false;
          }
        }

        /**
         * 初始化音效系統
         */
        initAudioSystem() {
          console.log('初始化音效系統...');
          
          try {
            // 預載入音效文件
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // 卡片翻轉音效
            this.loadSound('cardFlip', 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGAZCECa0y6r');
            
            // 成功音效
            this.loadSound('success', 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGAZCECa0');
            
            console.log('音效系統初始化完成');
            return true;
            
          } catch (error) {
            console.warn('音效系統初始化失敗:', error);
            return false;
          }
        }

        /**
         * 載入音效文件
         */
        loadSound(name, dataUrl) {
          // 模擬音效載入 - 實際專案中會載入真實音效文件
          this.sounds = this.sounds || {};
          this.sounds[name] = { loaded: true, url: dataUrl };
        }

        /**
         * 播放音效
         */
        playSound(name) {
          if (this.sounds && this.sounds[name] && this.sounds[name].loaded) {
            console.log('播放音效:', name);
            // 實際播放邏輯
          }
        }

        /**
         * 創建賽博龐克風格的MODA背景平面 - 優化版本
         */
        createBackgroundPlane() {
          console.log('創建賽博龐克背景平面 - 優化版本...');
          
          try {
            // 大型遠景背景平面 - 確保覆蓋整個視窗
            const bgGeometry = new THREE.PlaneGeometry(80, 50);
            
            // 賽博龐克漸變背景
            let bgMaterial;
            if (this.cyberpunkTexture) {
              bgMaterial = new THREE.MeshLambertMaterial({
                map: this.cyberpunkTexture,
                transparent: true,
                opacity: 0.6, // 降低透明度避免搶眼
                side: THREE.DoubleSide
              });
            } else {
              // 後備賽博龐克漸變色彩
              bgMaterial = new THREE.MeshLambertMaterial({
                color: 0x1a0033, // 深紫色
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
              });
            }
            
            this.backgroundPlane = new THREE.Mesh(bgGeometry, bgMaterial);
            this.backgroundPlane.position.set(0, 0, -25); // 置於更遠距離作為遠景
            this.backgroundPlane.renderOrder = -15;
            
            // 商標背景平面 - 增強辨識度設計
            const logoGeometry = new THREE.PlaneGeometry(24, 24); // 大幅增大尺寸
            let logoMaterial;
            
            if (this.logoTexture) {
              logoMaterial = new THREE.MeshLambertMaterial({
                map: this.logoTexture,
                transparent: true,
                opacity: 0.6, // 提高透明度增強可見性
                alphaTest: 0.05,
                color: 0xaaaaff, // 提高飽和度增強對比
                blending: THREE.AdditiveBlending // 添加加法混合增強光效
              });
            } else {
              // 後備商標顯示 - 增強版
              logoMaterial = new THREE.MeshLambertMaterial({
                color: 0x8888ff, // 提高飽和度
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
              });
            }
            
            this.logoPlane = new THREE.Mesh(logoGeometry, logoMaterial);
            this.logoPlane.position.set(0, 0, -18); // 移到更前方增強可見性
            this.logoPlane.renderOrder = -8;
            
            // 添加logo專用脈動光暈
            this.createLogoEnhancedGlow();
            
            // 霓虹光暈效果圈 - 營造遠景霧化感
            // this.createNeonRings(); // 已移除線條光圈效果
            // this.createLogoGlowEffect(); // 已移除線條光圈效果
            
            if (this.scene) {
              this.scene.add(this.backgroundPlane);
              this.scene.add(this.logoPlane);
              console.log('賽博龐克背景和商標平面已添加到場景');
              console.log('場景中物件數量:', this.scene.children.length);
            } else {
              console.warn('場景不存在，無法添加背景平面');
            }
            
          } catch (error) {
            console.error('創建背景平面失敗:', error);
          }
        }

        /**
         * 創建logo增強脈動光暈
         */
        createLogoEnhancedGlow() {
          console.log('創建logo增強脈動光暈...');
          
          try {
            this.logoEnhancedGlows = [];
            
            // 多層強化光暈
            const enhancedGlows = [
              { radius: 15, opacity: 0.4, color: 0x6666ff, pulseSpeed: 1.0 },
              { radius: 20, opacity: 0.3, color: 0x8888ff, pulseSpeed: 1.2 },
              { radius: 26, opacity: 0.2, color: 0xaaaaff, pulseSpeed: 0.8 },
              { radius: 32, opacity: 0.15, color: 0xccccff, pulseSpeed: 1.5 }
            ];
            
            enhancedGlows.forEach((glowConfig, index) => {
              const glowGeometry = new THREE.RingGeometry(glowConfig.radius * 0.7, glowConfig.radius, 64);
              const glowMaterial = new THREE.MeshBasicMaterial({
                color: glowConfig.color,
                transparent: true,
                opacity: glowConfig.opacity,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
              });
              
              const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
              // 調整位置避免遮擋卡片區域，移至更遠背景
              glowRing.position.set(0, 0, -25 + index * 0.1);
              glowRing.renderOrder = -10 + index;
              
              // 增強脈動數據
              glowRing.userData = {
                rotationSpeed: 0.008 + index * 0.003,
                pulseSpeed: glowConfig.pulseSpeed,
                originalOpacity: glowConfig.opacity,
                scaleAmplitude: 0.15 + index * 0.05, // 減小縮放幅度避免過度干擾
                colorShift: index * 0.5
              };
              
              this.logoEnhancedGlows.push(glowRing);
              
              if (this.scene) {
                this.scene.add(glowRing);
              }
            });
            
            // 創建精細聚光點 - 使用Shader實現細膩光暈
            const spotGeometry = new THREE.CircleGeometry(3, 32); // 進一步縮小至3
            const spotMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                opacity: { value: 0.15 },
                color: { value: new THREE.Color(0x4dcccc) },
                intensity: { value: 0.8 }
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float opacity;
                uniform vec3 color;
                uniform float intensity;
                varying vec2 vUv;
                
                void main() {
                  vec2 center = vec2(0.5, 0.5);
                  float dist = distance(vUv, center);
                  
                  // 創建多層漸變光暈
                  float innerGlow = 1.0 - smoothstep(0.0, 0.3, dist);
                  innerGlow = pow(innerGlow, 4.0);
                  
                  float outerGlow = 1.0 - smoothstep(0.0, 0.8, dist);
                  outerGlow = pow(outerGlow, 2.0) * 0.3;
                  
                  // 添加時間變化
                  float pulse = sin(time * 2.0) * 0.2 + 0.8;
                  
                  float finalAlpha = (innerGlow + outerGlow) * opacity * intensity * pulse;
                  gl_FragColor = vec4(color, finalAlpha);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });
            
            this.logoSpotlight = new THREE.Mesh(spotGeometry, spotMaterial);
            // \u79fb\u81f3\u66f4\u9060\u80cc\u666f\u4f4d\u7f6e\u907f\u514d\u906e\u64cb\u5361\u7247
            this.logoSpotlight.position.set(0, 0, -22);
            this.logoSpotlight.renderOrder = -12;
            this.logoSpotlight.userData = {
              pulseSpeed: 2.0,
              originalOpacity: 0.3
            };
            
            this.logoEnhancedGlows.push(this.logoSpotlight);
            
            if (this.scene) {
              this.scene.add(this.logoSpotlight);
            }
            
            console.log('logo增強脈動光暈創建完成，數量:', this.logoEnhancedGlows.length);
            
          } catch (error) {
            console.error('創建logo增強光暈失敗:', error);
          }
        }

        /**
         * 創建商標光暈效果 - 霧化遠景感 (已移除線條光圈效果)
         */
        /*
        createLogoGlowEffect() {
          console.log('創建商標光暈效果...');
          
          try {
            // 創建多層光暈圈，營造霧化效果
            this.logoGlowRings = [];
            
            const glowRings = [
              { radius: 12, opacity: 0.15, color: 0x6666cc },
              { radius: 18, opacity: 0.10, color: 0x8888ff },
              { radius: 24, opacity: 0.06, color: 0xaaaaff }
            ];
            
            glowRings.forEach((glowConfig, index) => {
              const glowGeometry = new THREE.RingGeometry(glowConfig.radius, glowConfig.radius + 1, 32);
              const glowMaterial = new THREE.MeshBasicMaterial({
                color: glowConfig.color,
                transparent: true,
                opacity: glowConfig.opacity,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
              });
              
              const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
              // 進一步後移，確保不會干擾前景元素
              glowRing.position.set(0, 0, -28 + index * 0.1);
              glowRing.renderOrder = -15 + index;
              
              // 添加輕微模糊運動
              glowRing.userData = {
                rotationSpeed: 0.005 + index * 0.002,
                pulseSpeed: 1.2 + index * 0.3,
                originalOpacity: glowConfig.opacity
              };
              
              this.logoGlowRings.push(glowRing);
              
              if (this.scene) {
                this.scene.add(glowRing);
              }
            });
            
            console.log('商標光暈效果創建完成，數量:', this.logoGlowRings.length);
            
          } catch (error) {
            console.error('創建商標光暈效果失敗:', error);
          }
        }
        */

        /**
         * 創建霓虹光環效果
         */
        /**
         * 創建霓虹光環效果 (已移除線條光圈效果)
         */
        /*
        createNeonRings() {
          console.log('創建霓虹光環效果...');
          
          try {
            this.neonRings = [];
            
            // 創建多層光環 - 移除黃色，使用漸層青色調
            const ringColors = [0x00e6e6, 0xe600e6, 0x0099cc];
            const ringRadii = [12, 15, 18];
            
            ringColors.forEach((color, index) => {
              const ringGeometry = new THREE.RingGeometry(ringRadii[index], ringRadii[index] + 0.2, 64);
              const ringMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3 - index * 0.05,
                side: THREE.DoubleSide
              });
              
              const ring = new THREE.Mesh(ringGeometry, ringMaterial);
              // 調整霓虹環位置至更遠背景
              ring.position.set(0, 0, -26 + index * 0.1);
              ring.renderOrder = -13 + index;
              
              // 添加旋轉動畫數據
              ring.userData = {
                rotationSpeed: 0.01 + index * 0.005,
                pulsePeriod: 2 + index,
                originalOpacity: 0.3 - index * 0.05
              };
              
              this.neonRings.push(ring);
              
              if (this.scene) {
                this.scene.add(ring);
              }
            });
            
            console.log('霓虹光環創建完成，數量:', this.neonRings.length);
            
          } catch (error) {
            console.error('創建霓虹光環失敗:', error);
          }
        }
        */

        /**
         * 初始化賽博龐克粒子系統 - 升級版
         */
        // 移除非背景粒子系統 - 保持簡約賽博龐克風格
        /*
        initParticleSystem() {
          console.log('初始化賽博龐克粒子系統 - 升級版...');
          
          try {
            // 創建粒子貼圖atlas
            this.createParticleTextureAtlas();
            
            // 創建多樣化Sprite粒子
            this.createAdvancedSpriteParticles();
            
            // 保留原有粒子系統作為backup
            this.createDataFlowParticles();
            this.createEnergyParticles();
            this.createGlitchParticles();
            
            // 創建增強替代視覺特效
            this.createEnhancedVisualEffects();
            
            // 確保整體風格一致性
            this.ensureCyberpunkThemeConsistency();
            
          } catch (error) {
            console.error('粒子系統初始化失敗:', error);
          }
        }
        */

        /**
         * 創建粒子貼圖Atlas - 整合多種形狀 (已停用)
         */
        // 移除非背景粒子特效
        /*
        createParticleTextureAtlas() {
          console.log('創建粒子貼圖Atlas...');
          
          try {
            // 創建512x512的atlas畫布
            const atlasCanvas = document.createElement('canvas');
            const ctx = atlasCanvas.getContext('2d');
            atlasCanvas.width = 256; // 4x4格支援12+種粒子類型
            atlasCanvas.height = 256;
            
            // 清空畫布
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 256, 256);
            
            // 粒子類型配置 - 擴展細緻粒子系統
            const particleTypes = [
              { name: 'circle', size: 64, color: '#00ffff' },      // 圓形 - 0,0
              { name: 'star', size: 64, color: '#ff00ff' },        // 星形 - 64,0
              { name: 'diamond', size: 64, color: '#0099cc' },     // 菱形 - 深青藍色
              { name: 'cross', size: 64, color: '#ff6600' },       // 十字 - 192,0
              { name: 'hexagon', size: 64, color: '#6600ff' },     // 六邊形 - 256,0
              { name: 'triangle', size: 64, color: '#00ff66' },    // 三角形 - 320,0
              { name: 'line', size: 64, color: '#ff0066' },        // 線條 - 0,64
              { name: 'dot', size: 64, color: '#66ff00' },         // 點 - 64,64
              // 新增細緻粒子類型
              { name: 'smallCircle', size: 32, color: '#80cccc' }, // 小圓點
              { name: 'microDot', size: 16, color: '#66b3b3' },    // 微點
              { name: 'tinyLine', size: 24, color: '#4d9999' },    // 細線
              { name: 'sparkle', size: 20, color: '#33cccc' }      // 閃點
            ];
            
            // 繪製各種粒子形狀
            particleTypes.forEach((type, index) => {
              const x = (index % 4) * 64 + 32; // 4列排列支援更多粒子類型
              const y = Math.floor(index / 4) * 64 + 32; // 每行64像素
              
              ctx.save();
              ctx.translate(x, y);
              
              // 設定發光效果
              ctx.shadowColor = type.color;
              ctx.shadowBlur = 8;
              ctx.fillStyle = type.color;
              ctx.strokeStyle = type.color;
              ctx.lineWidth = 2;
              
              // 繪製不同形狀
              switch(type.name) {
                case 'circle':
                  ctx.beginPath();
                  ctx.arc(0, 0, 20, 0, Math.PI * 2);
                  ctx.fill();
                  break;
                  
                case 'star':
                  this.drawStar(ctx, 0, 0, 5, 20, 10);
                  ctx.fill();
                  break;
                  
                case 'diamond':
                  ctx.beginPath();
                  ctx.moveTo(0, -20);
                  ctx.lineTo(15, 0);
                  ctx.lineTo(0, 20);
                  ctx.lineTo(-15, 0);
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'cross':
                  ctx.beginPath();
                  ctx.moveTo(-15, -3);
                  ctx.lineTo(-3, -3);
                  ctx.lineTo(-3, -15);
                  ctx.lineTo(3, -15);
                  ctx.lineTo(3, -3);
                  ctx.lineTo(15, -3);
                  ctx.lineTo(15, 3);
                  ctx.lineTo(3, 3);
                  ctx.lineTo(3, 15);
                  ctx.lineTo(-3, 15);
                  ctx.lineTo(-3, 3);
                  ctx.lineTo(-15, 3);
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'hexagon':
                  this.drawHexagon(ctx, 0, 0, 18);
                  ctx.fill();
                  break;
                  
                case 'triangle':
                  ctx.beginPath();
                  ctx.moveTo(0, -18);
                  ctx.lineTo(16, 12);
                  ctx.lineTo(-16, 12);
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'line':
                  ctx.beginPath();
                  ctx.moveTo(-20, 0);
                  ctx.lineTo(20, 0);
                  ctx.lineWidth = 4;
                  ctx.stroke();
                  break;
                  
                case 'dot':
                  ctx.beginPath();
                  ctx.arc(0, 0, 8, 0, Math.PI * 2);
                  ctx.fill();
                  // 加上小光環
                  ctx.beginPath();
                  ctx.arc(0, 0, 15, 0, Math.PI * 2);
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  break;
                  
                // 新增細緻粒子類型繪製
                case 'smallCircle':
                  ctx.beginPath();
                  ctx.arc(0, 0, 6, 0, Math.PI * 2); // 小圓點
                  ctx.fill();
                  break;
                  
                case 'microDot':
                  ctx.beginPath();
                  ctx.arc(0, 0, 3, 0, Math.PI * 2); // 微點
                  ctx.fill();
                  // 添加細緻光暈
                  ctx.beginPath();
                  ctx.arc(0, 0, 8, 0, Math.PI * 2);
                  ctx.lineWidth = 0.5;
                  ctx.stroke();
                  break;
                  
                case 'tinyLine':
                  ctx.beginPath();
                  ctx.moveTo(-8, 0); // 細線
                  ctx.lineTo(8, 0);
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  // 交叉細線
                  ctx.beginPath();
                  ctx.moveTo(0, -8);
                  ctx.lineTo(0, 8);
                  ctx.stroke();
                  break;
                  
                case 'sparkle':
                  // 閃爍星形效果
                  ctx.beginPath();
                  ctx.moveTo(0, -6);
                  ctx.lineTo(1.5, -1.5);
                  ctx.lineTo(6, 0);
                  ctx.lineTo(1.5, 1.5);
                  ctx.lineTo(0, 6);
                  ctx.lineTo(-1.5, 1.5);
                  ctx.lineTo(-6, 0);
                  ctx.lineTo(-1.5, -1.5);
                  ctx.closePath();
                  ctx.fill();
                  break;
              }
              
              ctx.restore();
            });
            
            // 創建Three.js紋理
            this.particleAtlasTexture = new THREE.CanvasTexture(atlasCanvas);
            this.particleAtlasTexture.minFilter = THREE.LinearFilter;
            this.particleAtlasTexture.magFilter = THREE.LinearFilter;
            this.particleAtlasTexture.needsUpdate = true;
            
            // 保存粒子類型配置用於UV映射
            this.particleAtlasMap = particleTypes.map((type, index) => ({
              name: type.name,
              color: type.color,
              uvOffset: {
                x: (index % 4) / 4, // 4x4格布局
                y: Math.floor(index / 4) / 4
              },
              uvScale: { x: 1/4, y: 1/4 } // 更新UV縮放
            }));
            
            console.log('粒子貼圖Atlas創建完成，包含', particleTypes.length, '種形狀');
            
          } catch (error) {
            console.error('粒子貼圖Atlas創建失敗:', error);
          }
        }
        */

        /**
         * 繪製星形輔助函數
         */
        drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
          let rot = Math.PI / 2 * 3;
          let x = cx;
          let y = cy;
          const step = Math.PI / spikes;

          ctx.beginPath();
          ctx.moveTo(cx, cy - outerRadius);
          
          for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
          }
          
          ctx.lineTo(cx, cy - outerRadius);
          ctx.closePath();
        }

        /**
         * 繪製六邊形輔助函數
         */
        drawHexagon(ctx, cx, cy, radius) {
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = cx + radius * Math.cos(angle);
            const y = cy + radius * Math.sin(angle);
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
        }

        /**
         * 創建進階Sprite粒子系統 (已停用)
         */
        /*
        createAdvancedSpriteParticles() {
          console.log('創建進階Sprite粒子系統...');
          
          try {
            if (!this.particleAtlasTexture) {
              console.warn('粒子Atlas未準備就緒，跳過Sprite粒子創建');
              return;
            }
            
            // 創建多個粒子群組
            this.spriteParticleGroups = [];
            
            // 數據流粒子群組 - 避開中心區域，增強拖尾效果
            this.createSpriteGroup('dataFlow', {
              count: 35, // 減少數量降低干擾
              particleTypes: ['microDot', 'tinyLine', 'smallCircle', 'sparkle'], // 使用新的細緻粒子
              area: { width: 40, height: 15, depth: 6 }, // 縮小分布區域提升細膩度
              movement: { type: 'flow', speed: 0.04 }, // 稍微減速
              rhythm: { frequency: 1.5, amplitude: 0.2, phaseShift: 0 }, // 統一節奏頻率
              trail: { enabled: true, length: 6, fade: 0.85 }, // 縮短拖尾
              randomSize: { min: 0.4, max: 1.5 } // 縮小尺寸範圍
            });
            
            // 能量環粒子群組 - 縮小軌道半徑避免遮擋
            this.createSpriteGroup('energyRing', {
              count: 25, // 減少數量
              particleTypes: ['smallCircle', 'microDot', 'sparkle'], // 更小的能量環粒子
              area: { width: 12, height: 12, depth: 2 }, // 進一步縮小提升精細度
              movement: { type: 'orbital', radius: 8, speed: 0.015 }, // 縮小軌道半徑
              rhythm: { frequency: 1.5, amplitude: 0.25, phaseShift: Math.PI/3 }, // 統一節奏頻率
              trail: { enabled: true, length: 4, fade: 0.75 }, // 縮短拖尾
              randomSize: { min: 0.6, max: 1.2 } // 縮小尺寸
            });
            
            // 故障閃爍粒子群組 - 隨機形狀變化
            this.createSpriteGroup('glitch', {
              count: 20,
              particleTypes: ['cross', 'triangle', 'diamond', 'star'],
              area: { width: 25, height: 18, depth: 5 }, // 縮小故障粒子區域
              movement: { type: 'random', speed: 0.01 },
              rhythm: { frequency: 8.0, amplitude: 0.6, phaseShift: Math.PI/2 },
              trail: { enabled: false }, // 故障粒子不使用拖尾
              randomSize: { min: 0.3, max: 2.5 },
              shapeVariation: true // 啟用形狀變化
            });
            
            // 背景光點群組 - 多層次深度
            this.createSpriteGroup('ambient', {
              count: 60,
              particleTypes: ['microDot', 'smallCircle', 'tinyLine'], // 細緻背景粒子
              area: { width: 50, height: 30, depth: 10 }, // 縮小背景粒子區域
              movement: { type: 'drift', speed: 0.005 },
              rhythm: { frequency: 1.0, amplitude: 0.18, phaseShift: Math.PI }, // 調整為與主調相符
              trail: { enabled: true, length: 3, fade: 0.95 },
              randomSize: { min: 0.2, max: 1.0 }
            });
            
            // 新增：霓虹拖尾粒子群組
            this.createSpriteGroup('neonTrails', {
              count: 25,
              particleTypes: ['tinyLine', 'sparkle'], // 細緻能量流粒子
              area: { width: 35, height: 25, depth: 8 }, // 縮小能量流粒子區域
              movement: { type: 'wave', amplitude: 3, frequency: 0.5 },
              rhythm: { frequency: 1.5, amplitude: 0.4, phaseShift: Math.PI/4 }, // 統一節奏頻率
              trail: { enabled: true, length: 12, fade: 0.85 },
              randomSize: { min: 1.0, max: 2.5 },
              neonGlow: true
            });
            
            console.log('進階Sprite粒子系統創建完成，共', this.spriteParticleGroups.length, '個群組');
            
          } catch (error) {
            console.error('進階Sprite粒子系統創建失敗:', error);
          }
        }
        */

        /**
         * 創建Sprite粒子群組 (已停用)
         */
        /*
        createSpriteGroup(groupName, config) {
          try {
            const group = new THREE.Group();
            group.name = groupName;
            
            const sprites = [];
            
            for (let i = 0; i < config.count; i++) {
              // 隨機選擇粒子類型
              const particleType = config.particleTypes[Math.floor(Math.random() * config.particleTypes.length)];
              const atlasInfo = this.particleAtlasMap.find(p => p.name === particleType);
              
              if (!atlasInfo) continue;
              
              // 創建Sprite材質
              const spriteMaterial = new THREE.SpriteMaterial({
                map: this.particleAtlasTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                alphaTest: 0.1
              });
              
              // 設定UV映射到Atlas的正確位置
              spriteMaterial.map.offset.set(atlasInfo.uvOffset.x, atlasInfo.uvOffset.y);
              spriteMaterial.map.repeat.set(atlasInfo.uvScale.x, atlasInfo.uvScale.y);
              
              const sprite = new THREE.Sprite(spriteMaterial);
              
              // 設定初始位置
              sprite.position.set(
                (Math.random() - 0.5) * config.area.width,
                (Math.random() - 0.5) * config.area.height,
                (Math.random() - 0.5) * config.area.depth
              );
              
              // 設定隨機尺寸
              let size;
              if (config.randomSize) {
                size = config.randomSize.min + Math.random() * (config.randomSize.max - config.randomSize.min);
              } else {
                size = 0.5 + Math.random() * 1.5;
              }
              sprite.scale.setScalar(size);
              
              // 創建拖尾效果
              let trailSprites = [];
              if (config.trail && config.trail.enabled) {
                for (let t = 0; t < config.trail.length; t++) {
                  const trailMaterial = new THREE.SpriteMaterial({
                    map: this.particleAtlasTexture,
                    transparent: true,
                    opacity: spriteMaterial.opacity * Math.pow(config.trail.fade, t + 1),
                    blending: THREE.AdditiveBlending,
                    alphaTest: 0.1
                  });
                  
                  trailMaterial.map.offset.set(atlasInfo.uvOffset.x, atlasInfo.uvOffset.y);
                  trailMaterial.map.repeat.set(atlasInfo.uvScale.x, atlasInfo.uvScale.y);
                  
                  const trailSprite = new THREE.Sprite(trailMaterial);
                  trailSprite.position.copy(sprite.position);
                  trailSprite.scale.setScalar(size * (1 - t * 0.1));
                  trailSprite.renderOrder = sprite.renderOrder - t - 1;
                  
                  group.add(trailSprite);
                  trailSprites.push(trailSprite);
                }
              }
              
              // 保存動畫數據
              sprite.userData = {
                particleType: particleType,
                originalPosition: sprite.position.clone(),
                originalOpacity: spriteMaterial.opacity,
                originalScale: size,
                movement: config.movement,
                rhythm: {
                  frequency: config.rhythm.frequency + (Math.random() - 0.5) * 0.5,
                  amplitude: config.rhythm.amplitude + (Math.random() - 0.5) * 0.2,
                  phase: Math.random() * Math.PI * 2 + config.rhythm.phaseShift,
                  baseOpacity: spriteMaterial.opacity
                },
                velocity: new THREE.Vector3(
                  (Math.random() - 0.5) * 0.02,
                  (Math.random() - 0.5) * 0.02,
                  (Math.random() - 0.5) * 0.01
                ),
                orbitalAngle: Math.random() * Math.PI * 2,
                glitchTimer: Math.random() * 5,
                trailSprites: trailSprites, // 拖尾精靈陣列
                trailPositions: [], // 位置歷史記錄
                shapeVariation: config.shapeVariation || false,
                neonGlow: config.neonGlow || false
              };
              
              group.add(sprite);
              sprites.push(sprite);
            }
            
            // 保存群組資訊
            const groupData = {
              name: groupName,
              group: group,
              sprites: sprites,
              config: config
            };
            
            this.spriteParticleGroups.push(groupData);
            
            if (this.scene) {
              this.scene.add(group);
              console.log(`Sprite粒子群組 "${groupName}" 已添加到場景，包含${sprites.length}個粒子`);
            }
            
          } catch (error) {
            console.error(`創建Sprite粒子群組 "${groupName}" 失敗:`, error);
          }
        }

        /**
         * 創建數據流粒子效果 (已停用)
         */
        createDataFlowParticles() {
          const particleCount = 100;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          const velocities = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // 位置 - 分布在屏幕邊緣，模擬數據流入
            if (Math.random() < 0.5) {
              // 水平流動
              positions[i3] = Math.random() < 0.5 ? -25 : 25;
              positions[i3 + 1] = (Math.random() - 0.5) * 20;
              velocities[i3] = Math.random() < 0.5 ? 0.1 : -0.1;
              velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
            } else {
              // 垂直流動  
              positions[i3] = (Math.random() - 0.5) * 20;
              positions[i3 + 1] = Math.random() < 0.5 ? -15 : 15;
              velocities[i3] = (Math.random() - 0.5) * 0.02;
              velocities[i3 + 1] = Math.random() < 0.5 ? 0.08 : -0.08;
            }
            positions[i3 + 2] = (Math.random() - 0.5) * 5;
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
            
            // 賽博龐克色彩 - 青色系
            colors[i3] = 0.0;     // r
            colors[i3 + 1] = 1.0; // g
            colors[i3 + 2] = 1.0; // b
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
          
          const material = new THREE.PointsMaterial({
            size: 1.5, // 從 3 縮小至 1.5，減少大斑塊
            vertexColors: true,
            transparent: true,
            opacity: 0.5, // 降低透明度增強細膩感
            blending: THREE.AdditiveBlending
          });
          
          this.dataFlowParticles = new THREE.Points(geometry, material);
          this.dataFlowParticles.renderOrder = 2;
          
          if (this.scene) {
            this.scene.add(this.dataFlowParticles);
            console.log('數據流粒子已添加到場景');
          }
        }

        /**
         * 創建能量粒子效果
         */
        createEnergyParticles() {
          const particleCount = 50;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // 圓形分布在商標周圍
            const angle = (i / particleCount) * Math.PI * 2;
            const radius = 10 + Math.random() * 5;
            positions[i3] = Math.cos(angle) * radius;
            positions[i3 + 1] = Math.sin(angle) * radius;
            positions[i3 + 2] = -15 + Math.random() * 2;
            
            // 紫紅色能量
            colors[i3] = 1.0;     // r
            colors[i3 + 1] = 0.0; // g  
            colors[i3 + 2] = 1.0; // b
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          
          const material = new THREE.PointsMaterial({
            size: 2.5, // 從 6 縮小至 2.5，大幅減少斑塊尺寸
            vertexColors: true,
            transparent: true,
            opacity: 0.5, // 降低透明度避免過於突出
            blending: THREE.AdditiveBlending
          });
          
          this.energyParticles = new THREE.Points(geometry, material);
          this.energyParticles.renderOrder = 3;
          
          if (this.scene) {
            this.scene.add(this.energyParticles);
            console.log('能量粒子已添加到場景');
          }
        }

        /**
         * 創建故障閃爍粒子效果 (已停用)
         */
        /*
        createGlitchParticles() {
          const particleCount = 30;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // 隨機位置
            positions[i3] = (Math.random() - 0.5) * 30;
            positions[i3 + 1] = (Math.random() - 0.5) * 20;
            positions[i3 + 2] = (Math.random() - 0.5) * 8;
            
            // 黃色故障效果
            colors[i3] = 1.0;     // r
            colors[i3 + 1] = 1.0; // g
            colors[i3 + 2] = 0.0; // b
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          
          const material = new THREE.PointsMaterial({
            size: 3.0, // 從 8 縮小至 3，顯著減少故障粒子的斑塊感
            vertexColors: true,
            transparent: true,
            opacity: 0.4, // 進一步降低透明度
            blending: THREE.AdditiveBlending
          });
          
          this.glitchParticles = new THREE.Points(geometry, material);
          this.glitchParticles.renderOrder = 4;
          
          if (this.scene) {
            this.scene.add(this.glitchParticles);
            console.log('故障粒子已添加到場景');
          }
        }
        */

        /**
         * 創建增強替代視覺特效 - 細緻光暈、掃光條帶、漸層效果
         */
        createEnhancedVisualEffects() {
          if (!this.scene) return;
          
          try {
            // 1. 創建細緻漸層光暈系統
            this.createGradientHaloSystem();
            
            // 2. 創建動態掃光條帶
            this.createScanLightStrips();
            
            // 3. 創建環境光層
            this.createAmbientLightLayers();
            
            console.log('增強視覺特效系統已創建');
          } catch (error) {
            console.warn('增強視覺特效創建失敗:', error);
          }
        }

        /**
         * 創建漸層光暈系統
         */
        createGradientHaloSystem() {
          this.gradientHalos = [];
          
          const haloConfigs = [
            { radius: 12, intensity: 0.20, color: 0x00cccc, pulse: 1.2 }, // 增強內層光暈
            { radius: 18, intensity: 0.15, color: 0x0099cc, pulse: 1.0 }, // 增強中層光暈
            { radius: 25, intensity: 0.10, color: 0x0066cc, pulse: 0.8 }, // 增強外層光暈
            { radius: 35, intensity: 0.06, color: 0x004488, pulse: 0.6 }  // 新增遠景光暈
          ];
          
          haloConfigs.forEach((config, index) => {
            const haloGeometry = new THREE.RingGeometry(config.radius, config.radius + 3, 64);
            const haloMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                intensity: { value: config.intensity },
                color: { value: new THREE.Color(config.color) },
                pulseSpeed: { value: config.pulse }
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float intensity;
                uniform vec3 color;
                uniform float pulseSpeed;
                varying vec2 vUv;
                
                void main() {
                  vec2 center = vec2(0.5, 0.5);
                  float dist = distance(vUv, center);
                  
                  // 創建多層次柔和漸層
                  float innerGradient = 1.0 - smoothstep(0.0, 0.2, dist);
                  innerGradient = pow(innerGradient, 4.0);
                  
                  float midGradient = 1.0 - smoothstep(0.1, 0.4, dist);
                  midGradient = pow(midGradient, 2.5) * 0.6;
                  
                  float outerGradient = 1.0 - smoothstep(0.2, 0.5, dist);
                  outerGradient = pow(outerGradient, 1.5) * 0.3;
                  
                  // 組合漸層效果
                  float combinedGradient = innerGradient + midGradient + outerGradient;
                  
                  // 增強脈動效果
                  float pulse = sin(time * pulseSpeed) * 0.25 + 0.75;
                  float microPulse = sin(time * pulseSpeed * 3.0) * 0.1 + 0.9;
                  
                  // 動態色彩變化
                  vec3 dynamicColor = color;
                  float colorShift = sin(time * 0.5) * 0.1;
                  dynamicColor.rgb += vec3(colorShift * 0.5, colorShift, colorShift * 0.3);
                  
                  // 最終透明度與色彩
                  float alpha = combinedGradient * intensity * pulse * microPulse;
                  
                  gl_FragColor = vec4(dynamicColor, alpha);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              side: THREE.DoubleSide
            });
            
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 0, -30 - index * 0.5);
            halo.renderOrder = -20 - index;
            
            this.gradientHalos.push(halo);
            this.scene.add(halo);
          });
        }

        /**
         * 創建動態掃光條帶
         */
        createScanLightStrips() {
          this.scanStrips = [];
          
          // 增強掃光條帶系統 - 替代粒子效果
          for (let i = 0; i < 5; i++) { // 增加數量
            const stripGeometry = new THREE.PlaneGeometry(60, 0.8); // 稍微放大以補償粒子移除
            const stripMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                speed: { value: 0.3 + i * 0.15 }, // 多樣化速度
                intensity: { value: 0.25 - i * 0.04 }, // 增強強度
                color: { value: new THREE.Color(i % 2 === 0 ? 0x00cccc : 0x0099cc) } // 交替色彩
              },
              vertexShader: `
                varying vec2 vUv;
                void main() {
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
              `,
              fragmentShader: `
                uniform float time;
                uniform float speed;
                uniform float intensity;
                uniform vec3 color;
                varying vec2 vUv;
                
                void main() {
                  // 創建移動掃光效果
                  float scan = sin((vUv.x + time * speed) * 3.14159 * 4.0);
                  scan = pow(max(0.0, scan), 2.0);
                  
                  // 邊緣漸變
                  float edgeFade = 1.0 - abs(vUv.x - 0.5) * 2.0;
                  edgeFade = pow(edgeFade, 2.0);
                  
                  float alpha = scan * intensity * edgeFade;
                  gl_FragColor = vec4(color, alpha);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending,
              side: THREE.DoubleSide
            });
            
            const strip = new THREE.Mesh(stripGeometry, stripMaterial);
            // 更好的分佈定位
            strip.position.set(0, 12 - i * 6, -30 - i * 2); // 更分散的垂直分佈
            strip.renderOrder = -20 - i;
            
            this.scanStrips.push(strip);
            this.scene.add(strip);
          }
        }

        /**
         * 創建環境光層
         */
        createAmbientLightLayers() {
          this.ambientLayers = [];
          
          const layerConfigs = [
            { size: 70, opacity: 0.08, color: 0x003333, z: -35 }, // 增強近景環境光
            { size: 90, opacity: 0.06, color: 0x004444, z: -40 }, // 增強中景環境光
            { size: 110, opacity: 0.04, color: 0x002244, z: -45 }, // 增強遠景環境光
            { size: 130, opacity: 0.03, color: 0x001122, z: -50 }, // 新增最遠背景
            { size: 150, opacity: 0.02, color: 0x000033, z: -55 }  // 深遠背景層
          ];
          
          layerConfigs.forEach((config, index) => {
            const layerGeometry = new THREE.PlaneGeometry(config.size, config.size);
            const layerMaterial = new THREE.MeshBasicMaterial({
              color: config.color,
              transparent: true,
              opacity: config.opacity,
              blending: THREE.AdditiveBlending
            });
            
            const layer = new THREE.Mesh(layerGeometry, layerMaterial);
            layer.position.set(0, 0, config.z);
            layer.renderOrder = -30 - index;
            
            this.ambientLayers.push(layer);
            this.scene.add(layer);
          });
        }

        /**
         * 確保賽博龐克主題一致性與視覺平衡
         */
        ensureCyberpunkThemeConsistency() {
          const themeColors = this.getCurrentThemeColors();
          
          // 定義簡約風格的視覺平衡比例
          const backgroundIntensityMultiplier = 1.0; // 無粒子時保持背景強度
          const focusEnhancement = 1.5; // 更強的前景增強以突出卡片
          
          // 1. 調整漸層光暈 - 背景層級
          if (this.gradientHalos) {
            this.gradientHalos.forEach((halo, index) => {
              if (halo.material.uniforms) {
                const themeIntensity = this.currentTheme === 'dark' ? 0.8 : 0.5;
                const depthFactor = 1.0 - (index * 0.2); // 距離越遠強度越低
                halo.material.uniforms.intensity.value = 
                  halo.material.uniforms.intensity.value * themeIntensity * backgroundIntensityMultiplier * depthFactor;
              }
            });
          }
          
          // 2. 調整掃光條帶 - 背景特效
          if (this.scanStrips) {
            this.scanStrips.forEach((strip, index) => {
              if (strip.material.uniforms) {
                const baseIntensity = this.currentTheme === 'dark' ? 0.12 : 0.08;
                const layerFactor = 1.0 - (index * 0.15);
                strip.material.uniforms.intensity.value = baseIntensity * backgroundIntensityMultiplier * layerFactor;
              }
            });
          }
          
          // 3. 調整環境光層 - 最遠背景
          if (this.ambientLayers) {
            this.ambientLayers.forEach((layer, index) => {
              const baseOpacity = this.currentTheme === 'dark' ? 0.04 : 0.025;
              const distanceFactor = 1.0 - (index * 0.3);
              layer.material.opacity = baseOpacity * backgroundIntensityMultiplier * distanceFactor;
            });
          }
          
          // 4. 調整粒子系統整體強度 - 分層處理
          if (this.spriteParticleGroups) {
            this.spriteParticleGroups.forEach((groupData, groupIndex) => {
              const groupType = groupData.name;
              let intensityFactor = backgroundIntensityMultiplier;
              
              // 根據粒子群組類型調整
              switch(groupType) {
                case 'glitch':
                  intensityFactor *= 0.7; // 故障粒子更加微妙
                  break;
                case 'backgroundAmbient':
                  intensityFactor *= 0.5; // 背景粒子最低
                  break;
                case 'energyRing':
                  intensityFactor *= 0.8; // 能量環中等
                  break;
                default:
                  intensityFactor *= 0.75; // 其他粒子適中
              }
              
              groupData.sprites.forEach(sprite => {
                if (sprite.userData.rhythm) {
                  sprite.userData.rhythm.baseOpacity *= intensityFactor;
                  sprite.userData.originalScale *= (intensityFactor + 0.2); // 尺寸稍微溫和調整
                }
              });
            });
          }
          
          // 5. 調整Logo光暈效果 - 中景元素
          if (this.logoEnhancedGlows) {
            this.logoEnhancedGlows.forEach((glow, index) => {
              if (glow.userData) {
                const logoFactor = 0.7; // Logo效果適度降低
                if (glow.material.uniforms) {
                  glow.userData.originalOpacity *= logoFactor;
                } else {
                  glow.userData.originalOpacity *= logoFactor;
                }
              }
            });
          }
          
          // 6. 調整霓虹光環 - 中景裝飾
          if (this.neonRings) {
            this.neonRings.forEach((ring, index) => {
              const neonFactor = 0.6;
              ring.material.opacity *= neonFactor;
            });
          }
          
          console.log('簡約賽博龐克風格調整完成 (無粒子系統)');
          console.log('背景強度倍數:', backgroundIntensityMultiplier);
          console.log('前景增強倍數:', focusEnhancement);
        }

        /**
         * 更新增強視覺特效
         */
        updateEnhancedVisualEffects(time) {
          // 更新漸層光暈
          if (this.gradientHalos) {
            this.gradientHalos.forEach((halo, index) => {
              if (halo.material.uniforms) {
                halo.material.uniforms.time.value = time;
                halo.rotation.z = time * 0.1 * (1 + index * 0.5);
              }
            });
          }
          
          // 更新掃光條帶
          if (this.scanStrips) {
            this.scanStrips.forEach((strip, index) => {
              if (strip.material.uniforms) {
                strip.material.uniforms.time.value = time;
              }
            });
          }
          
          // 更新環境光層
          if (this.ambientLayers) {
            this.ambientLayers.forEach((layer, index) => {
              layer.rotation.z = time * 0.05 * (1 - index * 0.2);
            });
          }
        }

        /**
         * 更新賽博龐克動畫效果 - 性能優化版本
         */
        // 重構為專注背景和卡片效果的更新系統，集成性能監控
        updateParticles() {
          const time = Date.now() * 0.001;
          
          // 性能監控與自適應優化
          this.updatePerformanceMonitoring(time);
          
          // 動態性能優化：基於FPS調整更新頻率
          if (!this.lastUpdateTime) this.lastUpdateTime = 0;
          const deltaTime = time - this.lastUpdateTime;
          
          // 自適應幀率控制：高性能時60fps，低性能時30fps
          const targetFrameTime = this.performanceMetrics.adaptiveFrameTime || 0.033;
          if (deltaTime < targetFrameTime) return;
          this.lastUpdateTime = time;
          
          // 移除非背景粒子系統更新
          /*
          // 更新進階Sprite粒子系統
          if (this.spriteParticleGroups && this.spriteParticleGroups.length > 0) {
            this.updateAdvancedSpriteParticles(time, deltaTime);
          }
          
          // 更新數據流粒子（較低頻率）
          if (this.dataFlowParticles && time % 0.1 < 0.033) {
            this.updateDataFlowParticles(time);
          }
          
          // 更新能量粒子
          if (this.energyParticles) {
            this.updateEnergyParticles(time);
          }
          
          // 更新故障粒子（低頻率，節省性能）
          if (this.glitchParticles && time % 0.2 < 0.033) {
            this.updateGlitchParticles(time);
          }
          */
          
          // 保留背景視覺特效系統
          this.updateEnhancedVisualEffects(time);
          
          // 保留霓虹光環（背景裝飾）(已移除線條光圈效果)
          /*
          if (this.neonRings && this.neonRings.length > 0) {
            this.updateNeonRings(time);
          }
          */
          
          // 保留商標動畫
          if (this.logoPlane) {
            this.updateLogoAnimation(time);
          }
          
          // 保留卡片動態特效
          if (this.cards && this.cards.length > 0) {
            this.updateAccessibilityCardEffects(time, deltaTime);
            
            // 更新增強卡片動畫效果
            this.cards.forEach(card => {
              this.updateCardEnhancedAnimations(card, time);
            });
          }
          
          // 保留 Shader Material 更新
          this.updateShaderMaterials(time);
          
          // 更新動態光影系統
          this.updateDynamicLighting(time);
          
          // 保留鼠標互動效果
          this.updateMouseEffects(time);
        }

        /**
         * 更新自訂 Shader Material 的 uniforms
         */
        updateShaderMaterials(time) {
          if (!this.cards || this.cards.length === 0) return;
          
          this.cards.forEach(card => {
            if (!card.userData.effects) return;
            
            const effects = card.userData.effects;
            
            // 更新霓虹光暈 shader uniforms - 已移除底部光暈
            // if (effects.aura && effects.aura.material.uniforms) {
            //   effects.aura.material.uniforms.time.value = time;
            // }
            
            // 更新掃光條帶 shader uniforms (已簡化移除)
            /*
            if (effects.scanLine && effects.scanLine.material.uniforms) {
              effects.scanLine.material.uniforms.time.value = time;
            }
            */
          });
        }

        /**
         * 更新無障礙卡片動態特效輔助辨識
         */
        updateAccessibilityCardEffects(time, deltaTime) {
          if (!this.cards || this.cards.length === 0) return;
          
          const colors = this.getCurrentThemeColors();
          const cardColors = colors.accessibleCard;
          
          // 統一動畫節奏系統
          const animationRhythm = this.createUnifiedAnimationRhythm(time, this.cards.length);
          
          this.cards.forEach((card, index) => {
            if (!card.userData.effects) return;
            
            const effects = card.userData.effects;
            const isFlipped = card.userData.isFlipped;
            const isClickable = card.userData.clickable;
            
            // 使用卡片儲存的動態參數
            const scaleFactor = card.userData.scaleFactor || 1.0;
            const glowIntensity = card.userData.glowIntensity || 1.0;
            const focusEnhancement = card.userData.focusEnhancement || {};
            
            // 應用統一動畫節奏到卡片修飾元素
            this.applyUnifiedRhythmToCardDecorations(card, index, effects, animationRhythm, {
              scaleFactor, glowIntensity, focusEnhancement, isFlipped, isClickable, cardColors
            });
          });
        }

        /**
         * 創建統一動畫節奏系統 - 性能優化版
         */
        createUnifiedAnimationRhythm(time, cardCount) {
          // 基於卡片數量和性能調整整體動畫頻率
          const baseFrequency = Math.max(0.8, 2.0 - cardCount * 0.1); // 卡片越多，頻率越低
          const complexityReduction = Math.min(1.0, cardCount / 6); // 簡化因子
          
          // 性能自適應調整
          const performanceMultiplier = this.performanceMetrics ? 
            this.performanceMetrics.qualityLevel : 1.0;
          const optimizedFrequency = baseFrequency * (0.5 + performanceMultiplier * 0.5);
          
          return {
            // 主要脈動節奏（邊緣發光）- 性能優化
            mainPulse: {
              frequency: optimizedFrequency,
              phase: 0,
              amplitude: 0.3 * (1 - complexityReduction * 0.5) * performanceMultiplier,
              baseline: 0.7
            },
            
            // 次要閃爍節奏（掃光、前景）- 性能優化
            secondaryFlash: {
              frequency: optimizedFrequency * 1.5,
              phase: Math.PI / 3,
              amplitude: 0.2 * (1 - complexityReduction * 0.3) * performanceMultiplier,
              baseline: 0.8
            },
            
            // 陰影動態節奏（較慢）- 性能優化
            shadowRhythm: {
              frequency: optimizedFrequency * 0.4,
              phase: Math.PI / 6,
              amplitude: 0.2 * performanceMultiplier,
              baseline: 0.8
            },
            
            // 浮動動畫節奏（僅限少量卡片且高性能）
            floatRhythm: {
              frequency: optimizedFrequency * 0.5,
              amplitude: 0.05 * performanceMultiplier,
              enabled: cardCount <= 3 && performanceMultiplier > 0.7
            },
            
            // 複雜度控制 - 性能自適應
            complexity: {
              level: Math.max(0.3, (1.0 - complexityReduction) * performanceMultiplier),
              enableAdvancedEffects: cardCount <= 5 && performanceMultiplier > 0.6,
              enableColorShifts: cardCount <= 3 && performanceMultiplier > 0.8,
              performanceOptimized: performanceMultiplier < 1.0
            }
          };
        }

        /**
         * 應用統一節奏到卡片修飾元素
         */
        applyUnifiedRhythmToCardDecorations(card, index, effects, rhythm, params) {
          const { scaleFactor, glowIntensity, focusEnhancement, isFlipped, isClickable, cardColors } = params;
          const time = Date.now() * 0.001;
          
          // 1. 簡化邊緣發光 - 靜態或低頻脈動
          if (effects.edgeGlowLayers) {
            // 簡化為低頻率脈動 (原頻率的1/4)
            const simplePulse = 0.8 + Math.sin(time * 0.5) * 0.15; // 低頻率脈動
            
            effects.edgeGlowLayers.forEach((layer, layerIndex) => {
              if (!layer.material) return;
              
              // 基礎不透明度，減少計算
              let baseOpacity = glowIntensity * (0.8 - layerIndex * 0.1);
              
              // 只在可點擊時添加輕微增強
              if (isClickable) {
                baseOpacity *= 1.1; // 簡化點擊增強效果
              }
              
              // 應用簡化的脈動效果
              layer.material.opacity = Math.max(0.1, Math.min(1.0, baseOpacity * simplePulse));
            });
          }
          
          // 2. 統一掃光條帶動畫 (已簡化移除)
          /*
          if (effects.scanLine && effects.scanLine.material && effects.scanLine.material.uniforms) {
            const flash = rhythm.secondaryFlash;
            const flashIntensity = flash.baseline + 
              Math.sin(time * flash.frequency + flash.phase + index * 0.5) * flash.amplitude;
            
            effects.scanLine.material.uniforms.intensity.value = flashIntensity * glowIntensity;
            effects.scanLine.material.uniforms.time.value = time;
          }
          */
          
          // 3. 統一陰影動畫
          if (effects.shadowLayers) {
            const shadowRhythm = rhythm.shadowRhythm;
            const shadowIntensity = shadowRhythm.baseline + 
              Math.sin(time * shadowRhythm.frequency + shadowRhythm.phase + index * 0.3) * shadowRhythm.amplitude;
            
            effects.shadowLayers.forEach((shadow, shadowIndex) => {
              if (!shadow.material) return;
              
              const baseShadowOpacity = shadowIndex === 0 ? 
                cardColors.shadowIntensity : cardColors.shadowIntensity * 0.4;
              
              shadow.material.opacity = baseShadowOpacity * shadowIntensity;
              
              // 簡化的位移動畫
              if (rhythm.complexity.enableAdvancedEffects) {
                const offsetScale = 0.03 * rhythm.complexity.level;
                const offsetX = Math.sin(time * 0.5 + index * 0.4) * offsetScale;
                const offsetY = Math.cos(time * 0.6 + index * 0.4) * offsetScale;
                shadow.position.x = (shadow.userData.baseOffsetX || 0.075) + offsetX;
                shadow.position.y = (shadow.userData.baseOffsetY || -0.05) + offsetY;
              }
            });
          }
          
          // 4. 統一前景/背景光暈
          if (effects.frontGlow) {
            const flash = rhythm.secondaryFlash;
            let frontOpacity = 0.3;
            
            if (isClickable) {
              const clickFlash = Math.sin(time * 3 + index) * 0.1 + 0.9;
              frontOpacity = 0.3 + clickFlash * 0.2;
            }
            
            effects.frontGlow.material.opacity = frontOpacity;
          }
          
          // 5. 統一卡片浮動動畫（僅限少量卡片）
          if (rhythm.floatRhythm.enabled && scaleFactor > 1.2 && card.userData.settled) {
            const floatRhythm = rhythm.floatRhythm;
            const cardFloatPhase = index * (Math.PI / 3);
            const floatOffset = Math.sin(time * floatRhythm.frequency + cardFloatPhase) * 
                               floatRhythm.amplitude * scaleFactor;
            
            const originalY = card.userData.targetPosition ? card.userData.targetPosition.y : 0;
            card.position.y = originalY + floatOffset;
            
            // 輕微旋轉
            if (rhythm.complexity.enableAdvancedEffects) {
              const rotationOffset = Math.sin(time * floatRhythm.frequency * 0.7 + cardFloatPhase) * 0.01;
              card.rotation.z = rotationOffset;
            }
          }
          
          // 6. 統一顏色溫度調節（僅限少量卡片）
          if (rhythm.complexity.enableColorShifts && effects.edgeGlowLayers) {
            const isDarkTheme = this.currentTheme === 'dark';
            const colorShiftIntensity = 0.05 * rhythm.complexity.level;
            
            effects.edgeGlowLayers.forEach(layer => {
              if (layer.material && layer.material.color) {
                const targetColor = isDarkTheme ? 
                  new THREE.Color(cardColors.primaryBorder) : 
                  new THREE.Color(cardColors.glowColor);
                layer.material.color.lerp(targetColor, colorShiftIntensity);
              }
            });
          }
        }

        /**
         * 性能監控與自適應優化系統
         */
        updatePerformanceMonitoring(time) {
          if (!this.performanceMetrics) {
            this.performanceMetrics = {
              frameCount: 0,
              lastFPSCheck: time,
              fps: 60,
              renderTimes: [],
              adaptiveFrameTime: 0.016, // 60fps
              qualityLevel: 1.0,
              lowPerformanceCount: 0
            };
          }
          
          const metrics = this.performanceMetrics;
          metrics.frameCount++;
          
          // 每秒計算一次FPS
          if (time - metrics.lastFPSCheck >= 1.0) {
            metrics.fps = metrics.frameCount / (time - metrics.lastFPSCheck);
            metrics.frameCount = 0;
            metrics.lastFPSCheck = time;
            
            // 自適應性能調整
            this.adaptivePerformanceOptimization(metrics.fps);
            
            // 調試信息
            if (metrics.fps < 45) {
              console.log('性能警告: FPS=' + metrics.fps.toFixed(1) + ', 品質等級=' + metrics.qualityLevel.toFixed(2));
            }
          }
        }

        /**
         * 自適應性能優化
         */
        adaptivePerformanceOptimization(currentFPS) {
          const metrics = this.performanceMetrics;
          
          // 性能閾值設定
          const highPerformanceThreshold = 55; // 高性能閾值
          const lowPerformanceThreshold = 35;  // 低性能閾值
          
          if (currentFPS < lowPerformanceThreshold) {
            metrics.lowPerformanceCount++;
            
            // 降低品質等級
            if (metrics.qualityLevel > 0.3) {
              metrics.qualityLevel = Math.max(0.3, metrics.qualityLevel - 0.1);
              metrics.adaptiveFrameTime = 0.033; // 降至30fps
              
              // 應用性能優化措施
              this.applyPerformanceOptimizations();
              
              console.log('性能優化: 降低品質至' + (metrics.qualityLevel * 100).toFixed(0) + '%');
            }
          } else if (currentFPS > highPerformanceThreshold && metrics.lowPerformanceCount === 0) {
            // 恢復品質等級
            if (metrics.qualityLevel < 1.0) {
              metrics.qualityLevel = Math.min(1.0, metrics.qualityLevel + 0.05);
              metrics.adaptiveFrameTime = 0.016; // 恢復至60fps
              
              console.log('性能恢復: 提升品質至' + (metrics.qualityLevel * 100).toFixed(0) + '%');
            }
          }
          
          // 重置低性能計數器
          if (currentFPS > lowPerformanceThreshold) {
            metrics.lowPerformanceCount = Math.max(0, metrics.lowPerformanceCount - 1);
          }
        }

        /**
         * 應用性能優化措施
         */
        applyPerformanceOptimizations() {
          const qualityLevel = this.performanceMetrics.qualityLevel;
          
          // 1. 動態光源優化
          if (this.dynamicLights) {
            const lightReduction = Math.floor((1 - qualityLevel) * 2); // 最多減少2個光源
            
            this.dynamicLights.pointLights.forEach((light, index) => {
              light.visible = index < (3 - lightReduction);
            });
            
            this.dynamicLights.spotLights.forEach((light, index) => {
              light.visible = index < (2 - Math.floor(lightReduction / 2));
            });
          }
          
          // 2. 卡片效果複雜度調整
          if (this.cards) {
            this.cards.forEach(card => {
              if (card.userData.effects) {
                const effects = card.userData.effects;
                
                // 邊緣發光層數調整
                if (effects.edgeGlowLayers) {
                  const enabledLayers = Math.ceil(effects.edgeGlowLayers.length * qualityLevel);
                  effects.edgeGlowLayers.forEach((layer, index) => {
                    layer.visible = index < enabledLayers;
                  });
                }
                
                // 陰影層數調整
                if (effects.shadowLayers) {
                  const enabledShadows = Math.ceil(effects.shadowLayers.length * qualityLevel);
                  effects.shadowLayers.forEach((shadow, index) => {
                    shadow.visible = index < enabledShadows;
                  });
                }
              }
            });
          }
          
          // 3. 渲染器設定優化
          if (this.renderer) {
            // 低品質時關閉抗鋸齒
            if (qualityLevel < 0.7) {
              this.renderer.antialias = false;
            }
            
            // 調整渲染器精度
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1 + qualityLevel));
          }
        }

        /**
         * 獲取性能統計信息
         */
        getPerformanceStats() {
          if (!this.performanceMetrics) return null;
          
          return {
            fps: Math.round(this.performanceMetrics.fps),
            qualityLevel: Math.round(this.performanceMetrics.qualityLevel * 100),
            adaptiveFrameTime: this.performanceMetrics.adaptiveFrameTime,
            isOptimized: this.performanceMetrics.qualityLevel < 1.0
          };
        }

        /**
         * 綜合性能測試與動畫優化
         */
        performComprehensiveOptimizationTest() {
          console.log('🔄 開始綜合性能測試與動畫優化...');
          
          const startTime = performance.now();
          let testResults = {
            renderingPerformance: 'unknown',
            lightingComplexity: 'unknown',
            cardAnimationSmooth: 'unknown',
            userExperienceRating: 'unknown',
            optimizationRecommendations: []
          };
          
          try {
            // 1. 測試渲染性能
            const renderStart = performance.now();
            if (this.renderer) {
              this.renderer.render(this.scene, this.camera);
            }
            const renderTime = performance.now() - renderStart;
            
            if (renderTime < 8) {
              testResults.renderingPerformance = '優秀 (<8ms)';
            } else if (renderTime < 16) {
              testResults.renderingPerformance = '良好 (8-16ms)';
            } else {
              testResults.renderingPerformance = '需優化 (>16ms)';
              testResults.optimizationRecommendations.push('降低渲染複雜度');
            }
            
            // 2. 測試光影系統複雜度
            let activeLights = 0;
            if (this.dynamicLights) {
              activeLights += this.dynamicLights.pointLights.filter(l => l.visible).length;
              activeLights += this.dynamicLights.spotLights.filter(l => l.visible).length;
            }
            
            if (activeLights <= 3) {
              testResults.lightingComplexity = '最適化';
            } else if (activeLights <= 5) {
              testResults.lightingComplexity = '適中';
            } else {
              testResults.lightingComplexity = '過於複雜';
              testResults.optimizationRecommendations.push('減少動態光源數量');
            }
            
            // 3. 測試卡片動畫流暢度
            const cardCount = this.cards ? this.cards.length : 0;
            const effectComplexity = this.calculateCardEffectsComplexity();
            
            if (cardCount <= 3 && effectComplexity <= 5) {
              testResults.cardAnimationSmooth = '非常流暢';
            } else if (cardCount <= 6 && effectComplexity <= 8) {
              testResults.cardAnimationSmooth = '流暢';
            } else {
              testResults.cardAnimationSmooth = '可能卡頓';
              testResults.optimizationRecommendations.push('簡化卡片特效');
            }
            
            // 4. 綜合用戶體驗評級
            const currentFPS = this.performanceMetrics ? this.performanceMetrics.fps : 60;
            const qualityLevel = this.performanceMetrics ? this.performanceMetrics.qualityLevel : 1.0;
            
            if (currentFPS >= 55 && qualityLevel >= 0.9) {
              testResults.userExperienceRating = '極佳';
            } else if (currentFPS >= 45 && qualityLevel >= 0.7) {
              testResults.userExperienceRating = '良好';
            } else if (currentFPS >= 30 && qualityLevel >= 0.5) {
              testResults.userExperienceRating = '可接受';
            } else {
              testResults.userExperienceRating = '需改善';
              testResults.optimizationRecommendations.push('啟用性能優化模式');
            }
            
            // 5. 動畫節奏舒適度測試
            const rhythmComfortLevel = this.testAnimationRhythmComfort();
            if (rhythmComfortLevel < 0.7) {
              testResults.optimizationRecommendations.push('調整動畫節奏頻率');
            }
            
            const totalTime = performance.now() - startTime;
            
            // 輸出詳細測試結果
            console.log('✅ 性能測試完成 (耗時:', totalTime.toFixed(2), 'ms)');
            console.log('📊 測試結果:');
            console.log('  - 渲染性能:', testResults.renderingPerformance);
            console.log('  - 光影複雜度:', testResults.lightingComplexity);
            console.log('  - 卡片動畫:', testResults.cardAnimationSmooth);
            console.log('  - 用戶體驗:', testResults.userExperienceRating);
            console.log('  - FPS:', currentFPS.toFixed(1));
            console.log('  - 品質等級:', (qualityLevel * 100).toFixed(0) + '%');
            
            if (testResults.optimizationRecommendations.length > 0) {
              console.log('🔧 優化建議:');
              testResults.optimizationRecommendations.forEach((rec, index) => {
                console.log('  ' + (index + 1) + '. ' + rec);
              });
            } else {
              console.log('🎉 系統運行狀態最佳，無需額外優化！');
            }
            
          } catch (error) {
            console.error('❌ 性能測試過程中發生錯誤:', error);
            testResults.userExperienceRating = '測試失敗';
          }
          
          return testResults;
        }

        /**
         * 計算卡片特效複雜度
         */
        calculateCardEffectsComplexity() {
          if (!this.cards) return 0;
          
          let totalComplexity = 0;
          this.cards.forEach(card => {
            if (card.userData.effects) {
              const effects = card.userData.effects;
              if (effects.edgeGlowLayers) totalComplexity += effects.edgeGlowLayers.length;
              if (effects.shadowLayers) totalComplexity += effects.shadowLayers.length;
              if (effects.scanLine) totalComplexity += 1;
              if (effects.frontGlow) totalComplexity += 1;
            }
          });
          
          return totalComplexity;
        }

        /**
         * 測試動畫節奏舒適度
         */
        testAnimationRhythmComfort() {
          const cardCount = this.cards ? this.cards.length : 0;
          if (cardCount === 0) return 1.0;
          
          const rhythm = this.createUnifiedAnimationRhythm(Date.now() * 0.001, cardCount);
          
          // 評估頻率是否在舒適範圍內 (0.5-2.5 Hz)
          const mainFreq = rhythm.mainPulse.frequency;
          const secondaryFreq = rhythm.secondaryFlash.frequency;
          
          let comfortScore = 1.0;
          
          // 主頻率舒適度
          if (mainFreq < 0.5 || mainFreq > 2.5) {
            comfortScore -= 0.3;
          }
          
          // 次要頻率舒適度
          if (secondaryFreq < 0.5 || secondaryFreq > 3.0) {
            comfortScore -= 0.2;
          }
          
          // 振幅舒適度
          if (rhythm.mainPulse.amplitude > 0.4) {
            comfortScore -= 0.2;
          }
          
          return Math.max(0, comfortScore);
        }

        /**
         * 更新進階Sprite粒子系統 - 節奏化閃爍 (已停用)
         */
        /*
        updateAdvancedSpriteParticles(time, deltaTime) {
          if (!this.spriteParticleGroups) return;
          
          // 如果沒有傳入deltaTime，則計算它
          if (deltaTime === undefined) {
            if (!this.lastSpriteUpdateTime) this.lastSpriteUpdateTime = time;
            deltaTime = time - this.lastSpriteUpdateTime;
            this.lastSpriteUpdateTime = time;
          }
          
          this.spriteParticleGroups.forEach(groupData => {
            groupData.sprites.forEach(sprite => {
              const userData = sprite.userData;
              const rhythm = userData.rhythm;
              
              // 記錄當前位置用於拖尾效果
              if (userData.trailSprites && userData.trailSprites.length > 0) {
                userData.trailPositions.unshift(sprite.position.clone());
                if (userData.trailPositions.length > userData.trailSprites.length) {
                  userData.trailPositions.pop();
                }
              }
              
              // 1. 增強節奏化透明度閃爍 - 添加微小閃爍效果
              const baseRhythmOpacity = rhythm.baseOpacity + 
                Math.sin(time * rhythm.frequency + rhythm.phase) * rhythm.amplitude;
              
              // 添加高頻微閃爍效果
              const microFlicker = Math.sin(time * 15 + userData.rhythm.phase * 3) * 0.05;
              const subtleFlicker = Math.sin(time * 8 + userData.rhythm.phase * 2) * 0.08;
              
              // 組合所有閃爍效果
              const finalOpacity = baseRhythmOpacity + microFlicker + subtleFlicker;
              sprite.material.opacity = Math.max(0.05, Math.min(0.9, finalOpacity));
              
              // 2. 增強節奏化尺寸變化 - 添加細微浮動
              const baseRhythmScale = userData.originalScale + 
                Math.sin(time * rhythm.frequency * 0.7 + rhythm.phase) * userData.originalScale * 0.2;
              
              // 添加緩慢浮動效果
              const slowFloat = Math.sin(time * 0.5 + userData.rhythm.phase) * userData.originalScale * 0.1;
              const microPulse = Math.sin(time * 12 + userData.rhythm.phase * 4) * userData.originalScale * 0.03;
              
              // 組合所有尺寸變化
              const finalScale = baseRhythmScale + slowFloat + microPulse;
              sprite.scale.setScalar(Math.max(0.1, Math.min(2.0, finalScale)));
              
              // 2.5. 霓虹光暈效果
              if (userData.neonGlow) {
                const glowPulse = Math.sin(time * 3 + rhythm.phase) * 0.3 + 0.7;
                sprite.material.opacity *= glowPulse;
              }
              
              // 3. 全域細微位置浮動效果
              const globalFloatX = Math.sin(time * 0.3 + userData.rhythm.phase) * 0.08;
              const globalFloatY = Math.cos(time * 0.25 + userData.rhythm.phase * 1.5) * 0.06;
              const microTremor = {
                x: Math.sin(time * 18 + userData.rhythm.phase * 5) * 0.02,
                y: Math.cos(time * 20 + userData.rhythm.phase * 6) * 0.015
              };
              
              // 4. 根據運動類型更新位置
              switch (userData.movement.type) {
                case 'flow':
                  // 數據流：線性移動 + 細微浮動
                  sprite.position.add(userData.velocity);
                  sprite.position.x += globalFloatX + microTremor.x;
                  sprite.position.y += globalFloatY + microTremor.y;
                  
                  // 邊界重置
                  if (Math.abs(sprite.position.x) > 30) {
                    sprite.position.x = -Math.sign(sprite.position.x) * 30;
                  }
                  if (Math.abs(sprite.position.y) > 20) {
                    sprite.position.y = -Math.sign(sprite.position.y) * 20;
                  }
                  break;
                  
                case 'orbital':
                  // 軌道運動：圓形路徑 + 細微震顫
                  userData.orbitalAngle += userData.movement.speed;
                  const radius = userData.movement.radius + Math.sin(time + userData.rhythm.phase) * 1.5;
                  sprite.position.x = Math.cos(userData.orbitalAngle) * radius + globalFloatX + microTremor.x;
                  sprite.position.y = Math.sin(userData.orbitalAngle) * radius + globalFloatY + microTremor.y;
                  sprite.position.z = userData.originalPosition.z + Math.sin(time * 0.5 + userData.rhythm.phase) * 1.5;
                  break;
                  
                case 'random':
                  // 故障隨機移動
                  userData.glitchTimer -= deltaTime;
                  if (userData.glitchTimer <= 0) {
                    // 隨機瞬移
                    sprite.position.x += (Math.random() - 0.5) * 4;
                    sprite.position.y += (Math.random() - 0.5) * 4;
                    sprite.position.z += (Math.random() - 0.5) * 1;
                    userData.glitchTimer = 0.5 + Math.random() * 2;
                    
                    // 重置到邊界內
                    sprite.position.x = Math.max(-25, Math.min(25, sprite.position.x));
                    sprite.position.y = Math.max(-15, Math.min(15, sprite.position.y));
                  }
                  break;
                  
                case 'drift':
                  // 緩慢漂移
                  sprite.position.add(userData.velocity);
                  sprite.position.x += Math.sin(time * 0.3 + userData.rhythm.phase) * 0.01;
                  sprite.position.y += Math.cos(time * 0.25 + userData.rhythm.phase) * 0.008;
                  
                  // 邊界循環
                  if (Math.abs(sprite.position.x) > 45) {
                    sprite.position.x = -Math.sign(sprite.position.x) * 45;
                  }
                  if (Math.abs(sprite.position.y) > 30) {
                    sprite.position.y = -Math.sign(sprite.position.y) * 30;
                  }
                  break;
                  
                case 'wave':
                  // 波浪運動 - 霓虹拖尾專用
                  const waveAmplitude = userData.movement.amplitude || 3;
                  const waveFrequency = userData.movement.frequency || 0.5;
                  
                  // 基礎移動
                  sprite.position.add(userData.velocity);
                  
                  // 波浪效果
                  const waveOffset = Math.sin(time * waveFrequency + userData.rhythm.phase) * waveAmplitude;
                  sprite.position.y = userData.originalPosition.y + waveOffset;
                  
                  // Z軸螺旋運動
                  sprite.position.z = userData.originalPosition.z + Math.sin(time * 0.8 + userData.rhythm.phase) * 1.5;
                  
                  // 邊界重置
                  if (Math.abs(sprite.position.x) > 35) {
                    sprite.position.x = -Math.sign(sprite.position.x) * 35;
                    userData.originalPosition.y = sprite.position.y; // 更新基準Y位置
                  }
                  break;
              }
              
              // 4. 特殊效果：顏色脈動（改變sprite的材質色調）
              if (userData.particleType === 'star' || userData.particleType === 'hexagon') {
                // 對特定類型粒子添加色彩變換
                const colorPhase = time * 2 + userData.rhythm.phase;
                const hue = (Math.sin(colorPhase) + 1) * 0.5; // 0-1範圍
                // 這裡可以通過修改材質來實現色彩變化，但需要複製材質避免影響其他粒子
              }
              
              // 5. 更新拖尾效果
              if (userData.trailSprites && userData.trailSprites.length > 0 && userData.trailPositions.length > 0) {
                userData.trailSprites.forEach((trailSprite, trailIndex) => {
                  if (userData.trailPositions[trailIndex]) {
                    // 使用歷史位置更新拖尾
                    trailSprite.position.copy(userData.trailPositions[trailIndex]);
                    
                    // 拖尾透明度隨距離衰減
                    const fadeMultiplier = Math.pow(groupData.config.trail.fade, trailIndex + 1);
                    trailSprite.material.opacity = sprite.material.opacity * fadeMultiplier;
                    
                    // 拖尾尺寸衰減
                    const scaleMultiplier = 1 - (trailIndex * 0.1);
                    trailSprite.scale.setScalar(sprite.scale.x * scaleMultiplier);
                  }
                });
              }
              
              // 6. 形狀變化效果
              if (userData.shapeVariation && Math.random() < 0.01) { // 1%機率變化
                // 隨機切換到群組中的其他粒子類型
                const newType = groupData.config.particleTypes[Math.floor(Math.random() * groupData.config.particleTypes.length)];
                const newAtlasInfo = this.particleAtlasMap.find(p => p.name === newType);
                if (newAtlasInfo && newType !== userData.particleType) {
                  sprite.material.map.offset.set(newAtlasInfo.uvOffset.x, newAtlasInfo.uvOffset.y);
                  sprite.material.map.repeat.set(newAtlasInfo.uvScale.x, newAtlasInfo.uvScale.y);
                  userData.particleType = newType;
                }
              }
            });
          });
        }

        /**
         * 更新數據流粒子動畫 (已停用)
         */
        /*
        updateDataFlowParticles(time) {
          const positions = this.dataFlowParticles.geometry.attributes.position.array;
          const velocities = this.dataFlowParticles.geometry.attributes.velocity.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            // 根據速度移動粒子
            positions[i] += velocities[i];
            positions[i + 1] += velocities[i + 1];
            positions[i + 2] += velocities[i + 2];
            
            // 邊界重置 - 創建循環效果
            if (Math.abs(positions[i]) > 25) {
              positions[i] = -Math.sign(positions[i]) * 25;
            }
            if (Math.abs(positions[i + 1]) > 15) {
              positions[i + 1] = -Math.sign(positions[i + 1]) * 15;
            }
          }
          
          this.dataFlowParticles.geometry.attributes.position.needsUpdate = true;
        }

        /**
         * 更新能量粒子動畫 (已停用)
         */
        updateEnergyParticles(time) {
          const positions = this.energyParticles.geometry.attributes.position.array;
          
          for (let i = 0; i < positions.length; i += 3) {
            const particleIndex = i / 3;
            const angle = (particleIndex / (positions.length / 3)) * Math.PI * 2 + time * 0.5;
            const radius = 10 + Math.sin(time * 2 + particleIndex) * 2;
            
            // 圓形軌道運動
            positions[i] = Math.cos(angle) * radius;
            positions[i + 1] = Math.sin(angle) * radius;
            positions[i + 2] = -15 + Math.sin(time * 3 + particleIndex) * 1;
          }
          
          this.energyParticles.geometry.attributes.position.needsUpdate = true;
          this.energyParticles.rotation.z += 0.01;
        }

        /**
         * 更新故障粒子動畫 (已停用)
         */
        updateGlitchParticles(time) {
          // 故障效果 - 隨機閃爍和位移
          if (Math.random() < 0.1) { // 10% 機率觸發故障
            const positions = this.glitchParticles.geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
              if (Math.random() < 0.3) { // 30% 的粒子參與故障
                positions[i] += (Math.random() - 0.5) * 2;
                positions[i + 1] += (Math.random() - 0.5) * 2;
              }
            }
            
            this.glitchParticles.geometry.attributes.position.needsUpdate = true;
          }
          
          // 透明度閃爍
          this.glitchParticles.material.opacity = 0.3 + Math.sin(time * 10) * 0.3;
        }

        /**
         * 更新霓虹光環動畫 (已移除線條光圈效果)
         */
        /*
        updateNeonRings(time) {
          this.neonRings.forEach((ring, index) => {
            // 持續旋轉
            ring.rotation.z += ring.userData.rotationSpeed;
            
            // 脈動效果
            const pulse = Math.sin(time * ring.userData.pulsePeriod) * 0.3 + 0.7;
            ring.material.opacity = ring.userData.originalOpacity * pulse;
            
            // 輕微尺寸變化
            const scale = 1 + Math.sin(time * 1.5 + index) * 0.05;
            ring.scale.setScalar(scale);
          });
        }
        */

        /**
         * 更新商標動畫 - 增強版背景動效
         */
        updateLogoAnimation(time) {
          // 商標平面增強動效
          if (this.logoPlane) {
            this.logoPlane.rotation.z = Math.sin(time * 0.2) * 0.12; // 稍微增強旋轉
            
            // 增強浮動效果
            this.logoPlane.position.x = Math.sin(time * 0.3) * 0.8;
            this.logoPlane.position.y = Math.cos(time * 0.25) * 0.6;
            
            // 增強呼吸式透明度變化
            const baseOpacity = 0.6; // 提高基礎透明度
            this.logoPlane.material.opacity = baseOpacity + Math.sin(time * 0.8) * 0.2;
            
            // 增強尺寸脈動
            const scale = 1 + Math.sin(time * 1.2) * 0.15;
            this.logoPlane.scale.setScalar(scale);
          }
          
          // 更新logo增強光暈
          if (this.logoEnhancedGlows && this.logoEnhancedGlows.length > 0) {
            this.logoEnhancedGlows.forEach((glow, index) => {
              // 獨立旋轉
              glow.rotation.z += glow.userData.rotationSpeed;
              
              // 強化脈動效果 - 支援Shader材質
              const pulse = Math.sin(time * glow.userData.pulseSpeed + glow.userData.colorShift) * 0.6 + 0.4;
              
              if (glow.material.uniforms) {
                // Shader材質更新
                glow.material.uniforms.time.value = time;
                glow.material.uniforms.opacity.value = glow.userData.originalOpacity * pulse;
              } else {
                // 普通材質更新
                glow.material.opacity = glow.userData.originalOpacity * pulse;
              }
              
              // 動態尺寸變化
              const scaleBase = 1 + Math.sin(time * glow.userData.pulseSpeed * 0.5 + index) * glow.userData.scaleAmplitude;
              glow.scale.setScalar(scaleBase);
              
              // 同步位置飄移
              glow.position.x = Math.sin(time * 0.3) * 0.8;
              glow.position.y = Math.cos(time * 0.25) * 0.6;
            });
          }
          
          // 更新原有商標光暈效果 (已移除線條光圈效果)
          /*
          if (this.logoGlowRings && this.logoGlowRings.length > 0) {
            this.logoGlowRings.forEach((ring, index) => {
              // 獨立的旋轉速度
              ring.rotation.z += ring.userData.rotationSpeed;
              
              // 脈動效果，創造霧化感
              const pulse = Math.sin(time * ring.userData.pulseSpeed + index) * 0.4 + 0.6;
              ring.material.opacity = ring.userData.originalOpacity * pulse;
              
              // 輕微的尺寸變化
              const scale = 1 + Math.sin(time * 0.5 + index * 0.5) * 0.1;
              ring.scale.setScalar(scale);
              
              // 同步位置飄移
              ring.position.x = Math.sin(time * 0.3) * 0.8;
              ring.position.y = Math.cos(time * 0.25) * 0.6;
            });
          }
          */
          
          // 更新背景平面動畫
          if (this.backgroundPlane) {
            // 極緩慢的背景移動
            this.backgroundPlane.position.x = Math.sin(time * 0.05) * 1;
            this.backgroundPlane.position.y = Math.cos(time * 0.04) * 0.5;
            
            // 背景透明度微調
            const bgOpacity = 0.4 + Math.sin(time * 0.3) * 0.1;
            this.backgroundPlane.material.opacity = Math.min(bgOpacity, 0.6);
          }
        }

        /**
         * 根據主題切換調整色彩方案 - 統一管理版本
         */
        updateThemeColors(isDarkMode) {
          console.log('更新主題色彩:', isDarkMode ? '深色模式' : '淺色模式');
          
          try {
            // 更新當前主題
            this.currentTheme = isDarkMode ? 'dark' : 'light';
            const colors = this.getCurrentThemeColors();
            
            // 1. 更新渲染器背景色
            if (this.renderer) {
              this.renderer.setClearColor(colors.backgroundColor, 1.0);
            }
            
            // 2. 更新霓虹光環
            if (this.neonRings) {
              this.neonRings.forEach((ring, index) => {
                ring.material.color.setHex(colors.glowColors.primary);
                ring.userData.originalOpacity = (0.3 - index * 0.05) * colors.ringOpacityMultiplier;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 3. 更新傳統粒子系統
            if (this.dataFlowParticles) {
              this.dataFlowParticles.material.opacity = colors.particleOpacity.dataFlow;
            }
            if (this.energyParticles) {
              this.energyParticles.material.opacity = colors.particleOpacity.energy;
            }
            if (this.glitchParticles) {
              this.glitchParticles.material.opacity = colors.particleOpacity.glitch;
            }
            
            // 4. 更新Sprite粒子系統
            if (this.spriteParticleGroups) {
              this.spriteParticleGroups.forEach(groupData => {
                const opacityKey = this.getSpriteGroupOpacityKey(groupData.name);
                const targetOpacity = colors.particleOpacity[opacityKey] || colors.particleOpacity.ambient;
                
                groupData.sprites.forEach(sprite => {
                  sprite.userData.rhythm.baseOpacity = targetOpacity;
                  sprite.material.opacity = targetOpacity;
                });
              });
            }
            
            // 5. 更新商標和商標光暈
            if (this.logoPlane) {
              this.logoPlane.material.opacity = colors.logoOpacity;
              this.logoPlane.material.color.setHex(colors.logoColorTint);
            }
            
            if (this.logoGlowRings) {
              this.logoGlowRings.forEach((ring, index) => {
                ring.material.color.setHex(colors.glowColors.logoGlow);
                ring.userData.originalOpacity = (0.15 - index * 0.03) * colors.neonIntensity;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 6. 更新所有卡片無障礙特效色彩
            if (this.cards) {
              this.cards.forEach(card => {
                this.updateCardAccessibilityColors(card, colors);
              });
            }
            
            console.log('主題色彩更新完成，套用配色:', colors);
            
          } catch (error) {
            console.error('主題色彩更新失敗:', error);
          }
        }

        /**
         * 更新單張卡片的無障礙特效色彩
         */
        updateCardAccessibilityColors(card, colors) {
          if (!card.userData.effects) return;
          
          const effects = card.userData.effects;
          const cardColors = colors.accessibleCard;
          
          try {
            // 1. 更新光暈效果色彩
            if (effects.aura) {
              effects.aura.material.color.setHex(colors.cardEffects.aura);
            }
            
            // 2. 更新掃光線色彩
            if (effects.scanLine) {
              effects.scanLine.material.color.setHex(colors.cardEffects.scanLine);
            }
            
            // 3. 更新多層邊緣發光色彩
            if (effects.edgeGlowLayers) {
              effects.edgeGlowLayers.forEach((layer, index) => {
                if (!layer.material) return;
                
                switch (index) {
                  case 0: // 最外層
                    layer.material.color.setHex(cardColors.primaryBorder);
                    break;
                  case 1: // 中間層
                    layer.material.color.setHex(cardColors.secondaryBorder);
                    break;
                  case 2: // 內層
                    layer.material.color.setHex(cardColors.glowColor);
                    break;
                  default:
                    layer.material.color.setHex(cardColors.glowColor);
                }
              });
            }
            
            // 4. 更新背景遮罩色彩
            if (effects.backMask) {
              effects.backMask.material.color.setHex(cardColors.backOverlay);
            }
            
            // 5. 更新前景光暈色彩
            if (effects.frontGlow) {
              effects.frontGlow.material.color.setHex(cardColors.frontColor);
            }
            
            // 6. 更新陰影系統色彩
            if (effects.shadowLayers) {
              effects.shadowLayers.forEach(shadow => {
                if (shadow.material) {
                  shadow.material.color.setHex(cardColors.shadowColor);
                }
              });
            }
            
            // 7. 更新卡片材質色彩
            if (card.userData.frontMaterial) {
              card.userData.frontMaterial.color.setHex(cardColors.frontColor);
            }
            
            if (card.userData.backMaterial) {
              card.userData.backMaterial.color.setHex(cardColors.backBackground);
              
              // 重新創建背面紋理以應用新色彩
              if (card.userData.name) {
                const newBackTexture = this.createAccessibleTextTexture(card.userData.name, cardColors);
                card.userData.backMaterial.map = newBackTexture;
                card.userData.backMaterial.needsUpdate = true;
              }
            }
            
            console.log('卡片無障礙色彩更新完成:', card.userData.name);
            
          } catch (error) {
            console.error('卡片色彩更新失敗:', card.userData.name, error);
          }
        }

        /**
         * 根據Sprite群組名稱映射到透明度設定key
         */
        getSpriteGroupOpacityKey(groupName) {
          const mapping = {
            'dataFlow': 'dataFlow',
            'energyRing': 'energy',
            'glitch': 'glitch',
            'ambient': 'ambient'
          };
          return mapping[groupName] || 'ambient';
        }

        /**
         * 測試渲染函數 - 立即渲染一幀檢查場景
         */
        testRender() {
          if (!this.renderer || !this.scene || !this.camera) {
            console.warn('無法測試渲染 - 缺少必要組件');
            return;
          }
          
          console.log('執行測試渲染...');
          console.log('場景物件:', this.scene.children.map(child => child.type));
          
          // 更新粒子（如果存在）- 粒子系統已暫時移除
          // this.updateParticles();
          
          // 渲染一幀
          this.renderer.render(this.scene, this.camera);
          
          console.log('測試渲染完成');
        }

        /**
         * 性能監控和調整系統
         */
        initPerformanceMonitoring() {
          this.performanceStats = {
            frameCount: 0,
            lastFPSCheck: Date.now(),
            averageFPS: 60,
            lowFPSThreshold: 30,
            veryLowFPSThreshold: 20,
            optimizationLevel: 0, // 0-3級優化
            maxOptimizationLevel: 3
          };
          
          // 每秒檢查一次FPS
          setInterval(() => {
            this.checkPerformanceAndAdjust();
          }, 1000);
          
          console.log('增強性能監控系統已啟動');
        }

        /**
         * 檢查性能並自動調整視覺效果 - 多級優化
         */
        checkPerformanceAndAdjust() {
          const now = Date.now();
          const timeDiff = now - this.performanceStats.lastFPSCheck;
          const currentFPS = (this.performanceStats.frameCount * 1000) / timeDiff;
          
          this.performanceStats.averageFPS = (this.performanceStats.averageFPS + currentFPS) / 2;
          this.performanceStats.frameCount = 0;
          this.performanceStats.lastFPSCheck = now;
          
          const stats = this.performanceStats;
          
          // 多級性能優化策略
          if (stats.averageFPS < stats.veryLowFPSThreshold && stats.optimizationLevel < 3) {
            // 極低FPS：最高級優化
            stats.optimizationLevel = 3;
            this.applyOptimization(3);
            console.log('極低FPS檢測，啟用最高級優化:', stats.averageFPS.toFixed(1));
            
          } else if (stats.averageFPS < stats.lowFPSThreshold && stats.optimizationLevel < 2) {
            // 低FPS：中級優化
            stats.optimizationLevel = Math.min(2, stats.optimizationLevel + 1);
            this.applyOptimization(stats.optimizationLevel);
            console.log('低FPS檢測，優化等級提升至:', stats.optimizationLevel);
            
          } else if (stats.averageFPS > stats.lowFPSThreshold + 10 && stats.optimizationLevel > 0) {
            // FPS恢復：降低優化等級
            stats.optimizationLevel = Math.max(0, stats.optimizationLevel - 1);
            this.applyOptimization(stats.optimizationLevel);
            console.log('FPS恢復，優化等級降低至:', stats.optimizationLevel);
          }
        }

        /**
         * 應用多級性能優化
         */
        applyOptimization(level) {
          const config = this.dynamicLayoutConfig.performance;
          
          switch (level) {
            case 0: // 無優化 - 全特效
              config.enableFloatAnimation = true;
              config.enableHoverEffect = true;
              config.updateFrequency = 0.033; // 30fps
              this.setParticleQuality(1.0);
              this.setShaderQuality('high');
              break;
              
            case 1: // 輕度優化
              config.enableFloatAnimation = true;
              config.enableHoverEffect = true;
              config.updateFrequency = 0.04; // 25fps
              this.setParticleQuality(0.8);
              this.setShaderQuality('medium');
              break;
              
            case 2: // 中度優化
              config.enableFloatAnimation = false;
              config.enableHoverEffect = true;
              config.updateFrequency = 0.05; // 20fps
              this.setParticleQuality(0.6);
              this.setShaderQuality('medium');
              break;
              
            case 3: // 重度優化
              config.enableFloatAnimation = false;
              config.enableHoverEffect = false;
              config.updateFrequency = 0.067; // 15fps
              this.setParticleQuality(0.4);
              this.setShaderQuality('low');
              this.disableMouseEffects();
              break;
          }
          
          console.log(`應用優化等級 ${level}:`, config);
        }

        /**
         * 設定粒子系統品質
         */
        setParticleQuality(quality) {
          if (!this.spriteParticleGroups) return;
          
          this.spriteParticleGroups.forEach(groupData => {
            groupData.sprites.forEach(sprite => {
              // 調整粒子透明度
              if (sprite.material) {
                sprite.material.opacity *= quality;
              }
              
              // 禁用部分拖尾效果
              if (quality < 0.6 && sprite.userData.trailSprites) {
                sprite.userData.trailSprites.forEach(trailSprite => {
                  trailSprite.visible = false;
                });
              }
            });
          });
        }

        /**
         * 設定Shader品質
         */
        setShaderQuality(quality) {
          if (!this.cards) return;
          
          this.cards.forEach(card => {
            if (!card.userData.effects) return;
            
            const effects = card.userData.effects;
            
            // 調整Shader的複雜度
            if (effects.aura && effects.aura.material.uniforms) {
              switch (quality) {
                case 'high':
                  effects.aura.material.uniforms.pulseSpeed.value = 2.0;
                  break;
                case 'medium':
                  effects.aura.material.uniforms.pulseSpeed.value = 1.0;
                  break;
                case 'low':
                  effects.aura.material.uniforms.pulseSpeed.value = 0.5;
                  effects.aura.visible = false; // 完全隱藏複雜shader
                  break;
              }
            }
            
            if (effects.scanLine && quality === 'low') {
              effects.scanLine.visible = false;
            }
          });
        }

        /**
         * 禁用鼠標特效（重度優化時）
         */
        disableMouseEffects() {
          // 清除所有波紋效果
          if (this.mouseEffects.ripples) {
            this.mouseEffects.ripples.forEach(rippleData => {
              if (this.scene) {
                this.scene.remove(rippleData.mesh);
              }
              rippleData.mesh.geometry.dispose();
              rippleData.mesh.material.dispose();
            });
            this.mouseEffects.ripples = [];
          }
          
          // 禁用引力場
          this.mouseState.isMoving = false;
        }

        /**
         * 智能背景亮度調節 - 根據卡片數量動態調整
         */
        adjustBackgroundBrightness(cardCount) {
          console.log('根據卡片數量調整背景亮度:', cardCount);
          
          try {
            // 計算背景亮度係數 - 卡片越多，背景越暗
            const brightnessReduction = Math.min(0.7, cardCount * 0.05);
            const finalMultiplier = 1 - brightnessReduction;
            
            // 調整所有背景元素
            const elements = [
              { items: this.spriteParticleGroups, type: 'sprite' },
              { items: this.neonRings, type: 'neon' },
              { items: this.logoGlowRings, type: 'logoGlow' },
              { items: this.logoEnhancedGlows, type: 'logoEnhanced' }
            ];
            
            elements.forEach(element => {
              if (!element.items) return;
              
              if (element.type === 'sprite') {
                element.items.forEach(groupData => {
                  groupData.sprites.forEach(sprite => {
                    sprite.userData.rhythm.baseOpacity *= finalMultiplier;
                  });
                });
              } else {
                element.items.forEach(item => {
                  if (item.userData && item.userData.originalOpacity !== undefined) {
                    item.userData.originalOpacity *= finalMultiplier;
                    item.material.opacity = item.userData.originalOpacity;
                  }
                });
              }
            });
            
            // 調整背景平面透明度
            if (this.backgroundPlane) {
              this.backgroundPlane.material.opacity *= finalMultiplier;
            }
            
            console.log(`背景亮度已調節，減少${(brightnessReduction * 100).toFixed(1)}%`);
            
          } catch (error) {
            console.error('背景亮度調節失敗:', error);
          }
        }

        /**
         * 為低性能設備優化視覺效果 - 進階版本
         */
        optimizeForPerformance() {
          try {
            // 1. 減少傳統粒子數量和透明度
            if (this.dataFlowParticles) {
              this.dataFlowParticles.material.opacity *= 0.7;
            }
            if (this.energyParticles) {
              this.energyParticles.material.opacity *= 0.7;
            }
            if (this.glitchParticles) {
              this.glitchParticles.material.opacity *= 0.6;
            }
            
            // 2. 優化Sprite粒子系統 - 減少粒子數量
            if (this.spriteParticleGroups) {
              this.spriteParticleGroups.forEach(groupData => {
                // 隱藏一半的粒子來節省性能
                groupData.sprites.forEach((sprite, index) => {
                  if (index % 2 === 0) {
                    sprite.visible = false;
                  } else {
                    sprite.userData.rhythm.baseOpacity *= 0.7;
                  }
                });
              });
            }
            
            // 3. 降低光環效果
            if (this.neonRings) {
              this.neonRings.forEach(ring => {
                ring.userData.originalOpacity *= 0.6;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 4. 降低商標光暈效果
            if (this.logoGlowRings) {
              this.logoGlowRings.forEach(ring => {
                ring.userData.originalOpacity *= 0.7;
                ring.material.opacity = ring.userData.originalOpacity;
              });
            }
            
            // 5. 降低渲染解析度
            if (this.renderer && this.container) {
              const pixelRatio = Math.min(window.devicePixelRatio, 1.5); // 限制最大像素比
              this.renderer.setPixelRatio(pixelRatio);
              console.log('降低渲染像素比至:', pixelRatio);
            }
            
            // 6. 簡化紋理過濾
            if (this.particleAtlasTexture) {
              this.particleAtlasTexture.minFilter = THREE.LinearFilter;
              this.particleAtlasTexture.magFilter = THREE.LinearFilter;
              this.particleAtlasTexture.generateMipmaps = false;
            }
            
            console.log('已執行進階性能優化');
            
          } catch (error) {
            console.error('性能優化執行失敗:', error);
          }
        }

        /**
         * 統計效能資訊
         */
        getPerformanceStats() {
          const stats = {
            triangles: 0,
            geometries: 0,
            textures: 0,
            materials: 0,
            sprites: 0,
            lights: 0
          };
          
          if (this.renderer && this.renderer.info) {
            const info = this.renderer.info;
            stats.triangles = info.render.triangles;
            stats.geometries = info.memory.geometries;
            stats.textures = info.memory.textures;
            stats.materials = info.programs?.length || 0;
          }
          
          if (this.scene) {
            this.scene.traverse(object => {
              if (object.type === 'Sprite') stats.sprites++;
              if (object.type === 'DirectionalLight' || object.type === 'AmbientLight') stats.lights++;
            });
          }
          
          if (this.spriteParticleGroups) {
            this.spriteParticleGroups.forEach(group => {
              stats.sprites += group.sprites.length;
            });
          }
          
          return stats;
        }

        /**
         * 銷毀並清理所有Three.js資源
         */
        dispose() {
          console.log('開始清理Three.js資源...');
          
          try {
            // 停止動畫
            this.isAnimating = false;
            
            // 清理紋理
            if (this.logoTexture) {
              this.logoTexture.dispose();
            }
            if (this.cyberpunkTexture) {
              this.cyberpunkTexture.dispose();
            }
            
            // 清理幾何體和材質
            if (this.scene) {
              this.scene.traverse((object) => {
                if (object.geometry) {
                  object.geometry.dispose();
                }
                if (object.material) {
                  if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                  } else {
                    object.material.dispose();
                  }
                }
              });
            }
            
            // 清理渲染器
            if (this.renderer) {
              this.renderer.dispose();
            }
            
            console.log('Three.js資源清理完成');
            
          } catch (error) {
            console.error('資源清理過程中發生錯誤:', error);
          }
        }
      }
      
      // Create and expose ThreeJSAnimation instance
      window.threeJSAnimation = new ThreeJSAnimation();
      console.log('Three.js animation instance created and attached to window');
      window.threeJSLoadedSuccessfully = true;
      
    } catch (error) {
      console.error('Failed to create Three.js animation instance:', error);
      window.threeJSLoadedSuccessfully = false;
    }
  </script>
  <script src="js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Theme toggle button -->
  <button id="themeToggle" class="theme-toggle-button" aria-label="切換色彩模式">
    <span class="theme-icon-light">☀️</span>
    <span class="theme-icon-dark" style="display:none;">🌙</span>
  </button>
</body>
</html>
